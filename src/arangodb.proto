import "mesos/mesos.proto";

package arangodb;

// -----------------------------------------------------------------------------
// --SECTION--                                                            TARGET
// -----------------------------------------------------------------------------

// This is set from the outside by the user, usually via command line options,
// environment variables, or via the web UI later on. The mode and whether
// or not we use asynchronous replication cannot be changed after the first
// startup of the cluster.

// The framework regularly adapts the plan (see below) to changes in the target.

message Target {
  required uint32         instances = 1;
  repeated mesos.Resource minimal_resources = 2;
  repeated mesos.Resource additional_resources = 3;
  required uint32         number_ports = 4;
}



message Targets {
  required string mode = 1;
  required Target agents = 2;
  required Target coordinators = 3;
  required Target dbservers = 4;
  required Target secondaries = 5;
  optional bool   asynchronous_replication = 6;
}

// -----------------------------------------------------------------------------
// --SECTION--                                                              PLAN
// -----------------------------------------------------------------------------

// The plan is changed by the framework as a reaction to target changes or
// events. It reflects the intention of the framework and thus the state of
// the cluster it wants to achieve. Here we also store how much progress
// with respect to reservations and persistent volumes we have made so far.
// This data is also used to implement timeouts in ArangoManager.cpp.

// The framework reacts to offers and messages and events it gets and takes
// measures accordingly to implement the plan in the current cluster state,
// which is stored in the current part of the state (see below).

enum TaskPlanState {
  TASK_STATE_NEW               = 1;
  TASK_STATE_TRYING_TO_RESERVE = 2;
  TASK_STATE_TRYING_TO_PERSIST = 3;
  TASK_STATE_TRYING_TO_START   = 4;
  TASK_STATE_TRYING_TO_RESTART = 5;
  TASK_STATE_RUNNING           = 6;
  TASK_STATE_KILLED            = 7;
  TASK_STATE_FAILED_OVER       = 8;
}

// The persistence_id and the started timestamp are set whenever the
// state chances due to some reaction on an offer. The persistence_id is
// unset, if the entry refers to an ephemeral task (i.e. a coordinator).
// When the state goes back to TASK_STATE_NEW on a timeout, the 
// persistence_id and start timestamp are cleared.

message TaskPlan {
  required TaskPlanState state = 1 [default = TASK_STATE_NEW];

  required bool          is_primary = 2;
  optional string        persistence_id = 3;
  optional double        started = 4;
}



message TasksPlan {
  repeated TaskPlan entries = 1;
}



message Plan {
  required TasksPlan agents = 1;
  required TasksPlan coordinators = 2;
  required TasksPlan dbservers = 3;
  required TasksPlan secondaries = 4;
}

// -----------------------------------------------------------------------------
// --SECTION--                                                           CURRENT
// -----------------------------------------------------------------------------

// This current section of the state describes the current state of
// the cluster insofar it is known to the framework. It is constantly
// updated by incoming messages, events and measures taken by the
// framework. For each task there are essentially two entries, one for
// the resources used (ResourceCurrent) and another for the current
// state of the task. The mesos.TaskInfo describes the task and contains
// all information needed for Mesos and its docker containerizer to
// launch the task. The mesos.TaskStatus is the latest status update
// from Mesos about the task.

message ResourceCurrent {
  optional mesos.SlaveID        slave_id = 1;
  optional mesos.OfferID        offer_id = 2;
  repeated mesos.Resource       resources = 3;
  repeated uint32               ports = 4;
  optional string               hostname = 5;
  optional string               container_path = 6;
}

// The slave_id and offer_id and resources are set whenever an offer is
// found suitable for usage. For persistent tasks this can happen multiple
// times on the way from state TASK_STATE_NEW to TASK_STATE_RUNNING.
// When a timeout happens and the state goes back to TASK_STATE_NEW, then
// this information is cleared out.

message ResourcesCurrent {
  repeated ResourceCurrent entries = 1;
}



enum InstanceCurrentState {
  INSTANCE_STATE_UNUSED   = 1;
  INSTANCE_STATE_STARTING = 2;
  INSTANCE_STATE_RUNNING  = 3;
  INSTANCE_STATE_STOPPED  = 4;
}

// task_info is initialized by Caretaker::setTaskId, where essentially only
// the actual taskID is set and everything else is cleared out. task_status
// is cleared on that occasion as well. setTaskId is called just before the
// task is actually started in ArangoManager::startInstance.
// Just after that Caretaker::setTaskInfo is called, which sets task_info
// with the return value of the scheduler call, delivering feedback from
// the system about the starting of this particular task.
// Later, when status updates come in from the Mesos master, the local 
// information is updated in the ArangoManager::applyStatusUpdates, it
// calls Caretaker::setTaskStatus, which in turn sets task_status. Finally,
// the state is set by calling Caretaker::setInstanceState.


message InstanceCurrent {
  required InstanceCurrentState state = 1 [default = INSTANCE_STATE_UNUSED];

  optional mesos.TaskInfo       task_info = 2;
  optional mesos.TaskStatus     task_status = 3;
}



message InstancesCurrent {
  repeated InstanceCurrent entries = 1;
}



message Current {
  required ResourcesCurrent agency_resources = 1;
  required ResourcesCurrent coordinator_resources = 2;
  required ResourcesCurrent primary_dbserver_resources = 3;
  required ResourcesCurrent secondary_dbserver_resources = 4;

  required InstancesCurrent agents = 5;
  required InstancesCurrent coordinators = 6;
  required InstancesCurrent primary_dbservers = 7;
  required InstancesCurrent secondary_dbservers = 8;

  required bool             cluster_complete = 9;
  required bool             cluster_bootstrappedDBservers = 10;
  required bool             cluster_upgradedDB = 11;
  required bool             cluster_bootstrappedCoordinators = 12;
  required bool             cluster_initialized = 13;
}

// -----------------------------------------------------------------------------
// --SECTION--                                                             STATE
// -----------------------------------------------------------------------------

message State {
  optional mesos.FrameworkID framework_id = 1;
  required Targets           targets = 2;
  required Plan              plan = 3;
  required Current           current = 4;
}

// -----------------------------------------------------------------------------
// --SECTION--                                                       END-OF-FILE
// -----------------------------------------------------------------------------
