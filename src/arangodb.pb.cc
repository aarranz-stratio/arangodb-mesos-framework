// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: arangodb.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "arangodb.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace arangodb {

namespace {

const ::google::protobuf::Descriptor* TargetEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TargetEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* Target_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Target_reflection_ = NULL;
const ::google::protobuf::Descriptor* TasksPlanEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TasksPlanEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* TasksPlan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TasksPlan_reflection_ = NULL;
const ::google::protobuf::Descriptor* Plan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Plan_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourcesCurrentEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourcesCurrentEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourcesCurrent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourcesCurrent_reflection_ = NULL;
const ::google::protobuf::Descriptor* InstancesCurrentEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InstancesCurrentEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* InstancesCurrent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InstancesCurrent_reflection_ = NULL;
const ::google::protobuf::Descriptor* Current_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Current_reflection_ = NULL;
const ::google::protobuf::Descriptor* State_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  State_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ResourcesCurrentState_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* InstancesCurrentState_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_arangodb_2eproto() {
  protobuf_AddDesc_arangodb_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "arangodb.proto");
  GOOGLE_CHECK(file != NULL);
  TargetEntry_descriptor_ = file->message_type(0);
  static const int TargetEntry_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetEntry, instances_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetEntry, minimal_resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetEntry, additional_resouces_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetEntry, number_ports_),
  };
  TargetEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TargetEntry_descriptor_,
      TargetEntry::default_instance_,
      TargetEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TargetEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TargetEntry));
  Target_descriptor_ = file->message_type(1);
  static const int Target_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, agencies_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, coordinators_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, dbservers_),
  };
  Target_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Target_descriptor_,
      Target::default_instance_,
      Target_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Target));
  TasksPlanEntry_descriptor_ = file->message_type(2);
  static const int TasksPlanEntry_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksPlanEntry, is_primary_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksPlanEntry, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksPlanEntry, persistence_id_),
  };
  TasksPlanEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TasksPlanEntry_descriptor_,
      TasksPlanEntry::default_instance_,
      TasksPlanEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksPlanEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksPlanEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TasksPlanEntry));
  TasksPlan_descriptor_ = file->message_type(3);
  static const int TasksPlan_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksPlan, entries_),
  };
  TasksPlan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TasksPlan_descriptor_,
      TasksPlan::default_instance_,
      TasksPlan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksPlan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksPlan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TasksPlan));
  Plan_descriptor_ = file->message_type(4);
  static const int Plan_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Plan, agencies_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Plan, coordinators_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Plan, dbservers_),
  };
  Plan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Plan_descriptor_,
      Plan::default_instance_,
      Plan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Plan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Plan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Plan));
  ResourcesCurrentEntry_descriptor_ = file->message_type(5);
  static const int ResourcesCurrentEntry_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrentEntry, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrentEntry, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrentEntry, offer_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrentEntry, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrentEntry, ports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrentEntry, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrentEntry, container_path_),
  };
  ResourcesCurrentEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourcesCurrentEntry_descriptor_,
      ResourcesCurrentEntry::default_instance_,
      ResourcesCurrentEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrentEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrentEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourcesCurrentEntry));
  ResourcesCurrent_descriptor_ = file->message_type(6);
  static const int ResourcesCurrent_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrent, entries_),
  };
  ResourcesCurrent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourcesCurrent_descriptor_,
      ResourcesCurrent::default_instance_,
      ResourcesCurrent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourcesCurrent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourcesCurrent));
  InstancesCurrentEntry_descriptor_ = file->message_type(7);
  static const int InstancesCurrentEntry_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstancesCurrentEntry, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstancesCurrentEntry, task_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstancesCurrentEntry, task_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstancesCurrentEntry, ports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstancesCurrentEntry, hostname_),
  };
  InstancesCurrentEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InstancesCurrentEntry_descriptor_,
      InstancesCurrentEntry::default_instance_,
      InstancesCurrentEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstancesCurrentEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstancesCurrentEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InstancesCurrentEntry));
  InstancesCurrent_descriptor_ = file->message_type(8);
  static const int InstancesCurrent_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstancesCurrent, entries_),
  };
  InstancesCurrent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InstancesCurrent_descriptor_,
      InstancesCurrent::default_instance_,
      InstancesCurrent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstancesCurrent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InstancesCurrent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InstancesCurrent));
  Current_descriptor_ = file->message_type(9);
  static const int Current_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, agency_resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, coordinator_resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, primary_dbserver_resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, secondary_dbserver_resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, agencies_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, coordinators_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, primary_dbservers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, secondary_dbservers_),
  };
  Current_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Current_descriptor_,
      Current::default_instance_,
      Current_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Current));
  State_descriptor_ = file->message_type(10);
  static const int State_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, target_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, plan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, current_),
  };
  State_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      State_descriptor_,
      State::default_instance_,
      State_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(State));
  ResourcesCurrentState_descriptor_ = file->enum_type(0);
  InstancesCurrentState_descriptor_ = file->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_arangodb_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TargetEntry_descriptor_, &TargetEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Target_descriptor_, &Target::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TasksPlanEntry_descriptor_, &TasksPlanEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TasksPlan_descriptor_, &TasksPlan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Plan_descriptor_, &Plan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourcesCurrentEntry_descriptor_, &ResourcesCurrentEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourcesCurrent_descriptor_, &ResourcesCurrent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InstancesCurrentEntry_descriptor_, &InstancesCurrentEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InstancesCurrent_descriptor_, &InstancesCurrent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Current_descriptor_, &Current::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    State_descriptor_, &State::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_arangodb_2eproto() {
  delete TargetEntry::default_instance_;
  delete TargetEntry_reflection_;
  delete Target::default_instance_;
  delete Target_reflection_;
  delete TasksPlanEntry::default_instance_;
  delete TasksPlanEntry_reflection_;
  delete TasksPlan::default_instance_;
  delete TasksPlan_reflection_;
  delete Plan::default_instance_;
  delete Plan_reflection_;
  delete ResourcesCurrentEntry::default_instance_;
  delete ResourcesCurrentEntry_reflection_;
  delete ResourcesCurrent::default_instance_;
  delete ResourcesCurrent_reflection_;
  delete InstancesCurrentEntry::default_instance_;
  delete InstancesCurrentEntry_reflection_;
  delete InstancesCurrent::default_instance_;
  delete InstancesCurrent_reflection_;
  delete Current::default_instance_;
  delete Current_reflection_;
  delete State::default_instance_;
  delete State_reflection_;
}

void protobuf_AddDesc_arangodb_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::mesos::protobuf_AddDesc_mesos_2fmesos_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016arangodb.proto\022\010arangodb\032\021mesos/mesos."
    "proto\"\220\001\n\013TargetEntry\022\021\n\tinstances\030\001 \002(\r"
    "\022*\n\021minimal_resources\030\002 \003(\0132\017.mesos.Reso"
    "urce\022,\n\023additional_resouces\030\003 \003(\0132\017.meso"
    "s.Resource\022\024\n\014number_ports\030\004 \002(\r\"\226\001\n\006Tar"
    "get\022\014\n\004mode\030\001 \002(\t\022\'\n\010agencies\030\002 \002(\0132\025.ar"
    "angodb.TargetEntry\022+\n\014coordinators\030\003 \002(\013"
    "2\025.arangodb.TargetEntry\022(\n\tdbservers\030\004 \002"
    "(\0132\025.arangodb.TargetEntry\"^\n\016TasksPlanEn"
    "try\022\022\n\nis_primary\030\001 \002(\010\022 \n\010slave_id\030\002 \001("
    "\0132\016.mesos.SlaveID\022\026\n\016persistence_id\030\003 \001("
    "\t\"6\n\tTasksPlan\022)\n\007entries\030\001 \003(\0132\030.arango"
    "db.TasksPlanEntry\"\200\001\n\004Plan\022%\n\010agencies\030\001"
    " \002(\0132\023.arangodb.TasksPlan\022)\n\014coordinator"
    "s\030\002 \002(\0132\023.arangodb.TasksPlan\022&\n\tdbserver"
    "s\030\003 \002(\0132\023.arangodb.TasksPlan\"\200\002\n\025Resourc"
    "esCurrentEntry\022F\n\005state\030\001 \001(\0162\037.arangodb"
    ".ResourcesCurrentState:\026RESOURCE_STATE_U"
    "NKNOWN\022 \n\010slave_id\030\002 \001(\0132\016.mesos.SlaveID"
    "\022 \n\010offer_id\030\003 \001(\0132\016.mesos.OfferID\022\"\n\tre"
    "sources\030\004 \003(\0132\017.mesos.Resource\022\r\n\005ports\030"
    "\005 \003(\r\022\020\n\010hostname\030\006 \001(\t\022\026\n\016container_pat"
    "h\030\007 \001(\t\"D\n\020ResourcesCurrent\0220\n\007entries\030\001"
    " \003(\0132\037.arangodb.ResourcesCurrentEntry\"\313\001"
    "\n\025InstancesCurrentEntry\022E\n\005state\030\001 \001(\0162\037"
    ".arangodb.InstancesCurrentState:\025INSTANC"
    "E_STATE_UNUSED\022\"\n\ttask_info\030\002 \001(\0132\017.meso"
    "s.TaskInfo\022&\n\013task_status\030\003 \001(\0132\021.mesos."
    "TaskStatus\022\r\n\005ports\030\004 \003(\r\022\020\n\010hostname\030\005 "
    "\001(\t\"D\n\020InstancesCurrent\0220\n\007entries\030\001 \003(\013"
    "2\037.arangodb.InstancesCurrentEntry\"\314\003\n\007Cu"
    "rrent\0224\n\020agency_resources\030\001 \002(\0132\032.arango"
    "db.ResourcesCurrent\0229\n\025coordinator_resou"
    "rces\030\002 \002(\0132\032.arangodb.ResourcesCurrent\022>"
    "\n\032primary_dbserver_resources\030\003 \002(\0132\032.ara"
    "ngodb.ResourcesCurrent\022@\n\034secondary_dbse"
    "rver_resources\030\004 \002(\0132\032.arangodb.Resource"
    "sCurrent\022,\n\010agencies\030\005 \002(\0132\032.arangodb.In"
    "stancesCurrent\0220\n\014coordinators\030\006 \002(\0132\032.a"
    "rangodb.InstancesCurrent\0225\n\021primary_dbse"
    "rvers\030\007 \002(\0132\032.arangodb.InstancesCurrent\022"
    "7\n\023secondary_dbservers\030\010 \002(\0132\032.arangodb."
    "InstancesCurrent\"\225\001\n\005State\022(\n\014framework_"
    "id\030\001 \001(\0132\022.mesos.FrameworkID\022 \n\006target\030\002"
    " \002(\0132\020.arangodb.Target\022\034\n\004plan\030\003 \002(\0132\016.a"
    "rangodb.Plan\022\"\n\007current\030\004 \002(\0132\021.arangodb"
    ".Current*\352\001\n\025ResourcesCurrentState\022\032\n\026RE"
    "SOURCE_STATE_UNKNOWN\020\001\022\033\n\027RESOURCE_STATE"
    "_REQUIRED\020\002\022$\n RESOURCE_STATE_TRYING_TO_"
    "RESERVE\020\003\022$\n RESOURCE_STATE_TRYING_TO_PE"
    "RSIST\020\004\022\032\n\026RESOURCE_STATE_USEABLE\020\005\022\027\n\023R"
    "ESOURCE_STATE_USED\020\006\022\027\n\023RESOURCE_STATE_L"
    "OST\020\007*\207\001\n\025InstancesCurrentState\022\031\n\025INSTA"
    "NCE_STATE_UNUSED\020\001\022\033\n\027INSTANCE_STATE_STA"
    "RTING\020\002\022\032\n\026INSTANCE_STATE_RUNNING\020\003\022\032\n\026I"
    "NSTANCE_STATE_STOPPED\020\004", 2223);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "arangodb.proto", &protobuf_RegisterTypes);
  TargetEntry::default_instance_ = new TargetEntry();
  Target::default_instance_ = new Target();
  TasksPlanEntry::default_instance_ = new TasksPlanEntry();
  TasksPlan::default_instance_ = new TasksPlan();
  Plan::default_instance_ = new Plan();
  ResourcesCurrentEntry::default_instance_ = new ResourcesCurrentEntry();
  ResourcesCurrent::default_instance_ = new ResourcesCurrent();
  InstancesCurrentEntry::default_instance_ = new InstancesCurrentEntry();
  InstancesCurrent::default_instance_ = new InstancesCurrent();
  Current::default_instance_ = new Current();
  State::default_instance_ = new State();
  TargetEntry::default_instance_->InitAsDefaultInstance();
  Target::default_instance_->InitAsDefaultInstance();
  TasksPlanEntry::default_instance_->InitAsDefaultInstance();
  TasksPlan::default_instance_->InitAsDefaultInstance();
  Plan::default_instance_->InitAsDefaultInstance();
  ResourcesCurrentEntry::default_instance_->InitAsDefaultInstance();
  ResourcesCurrent::default_instance_->InitAsDefaultInstance();
  InstancesCurrentEntry::default_instance_->InitAsDefaultInstance();
  InstancesCurrent::default_instance_->InitAsDefaultInstance();
  Current::default_instance_->InitAsDefaultInstance();
  State::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_arangodb_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_arangodb_2eproto {
  StaticDescriptorInitializer_arangodb_2eproto() {
    protobuf_AddDesc_arangodb_2eproto();
  }
} static_descriptor_initializer_arangodb_2eproto_;
const ::google::protobuf::EnumDescriptor* ResourcesCurrentState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourcesCurrentState_descriptor_;
}
bool ResourcesCurrentState_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* InstancesCurrentState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InstancesCurrentState_descriptor_;
}
bool InstancesCurrentState_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int TargetEntry::kInstancesFieldNumber;
const int TargetEntry::kMinimalResourcesFieldNumber;
const int TargetEntry::kAdditionalResoucesFieldNumber;
const int TargetEntry::kNumberPortsFieldNumber;
#endif  // !_MSC_VER

TargetEntry::TargetEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TargetEntry::InitAsDefaultInstance() {
}

TargetEntry::TargetEntry(const TargetEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TargetEntry::SharedCtor() {
  _cached_size_ = 0;
  instances_ = 0u;
  number_ports_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TargetEntry::~TargetEntry() {
  SharedDtor();
}

void TargetEntry::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TargetEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TargetEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TargetEntry_descriptor_;
}

const TargetEntry& TargetEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

TargetEntry* TargetEntry::default_instance_ = NULL;

TargetEntry* TargetEntry::New() const {
  return new TargetEntry;
}

void TargetEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    instances_ = 0u;
    number_ports_ = 0u;
  }
  minimal_resources_.Clear();
  additional_resouces_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TargetEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 instances = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &instances_)));
          set_has_instances();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_minimal_resources;
        break;
      }

      // repeated .mesos.Resource minimal_resources = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_minimal_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_minimal_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_minimal_resources;
        if (input->ExpectTag(26)) goto parse_additional_resouces;
        break;
      }

      // repeated .mesos.Resource additional_resouces = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_additional_resouces:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_additional_resouces()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_additional_resouces;
        if (input->ExpectTag(32)) goto parse_number_ports;
        break;
      }

      // required uint32 number_ports = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_number_ports:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &number_ports_)));
          set_has_number_ports();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TargetEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 instances = 1;
  if (has_instances()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->instances(), output);
  }

  // repeated .mesos.Resource minimal_resources = 2;
  for (int i = 0; i < this->minimal_resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->minimal_resources(i), output);
  }

  // repeated .mesos.Resource additional_resouces = 3;
  for (int i = 0; i < this->additional_resouces_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->additional_resouces(i), output);
  }

  // required uint32 number_ports = 4;
  if (has_number_ports()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->number_ports(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TargetEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 instances = 1;
  if (has_instances()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->instances(), target);
  }

  // repeated .mesos.Resource minimal_resources = 2;
  for (int i = 0; i < this->minimal_resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->minimal_resources(i), target);
  }

  // repeated .mesos.Resource additional_resouces = 3;
  for (int i = 0; i < this->additional_resouces_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->additional_resouces(i), target);
  }

  // required uint32 number_ports = 4;
  if (has_number_ports()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->number_ports(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TargetEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 instances = 1;
    if (has_instances()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->instances());
    }

    // required uint32 number_ports = 4;
    if (has_number_ports()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->number_ports());
    }

  }
  // repeated .mesos.Resource minimal_resources = 2;
  total_size += 1 * this->minimal_resources_size();
  for (int i = 0; i < this->minimal_resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->minimal_resources(i));
  }

  // repeated .mesos.Resource additional_resouces = 3;
  total_size += 1 * this->additional_resouces_size();
  for (int i = 0; i < this->additional_resouces_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->additional_resouces(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TargetEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TargetEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TargetEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TargetEntry::MergeFrom(const TargetEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  minimal_resources_.MergeFrom(from.minimal_resources_);
  additional_resouces_.MergeFrom(from.additional_resouces_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_instances()) {
      set_instances(from.instances());
    }
    if (from.has_number_ports()) {
      set_number_ports(from.number_ports());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TargetEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TargetEntry::CopyFrom(const TargetEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TargetEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;

  for (int i = 0; i < minimal_resources_size(); i++) {
    if (!this->minimal_resources(i).IsInitialized()) return false;
  }
  for (int i = 0; i < additional_resouces_size(); i++) {
    if (!this->additional_resouces(i).IsInitialized()) return false;
  }
  return true;
}

void TargetEntry::Swap(TargetEntry* other) {
  if (other != this) {
    std::swap(instances_, other->instances_);
    minimal_resources_.Swap(&other->minimal_resources_);
    additional_resouces_.Swap(&other->additional_resouces_);
    std::swap(number_ports_, other->number_ports_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TargetEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TargetEntry_descriptor_;
  metadata.reflection = TargetEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Target::kModeFieldNumber;
const int Target::kAgenciesFieldNumber;
const int Target::kCoordinatorsFieldNumber;
const int Target::kDbserversFieldNumber;
#endif  // !_MSC_VER

Target::Target()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Target::InitAsDefaultInstance() {
  agencies_ = const_cast< ::arangodb::TargetEntry*>(&::arangodb::TargetEntry::default_instance());
  coordinators_ = const_cast< ::arangodb::TargetEntry*>(&::arangodb::TargetEntry::default_instance());
  dbservers_ = const_cast< ::arangodb::TargetEntry*>(&::arangodb::TargetEntry::default_instance());
}

Target::Target(const Target& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Target::SharedCtor() {
  _cached_size_ = 0;
  mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  agencies_ = NULL;
  coordinators_ = NULL;
  dbservers_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Target::~Target() {
  SharedDtor();
}

void Target::SharedDtor() {
  if (mode_ != &::google::protobuf::internal::kEmptyString) {
    delete mode_;
  }
  if (this != default_instance_) {
    delete agencies_;
    delete coordinators_;
    delete dbservers_;
  }
}

void Target::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Target::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Target_descriptor_;
}

const Target& Target::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

Target* Target::default_instance_ = NULL;

Target* Target::New() const {
  return new Target;
}

void Target::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mode()) {
      if (mode_ != &::google::protobuf::internal::kEmptyString) {
        mode_->clear();
      }
    }
    if (has_agencies()) {
      if (agencies_ != NULL) agencies_->::arangodb::TargetEntry::Clear();
    }
    if (has_coordinators()) {
      if (coordinators_ != NULL) coordinators_->::arangodb::TargetEntry::Clear();
    }
    if (has_dbservers()) {
      if (dbservers_ != NULL) dbservers_->::arangodb::TargetEntry::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Target::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string mode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mode()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mode().data(), this->mode().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_agencies;
        break;
      }

      // required .arangodb.TargetEntry agencies = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agencies:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agencies()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_coordinators;
        break;
      }

      // required .arangodb.TargetEntry coordinators = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coordinators:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coordinators()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_dbservers;
        break;
      }

      // required .arangodb.TargetEntry dbservers = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dbservers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dbservers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Target::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mode().data(), this->mode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->mode(), output);
  }

  // required .arangodb.TargetEntry agencies = 2;
  if (has_agencies()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->agencies(), output);
  }

  // required .arangodb.TargetEntry coordinators = 3;
  if (has_coordinators()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->coordinators(), output);
  }

  // required .arangodb.TargetEntry dbservers = 4;
  if (has_dbservers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->dbservers(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Target::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mode().data(), this->mode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->mode(), target);
  }

  // required .arangodb.TargetEntry agencies = 2;
  if (has_agencies()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->agencies(), target);
  }

  // required .arangodb.TargetEntry coordinators = 3;
  if (has_coordinators()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->coordinators(), target);
  }

  // required .arangodb.TargetEntry dbservers = 4;
  if (has_dbservers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->dbservers(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Target::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mode());
    }

    // required .arangodb.TargetEntry agencies = 2;
    if (has_agencies()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agencies());
    }

    // required .arangodb.TargetEntry coordinators = 3;
    if (has_coordinators()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coordinators());
    }

    // required .arangodb.TargetEntry dbservers = 4;
    if (has_dbservers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dbservers());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Target::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Target* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Target*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Target::MergeFrom(const Target& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_agencies()) {
      mutable_agencies()->::arangodb::TargetEntry::MergeFrom(from.agencies());
    }
    if (from.has_coordinators()) {
      mutable_coordinators()->::arangodb::TargetEntry::MergeFrom(from.coordinators());
    }
    if (from.has_dbservers()) {
      mutable_dbservers()->::arangodb::TargetEntry::MergeFrom(from.dbservers());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Target::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Target::CopyFrom(const Target& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Target::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_agencies()) {
    if (!this->agencies().IsInitialized()) return false;
  }
  if (has_coordinators()) {
    if (!this->coordinators().IsInitialized()) return false;
  }
  if (has_dbservers()) {
    if (!this->dbservers().IsInitialized()) return false;
  }
  return true;
}

void Target::Swap(Target* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(agencies_, other->agencies_);
    std::swap(coordinators_, other->coordinators_);
    std::swap(dbservers_, other->dbservers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Target::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Target_descriptor_;
  metadata.reflection = Target_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TasksPlanEntry::kIsPrimaryFieldNumber;
const int TasksPlanEntry::kSlaveIdFieldNumber;
const int TasksPlanEntry::kPersistenceIdFieldNumber;
#endif  // !_MSC_VER

TasksPlanEntry::TasksPlanEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TasksPlanEntry::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

TasksPlanEntry::TasksPlanEntry(const TasksPlanEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TasksPlanEntry::SharedCtor() {
  _cached_size_ = 0;
  is_primary_ = false;
  slave_id_ = NULL;
  persistence_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TasksPlanEntry::~TasksPlanEntry() {
  SharedDtor();
}

void TasksPlanEntry::SharedDtor() {
  if (persistence_id_ != &::google::protobuf::internal::kEmptyString) {
    delete persistence_id_;
  }
  if (this != default_instance_) {
    delete slave_id_;
  }
}

void TasksPlanEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TasksPlanEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TasksPlanEntry_descriptor_;
}

const TasksPlanEntry& TasksPlanEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

TasksPlanEntry* TasksPlanEntry::default_instance_ = NULL;

TasksPlanEntry* TasksPlanEntry::New() const {
  return new TasksPlanEntry;
}

void TasksPlanEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    is_primary_ = false;
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_persistence_id()) {
      if (persistence_id_ != &::google::protobuf::internal::kEmptyString) {
        persistence_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TasksPlanEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool is_primary = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_primary_)));
          set_has_is_primary();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slave_id;
        break;
      }

      // optional .mesos.SlaveID slave_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_persistence_id;
        break;
      }

      // optional string persistence_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_persistence_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_persistence_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->persistence_id().data(), this->persistence_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TasksPlanEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool is_primary = 1;
  if (has_is_primary()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->is_primary(), output);
  }

  // optional .mesos.SlaveID slave_id = 2;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->slave_id(), output);
  }

  // optional string persistence_id = 3;
  if (has_persistence_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->persistence_id().data(), this->persistence_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->persistence_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TasksPlanEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool is_primary = 1;
  if (has_is_primary()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->is_primary(), target);
  }

  // optional .mesos.SlaveID slave_id = 2;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->slave_id(), target);
  }

  // optional string persistence_id = 3;
  if (has_persistence_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->persistence_id().data(), this->persistence_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->persistence_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TasksPlanEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool is_primary = 1;
    if (has_is_primary()) {
      total_size += 1 + 1;
    }

    // optional .mesos.SlaveID slave_id = 2;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // optional string persistence_id = 3;
    if (has_persistence_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->persistence_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TasksPlanEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TasksPlanEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TasksPlanEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TasksPlanEntry::MergeFrom(const TasksPlanEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_is_primary()) {
      set_is_primary(from.is_primary());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_persistence_id()) {
      set_persistence_id(from.persistence_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TasksPlanEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TasksPlanEntry::CopyFrom(const TasksPlanEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TasksPlanEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  return true;
}

void TasksPlanEntry::Swap(TasksPlanEntry* other) {
  if (other != this) {
    std::swap(is_primary_, other->is_primary_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(persistence_id_, other->persistence_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TasksPlanEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TasksPlanEntry_descriptor_;
  metadata.reflection = TasksPlanEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TasksPlan::kEntriesFieldNumber;
#endif  // !_MSC_VER

TasksPlan::TasksPlan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TasksPlan::InitAsDefaultInstance() {
}

TasksPlan::TasksPlan(const TasksPlan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TasksPlan::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TasksPlan::~TasksPlan() {
  SharedDtor();
}

void TasksPlan::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TasksPlan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TasksPlan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TasksPlan_descriptor_;
}

const TasksPlan& TasksPlan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

TasksPlan* TasksPlan::default_instance_ = NULL;

TasksPlan* TasksPlan::New() const {
  return new TasksPlan;
}

void TasksPlan::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TasksPlan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .arangodb.TasksPlanEntry entries = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TasksPlan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .arangodb.TasksPlanEntry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TasksPlan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .arangodb.TasksPlanEntry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TasksPlan::ByteSize() const {
  int total_size = 0;

  // repeated .arangodb.TasksPlanEntry entries = 1;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TasksPlan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TasksPlan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TasksPlan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TasksPlan::MergeFrom(const TasksPlan& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TasksPlan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TasksPlan::CopyFrom(const TasksPlan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TasksPlan::IsInitialized() const {

  for (int i = 0; i < entries_size(); i++) {
    if (!this->entries(i).IsInitialized()) return false;
  }
  return true;
}

void TasksPlan::Swap(TasksPlan* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TasksPlan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TasksPlan_descriptor_;
  metadata.reflection = TasksPlan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Plan::kAgenciesFieldNumber;
const int Plan::kCoordinatorsFieldNumber;
const int Plan::kDbserversFieldNumber;
#endif  // !_MSC_VER

Plan::Plan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Plan::InitAsDefaultInstance() {
  agencies_ = const_cast< ::arangodb::TasksPlan*>(&::arangodb::TasksPlan::default_instance());
  coordinators_ = const_cast< ::arangodb::TasksPlan*>(&::arangodb::TasksPlan::default_instance());
  dbservers_ = const_cast< ::arangodb::TasksPlan*>(&::arangodb::TasksPlan::default_instance());
}

Plan::Plan(const Plan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Plan::SharedCtor() {
  _cached_size_ = 0;
  agencies_ = NULL;
  coordinators_ = NULL;
  dbservers_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Plan::~Plan() {
  SharedDtor();
}

void Plan::SharedDtor() {
  if (this != default_instance_) {
    delete agencies_;
    delete coordinators_;
    delete dbservers_;
  }
}

void Plan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Plan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Plan_descriptor_;
}

const Plan& Plan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

Plan* Plan::default_instance_ = NULL;

Plan* Plan::New() const {
  return new Plan;
}

void Plan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_agencies()) {
      if (agencies_ != NULL) agencies_->::arangodb::TasksPlan::Clear();
    }
    if (has_coordinators()) {
      if (coordinators_ != NULL) coordinators_->::arangodb::TasksPlan::Clear();
    }
    if (has_dbservers()) {
      if (dbservers_ != NULL) dbservers_->::arangodb::TasksPlan::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Plan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .arangodb.TasksPlan agencies = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agencies()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_coordinators;
        break;
      }

      // required .arangodb.TasksPlan coordinators = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coordinators:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coordinators()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_dbservers;
        break;
      }

      // required .arangodb.TasksPlan dbservers = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dbservers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dbservers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Plan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .arangodb.TasksPlan agencies = 1;
  if (has_agencies()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->agencies(), output);
  }

  // required .arangodb.TasksPlan coordinators = 2;
  if (has_coordinators()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->coordinators(), output);
  }

  // required .arangodb.TasksPlan dbservers = 3;
  if (has_dbservers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->dbservers(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Plan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .arangodb.TasksPlan agencies = 1;
  if (has_agencies()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->agencies(), target);
  }

  // required .arangodb.TasksPlan coordinators = 2;
  if (has_coordinators()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->coordinators(), target);
  }

  // required .arangodb.TasksPlan dbservers = 3;
  if (has_dbservers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->dbservers(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Plan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .arangodb.TasksPlan agencies = 1;
    if (has_agencies()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agencies());
    }

    // required .arangodb.TasksPlan coordinators = 2;
    if (has_coordinators()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coordinators());
    }

    // required .arangodb.TasksPlan dbservers = 3;
    if (has_dbservers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dbservers());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Plan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Plan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Plan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Plan::MergeFrom(const Plan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agencies()) {
      mutable_agencies()->::arangodb::TasksPlan::MergeFrom(from.agencies());
    }
    if (from.has_coordinators()) {
      mutable_coordinators()->::arangodb::TasksPlan::MergeFrom(from.coordinators());
    }
    if (from.has_dbservers()) {
      mutable_dbservers()->::arangodb::TasksPlan::MergeFrom(from.dbservers());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Plan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Plan::CopyFrom(const Plan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Plan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_agencies()) {
    if (!this->agencies().IsInitialized()) return false;
  }
  if (has_coordinators()) {
    if (!this->coordinators().IsInitialized()) return false;
  }
  if (has_dbservers()) {
    if (!this->dbservers().IsInitialized()) return false;
  }
  return true;
}

void Plan::Swap(Plan* other) {
  if (other != this) {
    std::swap(agencies_, other->agencies_);
    std::swap(coordinators_, other->coordinators_);
    std::swap(dbservers_, other->dbservers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Plan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Plan_descriptor_;
  metadata.reflection = Plan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResourcesCurrentEntry::kStateFieldNumber;
const int ResourcesCurrentEntry::kSlaveIdFieldNumber;
const int ResourcesCurrentEntry::kOfferIdFieldNumber;
const int ResourcesCurrentEntry::kResourcesFieldNumber;
const int ResourcesCurrentEntry::kPortsFieldNumber;
const int ResourcesCurrentEntry::kHostnameFieldNumber;
const int ResourcesCurrentEntry::kContainerPathFieldNumber;
#endif  // !_MSC_VER

ResourcesCurrentEntry::ResourcesCurrentEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResourcesCurrentEntry::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  offer_id_ = const_cast< ::mesos::OfferID*>(&::mesos::OfferID::default_instance());
}

ResourcesCurrentEntry::ResourcesCurrentEntry(const ResourcesCurrentEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResourcesCurrentEntry::SharedCtor() {
  _cached_size_ = 0;
  state_ = 1;
  slave_id_ = NULL;
  offer_id_ = NULL;
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourcesCurrentEntry::~ResourcesCurrentEntry() {
  SharedDtor();
}

void ResourcesCurrentEntry::SharedDtor() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (container_path_ != &::google::protobuf::internal::kEmptyString) {
    delete container_path_;
  }
  if (this != default_instance_) {
    delete slave_id_;
    delete offer_id_;
  }
}

void ResourcesCurrentEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourcesCurrentEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourcesCurrentEntry_descriptor_;
}

const ResourcesCurrentEntry& ResourcesCurrentEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

ResourcesCurrentEntry* ResourcesCurrentEntry::default_instance_ = NULL;

ResourcesCurrentEntry* ResourcesCurrentEntry::New() const {
  return new ResourcesCurrentEntry;
}

void ResourcesCurrentEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    state_ = 1;
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_offer_id()) {
      if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
    }
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::kEmptyString) {
        hostname_->clear();
      }
    }
    if (has_container_path()) {
      if (container_path_ != &::google::protobuf::internal::kEmptyString) {
        container_path_->clear();
      }
    }
  }
  resources_.Clear();
  ports_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourcesCurrentEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .arangodb.ResourcesCurrentState state = 1 [default = RESOURCE_STATE_UNKNOWN];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::arangodb::ResourcesCurrentState_IsValid(value)) {
            set_state(static_cast< ::arangodb::ResourcesCurrentState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_slave_id;
        break;
      }

      // optional .mesos.SlaveID slave_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_offer_id;
        break;
      }

      // optional .mesos.OfferID offer_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offer_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_offer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_resources;
        if (input->ExpectTag(40)) goto parse_ports;
        break;
      }

      // repeated uint32 ports = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ports:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_ports())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_ports())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_ports;
        if (input->ExpectTag(50)) goto parse_hostname;
        break;
      }

      // optional string hostname = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_container_path;
        break;
      }

      // optional string container_path = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_container_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_container_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->container_path().data(), this->container_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResourcesCurrentEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .arangodb.ResourcesCurrentState state = 1 [default = RESOURCE_STATE_UNKNOWN];
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  // optional .mesos.SlaveID slave_id = 2;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->slave_id(), output);
  }

  // optional .mesos.OfferID offer_id = 3;
  if (has_offer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->offer_id(), output);
  }

  // repeated .mesos.Resource resources = 4;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->resources(i), output);
  }

  // repeated uint32 ports = 5;
  for (int i = 0; i < this->ports_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->ports(i), output);
  }

  // optional string hostname = 6;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->hostname(), output);
  }

  // optional string container_path = 7;
  if (has_container_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->container_path().data(), this->container_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->container_path(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResourcesCurrentEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .arangodb.ResourcesCurrentState state = 1 [default = RESOURCE_STATE_UNKNOWN];
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  // optional .mesos.SlaveID slave_id = 2;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->slave_id(), target);
  }

  // optional .mesos.OfferID offer_id = 3;
  if (has_offer_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->offer_id(), target);
  }

  // repeated .mesos.Resource resources = 4;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->resources(i), target);
  }

  // repeated uint32 ports = 5;
  for (int i = 0; i < this->ports_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(5, this->ports(i), target);
  }

  // optional string hostname = 6;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->hostname(), target);
  }

  // optional string container_path = 7;
  if (has_container_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->container_path().data(), this->container_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->container_path(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResourcesCurrentEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .arangodb.ResourcesCurrentState state = 1 [default = RESOURCE_STATE_UNKNOWN];
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional .mesos.SlaveID slave_id = 2;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // optional .mesos.OfferID offer_id = 3;
    if (has_offer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->offer_id());
    }

    // optional string hostname = 6;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional string container_path = 7;
    if (has_container_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->container_path());
    }

  }
  // repeated .mesos.Resource resources = 4;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  // repeated uint32 ports = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->ports_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->ports(i));
    }
    total_size += 1 * this->ports_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourcesCurrentEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourcesCurrentEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourcesCurrentEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourcesCurrentEntry::MergeFrom(const ResourcesCurrentEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  ports_.MergeFrom(from.ports_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_offer_id()) {
      mutable_offer_id()->::mesos::OfferID::MergeFrom(from.offer_id());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_container_path()) {
      set_container_path(from.container_path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourcesCurrentEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourcesCurrentEntry::CopyFrom(const ResourcesCurrentEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourcesCurrentEntry::IsInitialized() const {

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_offer_id()) {
    if (!this->offer_id().IsInitialized()) return false;
  }
  for (int i = 0; i < resources_size(); i++) {
    if (!this->resources(i).IsInitialized()) return false;
  }
  return true;
}

void ResourcesCurrentEntry::Swap(ResourcesCurrentEntry* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(slave_id_, other->slave_id_);
    std::swap(offer_id_, other->offer_id_);
    resources_.Swap(&other->resources_);
    ports_.Swap(&other->ports_);
    std::swap(hostname_, other->hostname_);
    std::swap(container_path_, other->container_path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourcesCurrentEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourcesCurrentEntry_descriptor_;
  metadata.reflection = ResourcesCurrentEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResourcesCurrent::kEntriesFieldNumber;
#endif  // !_MSC_VER

ResourcesCurrent::ResourcesCurrent()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResourcesCurrent::InitAsDefaultInstance() {
}

ResourcesCurrent::ResourcesCurrent(const ResourcesCurrent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResourcesCurrent::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourcesCurrent::~ResourcesCurrent() {
  SharedDtor();
}

void ResourcesCurrent::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResourcesCurrent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourcesCurrent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourcesCurrent_descriptor_;
}

const ResourcesCurrent& ResourcesCurrent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

ResourcesCurrent* ResourcesCurrent::default_instance_ = NULL;

ResourcesCurrent* ResourcesCurrent::New() const {
  return new ResourcesCurrent;
}

void ResourcesCurrent::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourcesCurrent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .arangodb.ResourcesCurrentEntry entries = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResourcesCurrent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .arangodb.ResourcesCurrentEntry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResourcesCurrent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .arangodb.ResourcesCurrentEntry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResourcesCurrent::ByteSize() const {
  int total_size = 0;

  // repeated .arangodb.ResourcesCurrentEntry entries = 1;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourcesCurrent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourcesCurrent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourcesCurrent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourcesCurrent::MergeFrom(const ResourcesCurrent& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourcesCurrent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourcesCurrent::CopyFrom(const ResourcesCurrent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourcesCurrent::IsInitialized() const {

  for (int i = 0; i < entries_size(); i++) {
    if (!this->entries(i).IsInitialized()) return false;
  }
  return true;
}

void ResourcesCurrent::Swap(ResourcesCurrent* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourcesCurrent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourcesCurrent_descriptor_;
  metadata.reflection = ResourcesCurrent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InstancesCurrentEntry::kStateFieldNumber;
const int InstancesCurrentEntry::kTaskInfoFieldNumber;
const int InstancesCurrentEntry::kTaskStatusFieldNumber;
const int InstancesCurrentEntry::kPortsFieldNumber;
const int InstancesCurrentEntry::kHostnameFieldNumber;
#endif  // !_MSC_VER

InstancesCurrentEntry::InstancesCurrentEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InstancesCurrentEntry::InitAsDefaultInstance() {
  task_info_ = const_cast< ::mesos::TaskInfo*>(&::mesos::TaskInfo::default_instance());
  task_status_ = const_cast< ::mesos::TaskStatus*>(&::mesos::TaskStatus::default_instance());
}

InstancesCurrentEntry::InstancesCurrentEntry(const InstancesCurrentEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InstancesCurrentEntry::SharedCtor() {
  _cached_size_ = 0;
  state_ = 1;
  task_info_ = NULL;
  task_status_ = NULL;
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InstancesCurrentEntry::~InstancesCurrentEntry() {
  SharedDtor();
}

void InstancesCurrentEntry::SharedDtor() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (this != default_instance_) {
    delete task_info_;
    delete task_status_;
  }
}

void InstancesCurrentEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InstancesCurrentEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InstancesCurrentEntry_descriptor_;
}

const InstancesCurrentEntry& InstancesCurrentEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

InstancesCurrentEntry* InstancesCurrentEntry::default_instance_ = NULL;

InstancesCurrentEntry* InstancesCurrentEntry::New() const {
  return new InstancesCurrentEntry;
}

void InstancesCurrentEntry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    state_ = 1;
    if (has_task_info()) {
      if (task_info_ != NULL) task_info_->::mesos::TaskInfo::Clear();
    }
    if (has_task_status()) {
      if (task_status_ != NULL) task_status_->::mesos::TaskStatus::Clear();
    }
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::kEmptyString) {
        hostname_->clear();
      }
    }
  }
  ports_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InstancesCurrentEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .arangodb.InstancesCurrentState state = 1 [default = INSTANCE_STATE_UNUSED];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::arangodb::InstancesCurrentState_IsValid(value)) {
            set_state(static_cast< ::arangodb::InstancesCurrentState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_task_info;
        break;
      }

      // optional .mesos.TaskInfo task_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_task_status;
        break;
      }

      // optional .mesos.TaskStatus task_status = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ports;
        break;
      }

      // repeated uint32 ports = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ports:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_ports())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_ports())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ports;
        if (input->ExpectTag(42)) goto parse_hostname;
        break;
      }

      // optional string hostname = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InstancesCurrentEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .arangodb.InstancesCurrentState state = 1 [default = INSTANCE_STATE_UNUSED];
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  // optional .mesos.TaskInfo task_info = 2;
  if (has_task_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->task_info(), output);
  }

  // optional .mesos.TaskStatus task_status = 3;
  if (has_task_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->task_status(), output);
  }

  // repeated uint32 ports = 4;
  for (int i = 0; i < this->ports_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->ports(i), output);
  }

  // optional string hostname = 5;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->hostname(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InstancesCurrentEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .arangodb.InstancesCurrentState state = 1 [default = INSTANCE_STATE_UNUSED];
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  // optional .mesos.TaskInfo task_info = 2;
  if (has_task_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->task_info(), target);
  }

  // optional .mesos.TaskStatus task_status = 3;
  if (has_task_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->task_status(), target);
  }

  // repeated uint32 ports = 4;
  for (int i = 0; i < this->ports_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(4, this->ports(i), target);
  }

  // optional string hostname = 5;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->hostname(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InstancesCurrentEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .arangodb.InstancesCurrentState state = 1 [default = INSTANCE_STATE_UNUSED];
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional .mesos.TaskInfo task_info = 2;
    if (has_task_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_info());
    }

    // optional .mesos.TaskStatus task_status = 3;
    if (has_task_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_status());
    }

    // optional string hostname = 5;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

  }
  // repeated uint32 ports = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->ports_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->ports(i));
    }
    total_size += 1 * this->ports_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InstancesCurrentEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InstancesCurrentEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InstancesCurrentEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InstancesCurrentEntry::MergeFrom(const InstancesCurrentEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  ports_.MergeFrom(from.ports_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_task_info()) {
      mutable_task_info()->::mesos::TaskInfo::MergeFrom(from.task_info());
    }
    if (from.has_task_status()) {
      mutable_task_status()->::mesos::TaskStatus::MergeFrom(from.task_status());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InstancesCurrentEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InstancesCurrentEntry::CopyFrom(const InstancesCurrentEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstancesCurrentEntry::IsInitialized() const {

  if (has_task_info()) {
    if (!this->task_info().IsInitialized()) return false;
  }
  if (has_task_status()) {
    if (!this->task_status().IsInitialized()) return false;
  }
  return true;
}

void InstancesCurrentEntry::Swap(InstancesCurrentEntry* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(task_info_, other->task_info_);
    std::swap(task_status_, other->task_status_);
    ports_.Swap(&other->ports_);
    std::swap(hostname_, other->hostname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InstancesCurrentEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InstancesCurrentEntry_descriptor_;
  metadata.reflection = InstancesCurrentEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InstancesCurrent::kEntriesFieldNumber;
#endif  // !_MSC_VER

InstancesCurrent::InstancesCurrent()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InstancesCurrent::InitAsDefaultInstance() {
}

InstancesCurrent::InstancesCurrent(const InstancesCurrent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InstancesCurrent::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InstancesCurrent::~InstancesCurrent() {
  SharedDtor();
}

void InstancesCurrent::SharedDtor() {
  if (this != default_instance_) {
  }
}

void InstancesCurrent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InstancesCurrent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InstancesCurrent_descriptor_;
}

const InstancesCurrent& InstancesCurrent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

InstancesCurrent* InstancesCurrent::default_instance_ = NULL;

InstancesCurrent* InstancesCurrent::New() const {
  return new InstancesCurrent;
}

void InstancesCurrent::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InstancesCurrent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .arangodb.InstancesCurrentEntry entries = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InstancesCurrent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .arangodb.InstancesCurrentEntry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InstancesCurrent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .arangodb.InstancesCurrentEntry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InstancesCurrent::ByteSize() const {
  int total_size = 0;

  // repeated .arangodb.InstancesCurrentEntry entries = 1;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InstancesCurrent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InstancesCurrent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InstancesCurrent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InstancesCurrent::MergeFrom(const InstancesCurrent& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InstancesCurrent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InstancesCurrent::CopyFrom(const InstancesCurrent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstancesCurrent::IsInitialized() const {

  for (int i = 0; i < entries_size(); i++) {
    if (!this->entries(i).IsInitialized()) return false;
  }
  return true;
}

void InstancesCurrent::Swap(InstancesCurrent* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InstancesCurrent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InstancesCurrent_descriptor_;
  metadata.reflection = InstancesCurrent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Current::kAgencyResourcesFieldNumber;
const int Current::kCoordinatorResourcesFieldNumber;
const int Current::kPrimaryDbserverResourcesFieldNumber;
const int Current::kSecondaryDbserverResourcesFieldNumber;
const int Current::kAgenciesFieldNumber;
const int Current::kCoordinatorsFieldNumber;
const int Current::kPrimaryDbserversFieldNumber;
const int Current::kSecondaryDbserversFieldNumber;
#endif  // !_MSC_VER

Current::Current()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Current::InitAsDefaultInstance() {
  agency_resources_ = const_cast< ::arangodb::ResourcesCurrent*>(&::arangodb::ResourcesCurrent::default_instance());
  coordinator_resources_ = const_cast< ::arangodb::ResourcesCurrent*>(&::arangodb::ResourcesCurrent::default_instance());
  primary_dbserver_resources_ = const_cast< ::arangodb::ResourcesCurrent*>(&::arangodb::ResourcesCurrent::default_instance());
  secondary_dbserver_resources_ = const_cast< ::arangodb::ResourcesCurrent*>(&::arangodb::ResourcesCurrent::default_instance());
  agencies_ = const_cast< ::arangodb::InstancesCurrent*>(&::arangodb::InstancesCurrent::default_instance());
  coordinators_ = const_cast< ::arangodb::InstancesCurrent*>(&::arangodb::InstancesCurrent::default_instance());
  primary_dbservers_ = const_cast< ::arangodb::InstancesCurrent*>(&::arangodb::InstancesCurrent::default_instance());
  secondary_dbservers_ = const_cast< ::arangodb::InstancesCurrent*>(&::arangodb::InstancesCurrent::default_instance());
}

Current::Current(const Current& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Current::SharedCtor() {
  _cached_size_ = 0;
  agency_resources_ = NULL;
  coordinator_resources_ = NULL;
  primary_dbserver_resources_ = NULL;
  secondary_dbserver_resources_ = NULL;
  agencies_ = NULL;
  coordinators_ = NULL;
  primary_dbservers_ = NULL;
  secondary_dbservers_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Current::~Current() {
  SharedDtor();
}

void Current::SharedDtor() {
  if (this != default_instance_) {
    delete agency_resources_;
    delete coordinator_resources_;
    delete primary_dbserver_resources_;
    delete secondary_dbserver_resources_;
    delete agencies_;
    delete coordinators_;
    delete primary_dbservers_;
    delete secondary_dbservers_;
  }
}

void Current::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Current::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Current_descriptor_;
}

const Current& Current::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

Current* Current::default_instance_ = NULL;

Current* Current::New() const {
  return new Current;
}

void Current::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_agency_resources()) {
      if (agency_resources_ != NULL) agency_resources_->::arangodb::ResourcesCurrent::Clear();
    }
    if (has_coordinator_resources()) {
      if (coordinator_resources_ != NULL) coordinator_resources_->::arangodb::ResourcesCurrent::Clear();
    }
    if (has_primary_dbserver_resources()) {
      if (primary_dbserver_resources_ != NULL) primary_dbserver_resources_->::arangodb::ResourcesCurrent::Clear();
    }
    if (has_secondary_dbserver_resources()) {
      if (secondary_dbserver_resources_ != NULL) secondary_dbserver_resources_->::arangodb::ResourcesCurrent::Clear();
    }
    if (has_agencies()) {
      if (agencies_ != NULL) agencies_->::arangodb::InstancesCurrent::Clear();
    }
    if (has_coordinators()) {
      if (coordinators_ != NULL) coordinators_->::arangodb::InstancesCurrent::Clear();
    }
    if (has_primary_dbservers()) {
      if (primary_dbservers_ != NULL) primary_dbservers_->::arangodb::InstancesCurrent::Clear();
    }
    if (has_secondary_dbservers()) {
      if (secondary_dbservers_ != NULL) secondary_dbservers_->::arangodb::InstancesCurrent::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Current::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .arangodb.ResourcesCurrent agency_resources = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agency_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_coordinator_resources;
        break;
      }

      // required .arangodb.ResourcesCurrent coordinator_resources = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coordinator_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coordinator_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_primary_dbserver_resources;
        break;
      }

      // required .arangodb.ResourcesCurrent primary_dbserver_resources = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_primary_dbserver_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_primary_dbserver_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_secondary_dbserver_resources;
        break;
      }

      // required .arangodb.ResourcesCurrent secondary_dbserver_resources = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_secondary_dbserver_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_secondary_dbserver_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_agencies;
        break;
      }

      // required .arangodb.InstancesCurrent agencies = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agencies:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agencies()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_coordinators;
        break;
      }

      // required .arangodb.InstancesCurrent coordinators = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coordinators:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coordinators()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_primary_dbservers;
        break;
      }

      // required .arangodb.InstancesCurrent primary_dbservers = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_primary_dbservers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_primary_dbservers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_secondary_dbservers;
        break;
      }

      // required .arangodb.InstancesCurrent secondary_dbservers = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_secondary_dbservers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_secondary_dbservers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Current::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .arangodb.ResourcesCurrent agency_resources = 1;
  if (has_agency_resources()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->agency_resources(), output);
  }

  // required .arangodb.ResourcesCurrent coordinator_resources = 2;
  if (has_coordinator_resources()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->coordinator_resources(), output);
  }

  // required .arangodb.ResourcesCurrent primary_dbserver_resources = 3;
  if (has_primary_dbserver_resources()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->primary_dbserver_resources(), output);
  }

  // required .arangodb.ResourcesCurrent secondary_dbserver_resources = 4;
  if (has_secondary_dbserver_resources()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->secondary_dbserver_resources(), output);
  }

  // required .arangodb.InstancesCurrent agencies = 5;
  if (has_agencies()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->agencies(), output);
  }

  // required .arangodb.InstancesCurrent coordinators = 6;
  if (has_coordinators()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->coordinators(), output);
  }

  // required .arangodb.InstancesCurrent primary_dbservers = 7;
  if (has_primary_dbservers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->primary_dbservers(), output);
  }

  // required .arangodb.InstancesCurrent secondary_dbservers = 8;
  if (has_secondary_dbservers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->secondary_dbservers(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Current::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .arangodb.ResourcesCurrent agency_resources = 1;
  if (has_agency_resources()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->agency_resources(), target);
  }

  // required .arangodb.ResourcesCurrent coordinator_resources = 2;
  if (has_coordinator_resources()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->coordinator_resources(), target);
  }

  // required .arangodb.ResourcesCurrent primary_dbserver_resources = 3;
  if (has_primary_dbserver_resources()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->primary_dbserver_resources(), target);
  }

  // required .arangodb.ResourcesCurrent secondary_dbserver_resources = 4;
  if (has_secondary_dbserver_resources()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->secondary_dbserver_resources(), target);
  }

  // required .arangodb.InstancesCurrent agencies = 5;
  if (has_agencies()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->agencies(), target);
  }

  // required .arangodb.InstancesCurrent coordinators = 6;
  if (has_coordinators()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->coordinators(), target);
  }

  // required .arangodb.InstancesCurrent primary_dbservers = 7;
  if (has_primary_dbservers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->primary_dbservers(), target);
  }

  // required .arangodb.InstancesCurrent secondary_dbservers = 8;
  if (has_secondary_dbservers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->secondary_dbservers(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Current::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .arangodb.ResourcesCurrent agency_resources = 1;
    if (has_agency_resources()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agency_resources());
    }

    // required .arangodb.ResourcesCurrent coordinator_resources = 2;
    if (has_coordinator_resources()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coordinator_resources());
    }

    // required .arangodb.ResourcesCurrent primary_dbserver_resources = 3;
    if (has_primary_dbserver_resources()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->primary_dbserver_resources());
    }

    // required .arangodb.ResourcesCurrent secondary_dbserver_resources = 4;
    if (has_secondary_dbserver_resources()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->secondary_dbserver_resources());
    }

    // required .arangodb.InstancesCurrent agencies = 5;
    if (has_agencies()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agencies());
    }

    // required .arangodb.InstancesCurrent coordinators = 6;
    if (has_coordinators()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coordinators());
    }

    // required .arangodb.InstancesCurrent primary_dbservers = 7;
    if (has_primary_dbservers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->primary_dbservers());
    }

    // required .arangodb.InstancesCurrent secondary_dbservers = 8;
    if (has_secondary_dbservers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->secondary_dbservers());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Current::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Current* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Current*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Current::MergeFrom(const Current& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agency_resources()) {
      mutable_agency_resources()->::arangodb::ResourcesCurrent::MergeFrom(from.agency_resources());
    }
    if (from.has_coordinator_resources()) {
      mutable_coordinator_resources()->::arangodb::ResourcesCurrent::MergeFrom(from.coordinator_resources());
    }
    if (from.has_primary_dbserver_resources()) {
      mutable_primary_dbserver_resources()->::arangodb::ResourcesCurrent::MergeFrom(from.primary_dbserver_resources());
    }
    if (from.has_secondary_dbserver_resources()) {
      mutable_secondary_dbserver_resources()->::arangodb::ResourcesCurrent::MergeFrom(from.secondary_dbserver_resources());
    }
    if (from.has_agencies()) {
      mutable_agencies()->::arangodb::InstancesCurrent::MergeFrom(from.agencies());
    }
    if (from.has_coordinators()) {
      mutable_coordinators()->::arangodb::InstancesCurrent::MergeFrom(from.coordinators());
    }
    if (from.has_primary_dbservers()) {
      mutable_primary_dbservers()->::arangodb::InstancesCurrent::MergeFrom(from.primary_dbservers());
    }
    if (from.has_secondary_dbservers()) {
      mutable_secondary_dbservers()->::arangodb::InstancesCurrent::MergeFrom(from.secondary_dbservers());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Current::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Current::CopyFrom(const Current& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Current::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_agency_resources()) {
    if (!this->agency_resources().IsInitialized()) return false;
  }
  if (has_coordinator_resources()) {
    if (!this->coordinator_resources().IsInitialized()) return false;
  }
  if (has_primary_dbserver_resources()) {
    if (!this->primary_dbserver_resources().IsInitialized()) return false;
  }
  if (has_secondary_dbserver_resources()) {
    if (!this->secondary_dbserver_resources().IsInitialized()) return false;
  }
  if (has_agencies()) {
    if (!this->agencies().IsInitialized()) return false;
  }
  if (has_coordinators()) {
    if (!this->coordinators().IsInitialized()) return false;
  }
  if (has_primary_dbservers()) {
    if (!this->primary_dbservers().IsInitialized()) return false;
  }
  if (has_secondary_dbservers()) {
    if (!this->secondary_dbservers().IsInitialized()) return false;
  }
  return true;
}

void Current::Swap(Current* other) {
  if (other != this) {
    std::swap(agency_resources_, other->agency_resources_);
    std::swap(coordinator_resources_, other->coordinator_resources_);
    std::swap(primary_dbserver_resources_, other->primary_dbserver_resources_);
    std::swap(secondary_dbserver_resources_, other->secondary_dbserver_resources_);
    std::swap(agencies_, other->agencies_);
    std::swap(coordinators_, other->coordinators_);
    std::swap(primary_dbservers_, other->primary_dbservers_);
    std::swap(secondary_dbservers_, other->secondary_dbservers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Current::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Current_descriptor_;
  metadata.reflection = Current_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int State::kFrameworkIdFieldNumber;
const int State::kTargetFieldNumber;
const int State::kPlanFieldNumber;
const int State::kCurrentFieldNumber;
#endif  // !_MSC_VER

State::State()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void State::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  target_ = const_cast< ::arangodb::Target*>(&::arangodb::Target::default_instance());
  plan_ = const_cast< ::arangodb::Plan*>(&::arangodb::Plan::default_instance());
  current_ = const_cast< ::arangodb::Current*>(&::arangodb::Current::default_instance());
}

State::State(const State& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void State::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  target_ = NULL;
  plan_ = NULL;
  current_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

State::~State() {
  SharedDtor();
}

void State::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete target_;
    delete plan_;
    delete current_;
  }
}

void State::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* State::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return State_descriptor_;
}

const State& State::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

State* State::default_instance_ = NULL;

State* State::New() const {
  return new State;
}

void State::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_target()) {
      if (target_ != NULL) target_->::arangodb::Target::Clear();
    }
    if (has_plan()) {
      if (plan_ != NULL) plan_->::arangodb::Plan::Clear();
    }
    if (has_current()) {
      if (current_ != NULL) current_->::arangodb::Current::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool State::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_target;
        break;
      }

      // required .arangodb.Target target = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_target()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_plan;
        break;
      }

      // required .arangodb.Plan plan = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_plan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_plan()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_current;
        break;
      }

      // required .arangodb.Current current = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_current:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_current()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void State::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .arangodb.Target target = 2;
  if (has_target()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->target(), output);
  }

  // required .arangodb.Plan plan = 3;
  if (has_plan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->plan(), output);
  }

  // required .arangodb.Current current = 4;
  if (has_current()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->current(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* State::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .arangodb.Target target = 2;
  if (has_target()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->target(), target);
  }

  // required .arangodb.Plan plan = 3;
  if (has_plan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->plan(), target);
  }

  // required .arangodb.Current current = 4;
  if (has_current()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->current(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int State::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .arangodb.Target target = 2;
    if (has_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->target());
    }

    // required .arangodb.Plan plan = 3;
    if (has_plan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->plan());
    }

    // required .arangodb.Current current = 4;
    if (has_current()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->current());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void State::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const State* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const State*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void State::MergeFrom(const State& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_target()) {
      mutable_target()->::arangodb::Target::MergeFrom(from.target());
    }
    if (from.has_plan()) {
      mutable_plan()->::arangodb::Plan::MergeFrom(from.plan());
    }
    if (from.has_current()) {
      mutable_current()->::arangodb::Current::MergeFrom(from.current());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void State::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void State::CopyFrom(const State& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool State::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_target()) {
    if (!this->target().IsInitialized()) return false;
  }
  if (has_plan()) {
    if (!this->plan().IsInitialized()) return false;
  }
  if (has_current()) {
    if (!this->current().IsInitialized()) return false;
  }
  return true;
}

void State::Swap(State* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(target_, other->target_);
    std::swap(plan_, other->plan_);
    std::swap(current_, other->current_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata State::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = State_descriptor_;
  metadata.reflection = State_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace arangodb

// @@protoc_insertion_point(global_scope)
