// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: arangodb.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "arangodb.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace arangodb {

namespace {

const ::google::protobuf::Descriptor* Target_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Target_reflection_ = NULL;
const ::google::protobuf::Descriptor* Targets_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Targets_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskPlan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskPlan_reflection_ = NULL;
const ::google::protobuf::Descriptor* TasksPlan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TasksPlan_reflection_ = NULL;
const ::google::protobuf::Descriptor* Plan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Plan_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskCurrent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskCurrent_reflection_ = NULL;
const ::google::protobuf::Descriptor* TasksCurrent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TasksCurrent_reflection_ = NULL;
const ::google::protobuf::Descriptor* Current_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Current_reflection_ = NULL;
const ::google::protobuf::Descriptor* State_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  State_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TaskPlanState_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TaskCurrentState_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_arangodb_2eproto() {
  protobuf_AddDesc_arangodb_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "arangodb.proto");
  GOOGLE_CHECK(file != NULL);
  Target_descriptor_ = file->message_type(0);
  static const int Target_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, instances_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, minimal_resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, additional_resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, number_ports_),
  };
  Target_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Target_descriptor_,
      Target::default_instance_,
      Target_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Target, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Target));
  Targets_descriptor_ = file->message_type(1);
  static const int Targets_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Targets, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Targets, agents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Targets, coordinators_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Targets, dbservers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Targets, secondaries_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Targets, asynchronous_replication_),
  };
  Targets_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Targets_descriptor_,
      Targets::default_instance_,
      Targets_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Targets, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Targets, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Targets));
  TaskPlan_descriptor_ = file->message_type(2);
  static const int TaskPlan_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskPlan, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskPlan, is_primary_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskPlan, persistence_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskPlan, started_),
  };
  TaskPlan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TaskPlan_descriptor_,
      TaskPlan::default_instance_,
      TaskPlan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskPlan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskPlan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TaskPlan));
  TasksPlan_descriptor_ = file->message_type(3);
  static const int TasksPlan_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksPlan, entries_),
  };
  TasksPlan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TasksPlan_descriptor_,
      TasksPlan::default_instance_,
      TasksPlan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksPlan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksPlan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TasksPlan));
  Plan_descriptor_ = file->message_type(4);
  static const int Plan_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Plan, agents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Plan, coordinators_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Plan, dbservers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Plan, secondaries_),
  };
  Plan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Plan_descriptor_,
      Plan::default_instance_,
      Plan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Plan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Plan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Plan));
  TaskCurrent_descriptor_ = file->message_type(5);
  static const int TaskCurrent_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskCurrent, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskCurrent, offer_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskCurrent, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskCurrent, ports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskCurrent, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskCurrent, container_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskCurrent, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskCurrent, task_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskCurrent, task_status_),
  };
  TaskCurrent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TaskCurrent_descriptor_,
      TaskCurrent::default_instance_,
      TaskCurrent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskCurrent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskCurrent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TaskCurrent));
  TasksCurrent_descriptor_ = file->message_type(6);
  static const int TasksCurrent_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksCurrent, entries_),
  };
  TasksCurrent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TasksCurrent_descriptor_,
      TasksCurrent::default_instance_,
      TasksCurrent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksCurrent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksCurrent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TasksCurrent));
  Current_descriptor_ = file->message_type(7);
  static const int Current_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, agents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, coordinators_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, dbservers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, secondaries_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, cluster_complete_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, cluster_bootstrappeddbservers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, cluster_upgradeddb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, cluster_bootstrappedcoordinators_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, cluster_initialized_),
  };
  Current_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Current_descriptor_,
      Current::default_instance_,
      Current_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Current, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Current));
  State_descriptor_ = file->message_type(8);
  static const int State_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, targets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, plan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, current_),
  };
  State_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      State_descriptor_,
      State::default_instance_,
      State_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(State));
  TaskPlanState_descriptor_ = file->enum_type(0);
  TaskCurrentState_descriptor_ = file->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_arangodb_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Target_descriptor_, &Target::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Targets_descriptor_, &Targets::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TaskPlan_descriptor_, &TaskPlan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TasksPlan_descriptor_, &TasksPlan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Plan_descriptor_, &Plan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TaskCurrent_descriptor_, &TaskCurrent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TasksCurrent_descriptor_, &TasksCurrent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Current_descriptor_, &Current::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    State_descriptor_, &State::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_arangodb_2eproto() {
  delete Target::default_instance_;
  delete Target_reflection_;
  delete Targets::default_instance_;
  delete Targets_reflection_;
  delete TaskPlan::default_instance_;
  delete TaskPlan_reflection_;
  delete TasksPlan::default_instance_;
  delete TasksPlan_reflection_;
  delete Plan::default_instance_;
  delete Plan_reflection_;
  delete TaskCurrent::default_instance_;
  delete TaskCurrent_reflection_;
  delete TasksCurrent::default_instance_;
  delete TasksCurrent_reflection_;
  delete Current::default_instance_;
  delete Current_reflection_;
  delete State::default_instance_;
  delete State_reflection_;
}

void protobuf_AddDesc_arangodb_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::mesos::protobuf_AddDesc_mesos_2fmesos_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016arangodb.proto\022\010arangodb\032\021mesos/mesos."
    "proto\"\214\001\n\006Target\022\021\n\tinstances\030\001 \002(\r\022*\n\021m"
    "inimal_resources\030\002 \003(\0132\017.mesos.Resource\022"
    "-\n\024additional_resources\030\003 \003(\0132\017.mesos.Re"
    "source\022\024\n\014number_ports\030\004 \002(\r\"\317\001\n\007Targets"
    "\022\014\n\004mode\030\001 \002(\t\022 \n\006agents\030\002 \002(\0132\020.arangod"
    "b.Target\022&\n\014coordinators\030\003 \002(\0132\020.arangod"
    "b.Target\022#\n\tdbservers\030\004 \002(\0132\020.arangodb.T"
    "arget\022%\n\013secondaries\030\005 \002(\0132\020.arangodb.Ta"
    "rget\022 \n\030asynchronous_replication\030\006 \001(\010\"\177"
    "\n\010TaskPlan\0226\n\005state\030\001 \002(\0162\027.arangodb.Tas"
    "kPlanState:\016TASK_STATE_NEW\022\022\n\nis_primary"
    "\030\002 \002(\010\022\026\n\016persistence_id\030\003 \001(\t\022\017\n\007starte"
    "d\030\004 \001(\001\"0\n\tTasksPlan\022#\n\007entries\030\001 \003(\0132\022."
    "arangodb.TaskPlan\"\250\001\n\004Plan\022#\n\006agents\030\001 \002"
    "(\0132\023.arangodb.TasksPlan\022)\n\014coordinators\030"
    "\002 \002(\0132\023.arangodb.TasksPlan\022&\n\tdbservers\030"
    "\003 \002(\0132\023.arangodb.TasksPlan\022(\n\013secondarie"
    "s\030\004 \002(\0132\023.arangodb.TasksPlan\"\274\002\n\013TaskCur"
    "rent\022 \n\010slave_id\030\001 \001(\0132\016.mesos.SlaveID\022 "
    "\n\010offer_id\030\002 \001(\0132\016.mesos.OfferID\022\"\n\treso"
    "urces\030\003 \003(\0132\017.mesos.Resource\022\r\n\005ports\030\004 "
    "\003(\r\022\020\n\010hostname\030\005 \001(\t\022\026\n\016container_path\030"
    "\006 \001(\t\022@\n\005state\030\007 \002(\0162\032.arangodb.TaskCurr"
    "entState:\025INSTANCE_STATE_UNUSED\022\"\n\ttask_"
    "info\030\010 \001(\0132\017.mesos.TaskInfo\022&\n\013task_stat"
    "us\030\t \001(\0132\021.mesos.TaskStatus\"6\n\014TasksCurr"
    "ent\022&\n\007entries\030\001 \003(\0132\025.arangodb.TaskCurr"
    "ent\"\333\002\n\007Current\022&\n\006agents\030\001 \002(\0132\026.arango"
    "db.TasksCurrent\022,\n\014coordinators\030\002 \002(\0132\026."
    "arangodb.TasksCurrent\022)\n\tdbservers\030\003 \002(\013"
    "2\026.arangodb.TasksCurrent\022+\n\013secondaries\030"
    "\004 \002(\0132\026.arangodb.TasksCurrent\022\030\n\020cluster"
    "_complete\030\005 \002(\010\022%\n\035cluster_bootstrappedD"
    "Bservers\030\006 \002(\010\022\032\n\022cluster_upgradedDB\030\007 \002"
    "(\010\022(\n cluster_bootstrappedCoordinators\030\010"
    " \002(\010\022\033\n\023cluster_initialized\030\t \002(\010\"\227\001\n\005St"
    "ate\022(\n\014framework_id\030\001 \001(\0132\022.mesos.Framew"
    "orkID\022\"\n\007targets\030\002 \002(\0132\021.arangodb.Target"
    "s\022\034\n\004plan\030\003 \002(\0132\016.arangodb.Plan\022\"\n\007curre"
    "nt\030\004 \002(\0132\021.arangodb.Current*\211\002\n\rTaskPlan"
    "State\022\022\n\016TASK_STATE_NEW\020\001\022 \n\034TASK_STATE_"
    "TRYING_TO_RESERVE\020\002\022 \n\034TASK_STATE_TRYING"
    "_TO_PERSIST\020\003\022\036\n\032TASK_STATE_TRYING_TO_ST"
    "ART\020\004\022 \n\034TASK_STATE_TRYING_TO_RESTART\020\005\022"
    "\026\n\022TASK_STATE_RUNNING\020\006\022\025\n\021TASK_STATE_KI"
    "LLED\020\007\022\032\n\026TASK_STATE_FAILED_OVER\020\010\022\023\n\017TA"
    "SK_STATE_DEAD\020\t*\202\001\n\020TaskCurrentState\022\031\n\025"
    "INSTANCE_STATE_UNUSED\020\001\022\033\n\027INSTANCE_STAT"
    "E_STARTING\020\002\022\032\n\026INSTANCE_STATE_RUNNING\020\003"
    "\022\032\n\026INSTANCE_STATE_STOPPED\020\004", 2028);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "arangodb.proto", &protobuf_RegisterTypes);
  Target::default_instance_ = new Target();
  Targets::default_instance_ = new Targets();
  TaskPlan::default_instance_ = new TaskPlan();
  TasksPlan::default_instance_ = new TasksPlan();
  Plan::default_instance_ = new Plan();
  TaskCurrent::default_instance_ = new TaskCurrent();
  TasksCurrent::default_instance_ = new TasksCurrent();
  Current::default_instance_ = new Current();
  State::default_instance_ = new State();
  Target::default_instance_->InitAsDefaultInstance();
  Targets::default_instance_->InitAsDefaultInstance();
  TaskPlan::default_instance_->InitAsDefaultInstance();
  TasksPlan::default_instance_->InitAsDefaultInstance();
  Plan::default_instance_->InitAsDefaultInstance();
  TaskCurrent::default_instance_->InitAsDefaultInstance();
  TasksCurrent::default_instance_->InitAsDefaultInstance();
  Current::default_instance_->InitAsDefaultInstance();
  State::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_arangodb_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_arangodb_2eproto {
  StaticDescriptorInitializer_arangodb_2eproto() {
    protobuf_AddDesc_arangodb_2eproto();
  }
} static_descriptor_initializer_arangodb_2eproto_;
const ::google::protobuf::EnumDescriptor* TaskPlanState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskPlanState_descriptor_;
}
bool TaskPlanState_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TaskCurrentState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskCurrentState_descriptor_;
}
bool TaskCurrentState_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Target::kInstancesFieldNumber;
const int Target::kMinimalResourcesFieldNumber;
const int Target::kAdditionalResourcesFieldNumber;
const int Target::kNumberPortsFieldNumber;
#endif  // !_MSC_VER

Target::Target()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Target::InitAsDefaultInstance() {
}

Target::Target(const Target& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Target::SharedCtor() {
  _cached_size_ = 0;
  instances_ = 0u;
  number_ports_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Target::~Target() {
  SharedDtor();
}

void Target::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Target::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Target::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Target_descriptor_;
}

const Target& Target::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

Target* Target::default_instance_ = NULL;

Target* Target::New() const {
  return new Target;
}

void Target::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    instances_ = 0u;
    number_ports_ = 0u;
  }
  minimal_resources_.Clear();
  additional_resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Target::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 instances = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &instances_)));
          set_has_instances();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_minimal_resources;
        break;
      }

      // repeated .mesos.Resource minimal_resources = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_minimal_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_minimal_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_minimal_resources;
        if (input->ExpectTag(26)) goto parse_additional_resources;
        break;
      }

      // repeated .mesos.Resource additional_resources = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_additional_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_additional_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_additional_resources;
        if (input->ExpectTag(32)) goto parse_number_ports;
        break;
      }

      // required uint32 number_ports = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_number_ports:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &number_ports_)));
          set_has_number_ports();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Target::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 instances = 1;
  if (has_instances()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->instances(), output);
  }

  // repeated .mesos.Resource minimal_resources = 2;
  for (int i = 0; i < this->minimal_resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->minimal_resources(i), output);
  }

  // repeated .mesos.Resource additional_resources = 3;
  for (int i = 0; i < this->additional_resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->additional_resources(i), output);
  }

  // required uint32 number_ports = 4;
  if (has_number_ports()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->number_ports(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Target::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 instances = 1;
  if (has_instances()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->instances(), target);
  }

  // repeated .mesos.Resource minimal_resources = 2;
  for (int i = 0; i < this->minimal_resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->minimal_resources(i), target);
  }

  // repeated .mesos.Resource additional_resources = 3;
  for (int i = 0; i < this->additional_resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->additional_resources(i), target);
  }

  // required uint32 number_ports = 4;
  if (has_number_ports()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->number_ports(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Target::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 instances = 1;
    if (has_instances()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->instances());
    }

    // required uint32 number_ports = 4;
    if (has_number_ports()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->number_ports());
    }

  }
  // repeated .mesos.Resource minimal_resources = 2;
  total_size += 1 * this->minimal_resources_size();
  for (int i = 0; i < this->minimal_resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->minimal_resources(i));
  }

  // repeated .mesos.Resource additional_resources = 3;
  total_size += 1 * this->additional_resources_size();
  for (int i = 0; i < this->additional_resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->additional_resources(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Target::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Target* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Target*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Target::MergeFrom(const Target& from) {
  GOOGLE_CHECK_NE(&from, this);
  minimal_resources_.MergeFrom(from.minimal_resources_);
  additional_resources_.MergeFrom(from.additional_resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_instances()) {
      set_instances(from.instances());
    }
    if (from.has_number_ports()) {
      set_number_ports(from.number_ports());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Target::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Target::CopyFrom(const Target& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Target::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;

  for (int i = 0; i < minimal_resources_size(); i++) {
    if (!this->minimal_resources(i).IsInitialized()) return false;
  }
  for (int i = 0; i < additional_resources_size(); i++) {
    if (!this->additional_resources(i).IsInitialized()) return false;
  }
  return true;
}

void Target::Swap(Target* other) {
  if (other != this) {
    std::swap(instances_, other->instances_);
    minimal_resources_.Swap(&other->minimal_resources_);
    additional_resources_.Swap(&other->additional_resources_);
    std::swap(number_ports_, other->number_ports_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Target::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Target_descriptor_;
  metadata.reflection = Target_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Targets::kModeFieldNumber;
const int Targets::kAgentsFieldNumber;
const int Targets::kCoordinatorsFieldNumber;
const int Targets::kDbserversFieldNumber;
const int Targets::kSecondariesFieldNumber;
const int Targets::kAsynchronousReplicationFieldNumber;
#endif  // !_MSC_VER

Targets::Targets()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Targets::InitAsDefaultInstance() {
  agents_ = const_cast< ::arangodb::Target*>(&::arangodb::Target::default_instance());
  coordinators_ = const_cast< ::arangodb::Target*>(&::arangodb::Target::default_instance());
  dbservers_ = const_cast< ::arangodb::Target*>(&::arangodb::Target::default_instance());
  secondaries_ = const_cast< ::arangodb::Target*>(&::arangodb::Target::default_instance());
}

Targets::Targets(const Targets& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Targets::SharedCtor() {
  _cached_size_ = 0;
  mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  agents_ = NULL;
  coordinators_ = NULL;
  dbservers_ = NULL;
  secondaries_ = NULL;
  asynchronous_replication_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Targets::~Targets() {
  SharedDtor();
}

void Targets::SharedDtor() {
  if (mode_ != &::google::protobuf::internal::kEmptyString) {
    delete mode_;
  }
  if (this != default_instance_) {
    delete agents_;
    delete coordinators_;
    delete dbservers_;
    delete secondaries_;
  }
}

void Targets::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Targets::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Targets_descriptor_;
}

const Targets& Targets::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

Targets* Targets::default_instance_ = NULL;

Targets* Targets::New() const {
  return new Targets;
}

void Targets::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mode()) {
      if (mode_ != &::google::protobuf::internal::kEmptyString) {
        mode_->clear();
      }
    }
    if (has_agents()) {
      if (agents_ != NULL) agents_->::arangodb::Target::Clear();
    }
    if (has_coordinators()) {
      if (coordinators_ != NULL) coordinators_->::arangodb::Target::Clear();
    }
    if (has_dbservers()) {
      if (dbservers_ != NULL) dbservers_->::arangodb::Target::Clear();
    }
    if (has_secondaries()) {
      if (secondaries_ != NULL) secondaries_->::arangodb::Target::Clear();
    }
    asynchronous_replication_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Targets::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string mode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mode()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mode().data(), this->mode().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_agents;
        break;
      }

      // required .arangodb.Target agents = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agents()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_coordinators;
        break;
      }

      // required .arangodb.Target coordinators = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coordinators:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coordinators()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_dbservers;
        break;
      }

      // required .arangodb.Target dbservers = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dbservers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dbservers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_secondaries;
        break;
      }

      // required .arangodb.Target secondaries = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_secondaries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_secondaries()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_asynchronous_replication;
        break;
      }

      // optional bool asynchronous_replication = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_asynchronous_replication:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &asynchronous_replication_)));
          set_has_asynchronous_replication();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Targets::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mode().data(), this->mode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->mode(), output);
  }

  // required .arangodb.Target agents = 2;
  if (has_agents()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->agents(), output);
  }

  // required .arangodb.Target coordinators = 3;
  if (has_coordinators()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->coordinators(), output);
  }

  // required .arangodb.Target dbservers = 4;
  if (has_dbservers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->dbservers(), output);
  }

  // required .arangodb.Target secondaries = 5;
  if (has_secondaries()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->secondaries(), output);
  }

  // optional bool asynchronous_replication = 6;
  if (has_asynchronous_replication()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->asynchronous_replication(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Targets::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mode().data(), this->mode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->mode(), target);
  }

  // required .arangodb.Target agents = 2;
  if (has_agents()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->agents(), target);
  }

  // required .arangodb.Target coordinators = 3;
  if (has_coordinators()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->coordinators(), target);
  }

  // required .arangodb.Target dbservers = 4;
  if (has_dbservers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->dbservers(), target);
  }

  // required .arangodb.Target secondaries = 5;
  if (has_secondaries()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->secondaries(), target);
  }

  // optional bool asynchronous_replication = 6;
  if (has_asynchronous_replication()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->asynchronous_replication(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Targets::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string mode = 1;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mode());
    }

    // required .arangodb.Target agents = 2;
    if (has_agents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agents());
    }

    // required .arangodb.Target coordinators = 3;
    if (has_coordinators()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coordinators());
    }

    // required .arangodb.Target dbservers = 4;
    if (has_dbservers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dbservers());
    }

    // required .arangodb.Target secondaries = 5;
    if (has_secondaries()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->secondaries());
    }

    // optional bool asynchronous_replication = 6;
    if (has_asynchronous_replication()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Targets::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Targets* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Targets*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Targets::MergeFrom(const Targets& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_agents()) {
      mutable_agents()->::arangodb::Target::MergeFrom(from.agents());
    }
    if (from.has_coordinators()) {
      mutable_coordinators()->::arangodb::Target::MergeFrom(from.coordinators());
    }
    if (from.has_dbservers()) {
      mutable_dbservers()->::arangodb::Target::MergeFrom(from.dbservers());
    }
    if (from.has_secondaries()) {
      mutable_secondaries()->::arangodb::Target::MergeFrom(from.secondaries());
    }
    if (from.has_asynchronous_replication()) {
      set_asynchronous_replication(from.asynchronous_replication());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Targets::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Targets::CopyFrom(const Targets& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Targets::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_agents()) {
    if (!this->agents().IsInitialized()) return false;
  }
  if (has_coordinators()) {
    if (!this->coordinators().IsInitialized()) return false;
  }
  if (has_dbservers()) {
    if (!this->dbservers().IsInitialized()) return false;
  }
  if (has_secondaries()) {
    if (!this->secondaries().IsInitialized()) return false;
  }
  return true;
}

void Targets::Swap(Targets* other) {
  if (other != this) {
    std::swap(mode_, other->mode_);
    std::swap(agents_, other->agents_);
    std::swap(coordinators_, other->coordinators_);
    std::swap(dbservers_, other->dbservers_);
    std::swap(secondaries_, other->secondaries_);
    std::swap(asynchronous_replication_, other->asynchronous_replication_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Targets::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Targets_descriptor_;
  metadata.reflection = Targets_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TaskPlan::kStateFieldNumber;
const int TaskPlan::kIsPrimaryFieldNumber;
const int TaskPlan::kPersistenceIdFieldNumber;
const int TaskPlan::kStartedFieldNumber;
#endif  // !_MSC_VER

TaskPlan::TaskPlan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TaskPlan::InitAsDefaultInstance() {
}

TaskPlan::TaskPlan(const TaskPlan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TaskPlan::SharedCtor() {
  _cached_size_ = 0;
  state_ = 1;
  is_primary_ = false;
  persistence_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  started_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskPlan::~TaskPlan() {
  SharedDtor();
}

void TaskPlan::SharedDtor() {
  if (persistence_id_ != &::google::protobuf::internal::kEmptyString) {
    delete persistence_id_;
  }
  if (this != default_instance_) {
  }
}

void TaskPlan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskPlan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskPlan_descriptor_;
}

const TaskPlan& TaskPlan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

TaskPlan* TaskPlan::default_instance_ = NULL;

TaskPlan* TaskPlan::New() const {
  return new TaskPlan;
}

void TaskPlan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    state_ = 1;
    is_primary_ = false;
    if (has_persistence_id()) {
      if (persistence_id_ != &::google::protobuf::internal::kEmptyString) {
        persistence_id_->clear();
      }
    }
    started_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TaskPlan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .arangodb.TaskPlanState state = 1 [default = TASK_STATE_NEW];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::arangodb::TaskPlanState_IsValid(value)) {
            set_state(static_cast< ::arangodb::TaskPlanState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_primary;
        break;
      }

      // required bool is_primary = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_primary:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_primary_)));
          set_has_is_primary();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_persistence_id;
        break;
      }

      // optional string persistence_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_persistence_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_persistence_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->persistence_id().data(), this->persistence_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(33)) goto parse_started;
        break;
      }

      // optional double started = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_started:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &started_)));
          set_has_started();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TaskPlan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .arangodb.TaskPlanState state = 1 [default = TASK_STATE_NEW];
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  // required bool is_primary = 2;
  if (has_is_primary()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_primary(), output);
  }

  // optional string persistence_id = 3;
  if (has_persistence_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->persistence_id().data(), this->persistence_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->persistence_id(), output);
  }

  // optional double started = 4;
  if (has_started()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->started(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TaskPlan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .arangodb.TaskPlanState state = 1 [default = TASK_STATE_NEW];
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  // required bool is_primary = 2;
  if (has_is_primary()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->is_primary(), target);
  }

  // optional string persistence_id = 3;
  if (has_persistence_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->persistence_id().data(), this->persistence_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->persistence_id(), target);
  }

  // optional double started = 4;
  if (has_started()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->started(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TaskPlan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .arangodb.TaskPlanState state = 1 [default = TASK_STATE_NEW];
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // required bool is_primary = 2;
    if (has_is_primary()) {
      total_size += 1 + 1;
    }

    // optional string persistence_id = 3;
    if (has_persistence_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->persistence_id());
    }

    // optional double started = 4;
    if (has_started()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskPlan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TaskPlan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TaskPlan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TaskPlan::MergeFrom(const TaskPlan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_is_primary()) {
      set_is_primary(from.is_primary());
    }
    if (from.has_persistence_id()) {
      set_persistence_id(from.persistence_id());
    }
    if (from.has_started()) {
      set_started(from.started());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TaskPlan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskPlan::CopyFrom(const TaskPlan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskPlan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TaskPlan::Swap(TaskPlan* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(is_primary_, other->is_primary_);
    std::swap(persistence_id_, other->persistence_id_);
    std::swap(started_, other->started_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TaskPlan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskPlan_descriptor_;
  metadata.reflection = TaskPlan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TasksPlan::kEntriesFieldNumber;
#endif  // !_MSC_VER

TasksPlan::TasksPlan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TasksPlan::InitAsDefaultInstance() {
}

TasksPlan::TasksPlan(const TasksPlan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TasksPlan::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TasksPlan::~TasksPlan() {
  SharedDtor();
}

void TasksPlan::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TasksPlan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TasksPlan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TasksPlan_descriptor_;
}

const TasksPlan& TasksPlan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

TasksPlan* TasksPlan::default_instance_ = NULL;

TasksPlan* TasksPlan::New() const {
  return new TasksPlan;
}

void TasksPlan::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TasksPlan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .arangodb.TaskPlan entries = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TasksPlan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .arangodb.TaskPlan entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TasksPlan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .arangodb.TaskPlan entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TasksPlan::ByteSize() const {
  int total_size = 0;

  // repeated .arangodb.TaskPlan entries = 1;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TasksPlan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TasksPlan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TasksPlan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TasksPlan::MergeFrom(const TasksPlan& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TasksPlan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TasksPlan::CopyFrom(const TasksPlan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TasksPlan::IsInitialized() const {

  for (int i = 0; i < entries_size(); i++) {
    if (!this->entries(i).IsInitialized()) return false;
  }
  return true;
}

void TasksPlan::Swap(TasksPlan* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TasksPlan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TasksPlan_descriptor_;
  metadata.reflection = TasksPlan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Plan::kAgentsFieldNumber;
const int Plan::kCoordinatorsFieldNumber;
const int Plan::kDbserversFieldNumber;
const int Plan::kSecondariesFieldNumber;
#endif  // !_MSC_VER

Plan::Plan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Plan::InitAsDefaultInstance() {
  agents_ = const_cast< ::arangodb::TasksPlan*>(&::arangodb::TasksPlan::default_instance());
  coordinators_ = const_cast< ::arangodb::TasksPlan*>(&::arangodb::TasksPlan::default_instance());
  dbservers_ = const_cast< ::arangodb::TasksPlan*>(&::arangodb::TasksPlan::default_instance());
  secondaries_ = const_cast< ::arangodb::TasksPlan*>(&::arangodb::TasksPlan::default_instance());
}

Plan::Plan(const Plan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Plan::SharedCtor() {
  _cached_size_ = 0;
  agents_ = NULL;
  coordinators_ = NULL;
  dbservers_ = NULL;
  secondaries_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Plan::~Plan() {
  SharedDtor();
}

void Plan::SharedDtor() {
  if (this != default_instance_) {
    delete agents_;
    delete coordinators_;
    delete dbservers_;
    delete secondaries_;
  }
}

void Plan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Plan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Plan_descriptor_;
}

const Plan& Plan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

Plan* Plan::default_instance_ = NULL;

Plan* Plan::New() const {
  return new Plan;
}

void Plan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_agents()) {
      if (agents_ != NULL) agents_->::arangodb::TasksPlan::Clear();
    }
    if (has_coordinators()) {
      if (coordinators_ != NULL) coordinators_->::arangodb::TasksPlan::Clear();
    }
    if (has_dbservers()) {
      if (dbservers_ != NULL) dbservers_->::arangodb::TasksPlan::Clear();
    }
    if (has_secondaries()) {
      if (secondaries_ != NULL) secondaries_->::arangodb::TasksPlan::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Plan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .arangodb.TasksPlan agents = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agents()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_coordinators;
        break;
      }

      // required .arangodb.TasksPlan coordinators = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coordinators:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coordinators()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_dbservers;
        break;
      }

      // required .arangodb.TasksPlan dbservers = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dbservers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dbservers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_secondaries;
        break;
      }

      // required .arangodb.TasksPlan secondaries = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_secondaries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_secondaries()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Plan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .arangodb.TasksPlan agents = 1;
  if (has_agents()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->agents(), output);
  }

  // required .arangodb.TasksPlan coordinators = 2;
  if (has_coordinators()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->coordinators(), output);
  }

  // required .arangodb.TasksPlan dbservers = 3;
  if (has_dbservers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->dbservers(), output);
  }

  // required .arangodb.TasksPlan secondaries = 4;
  if (has_secondaries()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->secondaries(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Plan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .arangodb.TasksPlan agents = 1;
  if (has_agents()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->agents(), target);
  }

  // required .arangodb.TasksPlan coordinators = 2;
  if (has_coordinators()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->coordinators(), target);
  }

  // required .arangodb.TasksPlan dbservers = 3;
  if (has_dbservers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->dbservers(), target);
  }

  // required .arangodb.TasksPlan secondaries = 4;
  if (has_secondaries()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->secondaries(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Plan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .arangodb.TasksPlan agents = 1;
    if (has_agents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agents());
    }

    // required .arangodb.TasksPlan coordinators = 2;
    if (has_coordinators()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coordinators());
    }

    // required .arangodb.TasksPlan dbservers = 3;
    if (has_dbservers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dbservers());
    }

    // required .arangodb.TasksPlan secondaries = 4;
    if (has_secondaries()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->secondaries());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Plan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Plan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Plan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Plan::MergeFrom(const Plan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agents()) {
      mutable_agents()->::arangodb::TasksPlan::MergeFrom(from.agents());
    }
    if (from.has_coordinators()) {
      mutable_coordinators()->::arangodb::TasksPlan::MergeFrom(from.coordinators());
    }
    if (from.has_dbservers()) {
      mutable_dbservers()->::arangodb::TasksPlan::MergeFrom(from.dbservers());
    }
    if (from.has_secondaries()) {
      mutable_secondaries()->::arangodb::TasksPlan::MergeFrom(from.secondaries());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Plan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Plan::CopyFrom(const Plan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Plan::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_agents()) {
    if (!this->agents().IsInitialized()) return false;
  }
  if (has_coordinators()) {
    if (!this->coordinators().IsInitialized()) return false;
  }
  if (has_dbservers()) {
    if (!this->dbservers().IsInitialized()) return false;
  }
  if (has_secondaries()) {
    if (!this->secondaries().IsInitialized()) return false;
  }
  return true;
}

void Plan::Swap(Plan* other) {
  if (other != this) {
    std::swap(agents_, other->agents_);
    std::swap(coordinators_, other->coordinators_);
    std::swap(dbservers_, other->dbservers_);
    std::swap(secondaries_, other->secondaries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Plan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Plan_descriptor_;
  metadata.reflection = Plan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TaskCurrent::kSlaveIdFieldNumber;
const int TaskCurrent::kOfferIdFieldNumber;
const int TaskCurrent::kResourcesFieldNumber;
const int TaskCurrent::kPortsFieldNumber;
const int TaskCurrent::kHostnameFieldNumber;
const int TaskCurrent::kContainerPathFieldNumber;
const int TaskCurrent::kStateFieldNumber;
const int TaskCurrent::kTaskInfoFieldNumber;
const int TaskCurrent::kTaskStatusFieldNumber;
#endif  // !_MSC_VER

TaskCurrent::TaskCurrent()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TaskCurrent::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  offer_id_ = const_cast< ::mesos::OfferID*>(&::mesos::OfferID::default_instance());
  task_info_ = const_cast< ::mesos::TaskInfo*>(&::mesos::TaskInfo::default_instance());
  task_status_ = const_cast< ::mesos::TaskStatus*>(&::mesos::TaskStatus::default_instance());
}

TaskCurrent::TaskCurrent(const TaskCurrent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TaskCurrent::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  offer_id_ = NULL;
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  state_ = 1;
  task_info_ = NULL;
  task_status_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskCurrent::~TaskCurrent() {
  SharedDtor();
}

void TaskCurrent::SharedDtor() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (container_path_ != &::google::protobuf::internal::kEmptyString) {
    delete container_path_;
  }
  if (this != default_instance_) {
    delete slave_id_;
    delete offer_id_;
    delete task_info_;
    delete task_status_;
  }
}

void TaskCurrent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskCurrent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskCurrent_descriptor_;
}

const TaskCurrent& TaskCurrent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

TaskCurrent* TaskCurrent::default_instance_ = NULL;

TaskCurrent* TaskCurrent::New() const {
  return new TaskCurrent;
}

void TaskCurrent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_offer_id()) {
      if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
    }
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::kEmptyString) {
        hostname_->clear();
      }
    }
    if (has_container_path()) {
      if (container_path_ != &::google::protobuf::internal::kEmptyString) {
        container_path_->clear();
      }
    }
    state_ = 1;
    if (has_task_info()) {
      if (task_info_ != NULL) task_info_->::mesos::TaskInfo::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_task_status()) {
      if (task_status_ != NULL) task_status_->::mesos::TaskStatus::Clear();
    }
  }
  resources_.Clear();
  ports_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TaskCurrent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.SlaveID slave_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_offer_id;
        break;
      }

      // optional .mesos.OfferID offer_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_offer_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_offer_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_resources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_resources;
        if (input->ExpectTag(32)) goto parse_ports;
        break;
      }

      // repeated uint32 ports = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ports:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_ports())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_ports())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ports;
        if (input->ExpectTag(42)) goto parse_hostname;
        break;
      }

      // optional string hostname = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_container_path;
        break;
      }

      // optional string container_path = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_container_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_container_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->container_path().data(), this->container_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_state;
        break;
      }

      // required .arangodb.TaskCurrentState state = 7 [default = INSTANCE_STATE_UNUSED];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::arangodb::TaskCurrentState_IsValid(value)) {
            set_state(static_cast< ::arangodb::TaskCurrentState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_task_info;
        break;
      }

      // optional .mesos.TaskInfo task_info = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_task_status;
        break;
      }

      // optional .mesos.TaskStatus task_status = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_status()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TaskCurrent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->slave_id(), output);
  }

  // optional .mesos.OfferID offer_id = 2;
  if (has_offer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->offer_id(), output);
  }

  // repeated .mesos.Resource resources = 3;
  for (int i = 0; i < this->resources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->resources(i), output);
  }

  // repeated uint32 ports = 4;
  for (int i = 0; i < this->ports_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->ports(i), output);
  }

  // optional string hostname = 5;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->hostname(), output);
  }

  // optional string container_path = 6;
  if (has_container_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->container_path().data(), this->container_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->container_path(), output);
  }

  // required .arangodb.TaskCurrentState state = 7 [default = INSTANCE_STATE_UNUSED];
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->state(), output);
  }

  // optional .mesos.TaskInfo task_info = 8;
  if (has_task_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->task_info(), output);
  }

  // optional .mesos.TaskStatus task_status = 9;
  if (has_task_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->task_status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TaskCurrent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->slave_id(), target);
  }

  // optional .mesos.OfferID offer_id = 2;
  if (has_offer_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->offer_id(), target);
  }

  // repeated .mesos.Resource resources = 3;
  for (int i = 0; i < this->resources_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->resources(i), target);
  }

  // repeated uint32 ports = 4;
  for (int i = 0; i < this->ports_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(4, this->ports(i), target);
  }

  // optional string hostname = 5;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->hostname(), target);
  }

  // optional string container_path = 6;
  if (has_container_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->container_path().data(), this->container_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->container_path(), target);
  }

  // required .arangodb.TaskCurrentState state = 7 [default = INSTANCE_STATE_UNUSED];
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->state(), target);
  }

  // optional .mesos.TaskInfo task_info = 8;
  if (has_task_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->task_info(), target);
  }

  // optional .mesos.TaskStatus task_status = 9;
  if (has_task_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->task_status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TaskCurrent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.SlaveID slave_id = 1;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->slave_id());
    }

    // optional .mesos.OfferID offer_id = 2;
    if (has_offer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->offer_id());
    }

    // optional string hostname = 5;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional string container_path = 6;
    if (has_container_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->container_path());
    }

    // required .arangodb.TaskCurrentState state = 7 [default = INSTANCE_STATE_UNUSED];
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional .mesos.TaskInfo task_info = 8;
    if (has_task_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_info());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .mesos.TaskStatus task_status = 9;
    if (has_task_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->task_status());
    }

  }
  // repeated .mesos.Resource resources = 3;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  // repeated uint32 ports = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->ports_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->ports(i));
    }
    total_size += 1 * this->ports_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskCurrent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TaskCurrent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TaskCurrent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TaskCurrent::MergeFrom(const TaskCurrent& from) {
  GOOGLE_CHECK_NE(&from, this);
  resources_.MergeFrom(from.resources_);
  ports_.MergeFrom(from.ports_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_offer_id()) {
      mutable_offer_id()->::mesos::OfferID::MergeFrom(from.offer_id());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_container_path()) {
      set_container_path(from.container_path());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_task_info()) {
      mutable_task_info()->::mesos::TaskInfo::MergeFrom(from.task_info());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_task_status()) {
      mutable_task_status()->::mesos::TaskStatus::MergeFrom(from.task_status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TaskCurrent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskCurrent::CopyFrom(const TaskCurrent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskCurrent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000040) != 0x00000040) return false;

  if (has_slave_id()) {
    if (!this->slave_id().IsInitialized()) return false;
  }
  if (has_offer_id()) {
    if (!this->offer_id().IsInitialized()) return false;
  }
  for (int i = 0; i < resources_size(); i++) {
    if (!this->resources(i).IsInitialized()) return false;
  }
  if (has_task_info()) {
    if (!this->task_info().IsInitialized()) return false;
  }
  if (has_task_status()) {
    if (!this->task_status().IsInitialized()) return false;
  }
  return true;
}

void TaskCurrent::Swap(TaskCurrent* other) {
  if (other != this) {
    std::swap(slave_id_, other->slave_id_);
    std::swap(offer_id_, other->offer_id_);
    resources_.Swap(&other->resources_);
    ports_.Swap(&other->ports_);
    std::swap(hostname_, other->hostname_);
    std::swap(container_path_, other->container_path_);
    std::swap(state_, other->state_);
    std::swap(task_info_, other->task_info_);
    std::swap(task_status_, other->task_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TaskCurrent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskCurrent_descriptor_;
  metadata.reflection = TaskCurrent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TasksCurrent::kEntriesFieldNumber;
#endif  // !_MSC_VER

TasksCurrent::TasksCurrent()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TasksCurrent::InitAsDefaultInstance() {
}

TasksCurrent::TasksCurrent(const TasksCurrent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TasksCurrent::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TasksCurrent::~TasksCurrent() {
  SharedDtor();
}

void TasksCurrent::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TasksCurrent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TasksCurrent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TasksCurrent_descriptor_;
}

const TasksCurrent& TasksCurrent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

TasksCurrent* TasksCurrent::default_instance_ = NULL;

TasksCurrent* TasksCurrent::New() const {
  return new TasksCurrent;
}

void TasksCurrent::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TasksCurrent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .arangodb.TaskCurrent entries = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TasksCurrent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .arangodb.TaskCurrent entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TasksCurrent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .arangodb.TaskCurrent entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TasksCurrent::ByteSize() const {
  int total_size = 0;

  // repeated .arangodb.TaskCurrent entries = 1;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TasksCurrent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TasksCurrent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TasksCurrent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TasksCurrent::MergeFrom(const TasksCurrent& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TasksCurrent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TasksCurrent::CopyFrom(const TasksCurrent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TasksCurrent::IsInitialized() const {

  for (int i = 0; i < entries_size(); i++) {
    if (!this->entries(i).IsInitialized()) return false;
  }
  return true;
}

void TasksCurrent::Swap(TasksCurrent* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TasksCurrent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TasksCurrent_descriptor_;
  metadata.reflection = TasksCurrent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Current::kAgentsFieldNumber;
const int Current::kCoordinatorsFieldNumber;
const int Current::kDbserversFieldNumber;
const int Current::kSecondariesFieldNumber;
const int Current::kClusterCompleteFieldNumber;
const int Current::kClusterBootstrappedDBserversFieldNumber;
const int Current::kClusterUpgradedDBFieldNumber;
const int Current::kClusterBootstrappedCoordinatorsFieldNumber;
const int Current::kClusterInitializedFieldNumber;
#endif  // !_MSC_VER

Current::Current()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Current::InitAsDefaultInstance() {
  agents_ = const_cast< ::arangodb::TasksCurrent*>(&::arangodb::TasksCurrent::default_instance());
  coordinators_ = const_cast< ::arangodb::TasksCurrent*>(&::arangodb::TasksCurrent::default_instance());
  dbservers_ = const_cast< ::arangodb::TasksCurrent*>(&::arangodb::TasksCurrent::default_instance());
  secondaries_ = const_cast< ::arangodb::TasksCurrent*>(&::arangodb::TasksCurrent::default_instance());
}

Current::Current(const Current& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Current::SharedCtor() {
  _cached_size_ = 0;
  agents_ = NULL;
  coordinators_ = NULL;
  dbservers_ = NULL;
  secondaries_ = NULL;
  cluster_complete_ = false;
  cluster_bootstrappeddbservers_ = false;
  cluster_upgradeddb_ = false;
  cluster_bootstrappedcoordinators_ = false;
  cluster_initialized_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Current::~Current() {
  SharedDtor();
}

void Current::SharedDtor() {
  if (this != default_instance_) {
    delete agents_;
    delete coordinators_;
    delete dbservers_;
    delete secondaries_;
  }
}

void Current::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Current::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Current_descriptor_;
}

const Current& Current::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

Current* Current::default_instance_ = NULL;

Current* Current::New() const {
  return new Current;
}

void Current::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_agents()) {
      if (agents_ != NULL) agents_->::arangodb::TasksCurrent::Clear();
    }
    if (has_coordinators()) {
      if (coordinators_ != NULL) coordinators_->::arangodb::TasksCurrent::Clear();
    }
    if (has_dbservers()) {
      if (dbservers_ != NULL) dbservers_->::arangodb::TasksCurrent::Clear();
    }
    if (has_secondaries()) {
      if (secondaries_ != NULL) secondaries_->::arangodb::TasksCurrent::Clear();
    }
    cluster_complete_ = false;
    cluster_bootstrappeddbservers_ = false;
    cluster_upgradeddb_ = false;
    cluster_bootstrappedcoordinators_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    cluster_initialized_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Current::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .arangodb.TasksCurrent agents = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agents()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_coordinators;
        break;
      }

      // required .arangodb.TasksCurrent coordinators = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coordinators:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coordinators()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_dbservers;
        break;
      }

      // required .arangodb.TasksCurrent dbservers = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dbservers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dbservers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_secondaries;
        break;
      }

      // required .arangodb.TasksCurrent secondaries = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_secondaries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_secondaries()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_cluster_complete;
        break;
      }

      // required bool cluster_complete = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cluster_complete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cluster_complete_)));
          set_has_cluster_complete();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_cluster_bootstrappedDBservers;
        break;
      }

      // required bool cluster_bootstrappedDBservers = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cluster_bootstrappedDBservers:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cluster_bootstrappeddbservers_)));
          set_has_cluster_bootstrappeddbservers();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_cluster_upgradedDB;
        break;
      }

      // required bool cluster_upgradedDB = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cluster_upgradedDB:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cluster_upgradeddb_)));
          set_has_cluster_upgradeddb();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_cluster_bootstrappedCoordinators;
        break;
      }

      // required bool cluster_bootstrappedCoordinators = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cluster_bootstrappedCoordinators:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cluster_bootstrappedcoordinators_)));
          set_has_cluster_bootstrappedcoordinators();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_cluster_initialized;
        break;
      }

      // required bool cluster_initialized = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cluster_initialized:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cluster_initialized_)));
          set_has_cluster_initialized();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Current::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .arangodb.TasksCurrent agents = 1;
  if (has_agents()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->agents(), output);
  }

  // required .arangodb.TasksCurrent coordinators = 2;
  if (has_coordinators()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->coordinators(), output);
  }

  // required .arangodb.TasksCurrent dbservers = 3;
  if (has_dbservers()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->dbservers(), output);
  }

  // required .arangodb.TasksCurrent secondaries = 4;
  if (has_secondaries()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->secondaries(), output);
  }

  // required bool cluster_complete = 5;
  if (has_cluster_complete()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->cluster_complete(), output);
  }

  // required bool cluster_bootstrappedDBservers = 6;
  if (has_cluster_bootstrappeddbservers()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->cluster_bootstrappeddbservers(), output);
  }

  // required bool cluster_upgradedDB = 7;
  if (has_cluster_upgradeddb()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->cluster_upgradeddb(), output);
  }

  // required bool cluster_bootstrappedCoordinators = 8;
  if (has_cluster_bootstrappedcoordinators()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->cluster_bootstrappedcoordinators(), output);
  }

  // required bool cluster_initialized = 9;
  if (has_cluster_initialized()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->cluster_initialized(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Current::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .arangodb.TasksCurrent agents = 1;
  if (has_agents()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->agents(), target);
  }

  // required .arangodb.TasksCurrent coordinators = 2;
  if (has_coordinators()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->coordinators(), target);
  }

  // required .arangodb.TasksCurrent dbservers = 3;
  if (has_dbservers()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->dbservers(), target);
  }

  // required .arangodb.TasksCurrent secondaries = 4;
  if (has_secondaries()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->secondaries(), target);
  }

  // required bool cluster_complete = 5;
  if (has_cluster_complete()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->cluster_complete(), target);
  }

  // required bool cluster_bootstrappedDBservers = 6;
  if (has_cluster_bootstrappeddbservers()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->cluster_bootstrappeddbservers(), target);
  }

  // required bool cluster_upgradedDB = 7;
  if (has_cluster_upgradeddb()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->cluster_upgradeddb(), target);
  }

  // required bool cluster_bootstrappedCoordinators = 8;
  if (has_cluster_bootstrappedcoordinators()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->cluster_bootstrappedcoordinators(), target);
  }

  // required bool cluster_initialized = 9;
  if (has_cluster_initialized()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->cluster_initialized(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Current::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .arangodb.TasksCurrent agents = 1;
    if (has_agents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agents());
    }

    // required .arangodb.TasksCurrent coordinators = 2;
    if (has_coordinators()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coordinators());
    }

    // required .arangodb.TasksCurrent dbservers = 3;
    if (has_dbservers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dbservers());
    }

    // required .arangodb.TasksCurrent secondaries = 4;
    if (has_secondaries()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->secondaries());
    }

    // required bool cluster_complete = 5;
    if (has_cluster_complete()) {
      total_size += 1 + 1;
    }

    // required bool cluster_bootstrappedDBservers = 6;
    if (has_cluster_bootstrappeddbservers()) {
      total_size += 1 + 1;
    }

    // required bool cluster_upgradedDB = 7;
    if (has_cluster_upgradeddb()) {
      total_size += 1 + 1;
    }

    // required bool cluster_bootstrappedCoordinators = 8;
    if (has_cluster_bootstrappedcoordinators()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required bool cluster_initialized = 9;
    if (has_cluster_initialized()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Current::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Current* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Current*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Current::MergeFrom(const Current& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agents()) {
      mutable_agents()->::arangodb::TasksCurrent::MergeFrom(from.agents());
    }
    if (from.has_coordinators()) {
      mutable_coordinators()->::arangodb::TasksCurrent::MergeFrom(from.coordinators());
    }
    if (from.has_dbservers()) {
      mutable_dbservers()->::arangodb::TasksCurrent::MergeFrom(from.dbservers());
    }
    if (from.has_secondaries()) {
      mutable_secondaries()->::arangodb::TasksCurrent::MergeFrom(from.secondaries());
    }
    if (from.has_cluster_complete()) {
      set_cluster_complete(from.cluster_complete());
    }
    if (from.has_cluster_bootstrappeddbservers()) {
      set_cluster_bootstrappeddbservers(from.cluster_bootstrappeddbservers());
    }
    if (from.has_cluster_upgradeddb()) {
      set_cluster_upgradeddb(from.cluster_upgradeddb());
    }
    if (from.has_cluster_bootstrappedcoordinators()) {
      set_cluster_bootstrappedcoordinators(from.cluster_bootstrappedcoordinators());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_cluster_initialized()) {
      set_cluster_initialized(from.cluster_initialized());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Current::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Current::CopyFrom(const Current& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Current::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  if (has_agents()) {
    if (!this->agents().IsInitialized()) return false;
  }
  if (has_coordinators()) {
    if (!this->coordinators().IsInitialized()) return false;
  }
  if (has_dbservers()) {
    if (!this->dbservers().IsInitialized()) return false;
  }
  if (has_secondaries()) {
    if (!this->secondaries().IsInitialized()) return false;
  }
  return true;
}

void Current::Swap(Current* other) {
  if (other != this) {
    std::swap(agents_, other->agents_);
    std::swap(coordinators_, other->coordinators_);
    std::swap(dbservers_, other->dbservers_);
    std::swap(secondaries_, other->secondaries_);
    std::swap(cluster_complete_, other->cluster_complete_);
    std::swap(cluster_bootstrappeddbservers_, other->cluster_bootstrappeddbservers_);
    std::swap(cluster_upgradeddb_, other->cluster_upgradeddb_);
    std::swap(cluster_bootstrappedcoordinators_, other->cluster_bootstrappedcoordinators_);
    std::swap(cluster_initialized_, other->cluster_initialized_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Current::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Current_descriptor_;
  metadata.reflection = Current_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int State::kFrameworkIdFieldNumber;
const int State::kTargetsFieldNumber;
const int State::kPlanFieldNumber;
const int State::kCurrentFieldNumber;
#endif  // !_MSC_VER

State::State()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void State::InitAsDefaultInstance() {
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  targets_ = const_cast< ::arangodb::Targets*>(&::arangodb::Targets::default_instance());
  plan_ = const_cast< ::arangodb::Plan*>(&::arangodb::Plan::default_instance());
  current_ = const_cast< ::arangodb::Current*>(&::arangodb::Current::default_instance());
}

State::State(const State& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void State::SharedCtor() {
  _cached_size_ = 0;
  framework_id_ = NULL;
  targets_ = NULL;
  plan_ = NULL;
  current_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

State::~State() {
  SharedDtor();
}

void State::SharedDtor() {
  if (this != default_instance_) {
    delete framework_id_;
    delete targets_;
    delete plan_;
    delete current_;
  }
}

void State::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* State::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return State_descriptor_;
}

const State& State::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_arangodb_2eproto();
  return *default_instance_;
}

State* State::default_instance_ = NULL;

State* State::New() const {
  return new State;
}

void State::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_targets()) {
      if (targets_ != NULL) targets_->::arangodb::Targets::Clear();
    }
    if (has_plan()) {
      if (plan_ != NULL) plan_->::arangodb::Plan::Clear();
    }
    if (has_current()) {
      if (current_ != NULL) current_->::arangodb::Current::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool State::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.FrameworkID framework_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_targets;
        break;
      }

      // required .arangodb.Targets targets = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_targets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_targets()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_plan;
        break;
      }

      // required .arangodb.Plan plan = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_plan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_plan()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_current;
        break;
      }

      // required .arangodb.Current current = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_current:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_current()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void State::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->framework_id(), output);
  }

  // required .arangodb.Targets targets = 2;
  if (has_targets()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->targets(), output);
  }

  // required .arangodb.Plan plan = 3;
  if (has_plan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->plan(), output);
  }

  // required .arangodb.Current current = 4;
  if (has_current()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->current(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* State::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .mesos.FrameworkID framework_id = 1;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->framework_id(), target);
  }

  // required .arangodb.Targets targets = 2;
  if (has_targets()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->targets(), target);
  }

  // required .arangodb.Plan plan = 3;
  if (has_plan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->plan(), target);
  }

  // required .arangodb.Current current = 4;
  if (has_current()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->current(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int State::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .mesos.FrameworkID framework_id = 1;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->framework_id());
    }

    // required .arangodb.Targets targets = 2;
    if (has_targets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->targets());
    }

    // required .arangodb.Plan plan = 3;
    if (has_plan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->plan());
    }

    // required .arangodb.Current current = 4;
    if (has_current()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->current());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void State::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const State* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const State*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void State::MergeFrom(const State& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_targets()) {
      mutable_targets()->::arangodb::Targets::MergeFrom(from.targets());
    }
    if (from.has_plan()) {
      mutable_plan()->::arangodb::Plan::MergeFrom(from.plan());
    }
    if (from.has_current()) {
      mutable_current()->::arangodb::Current::MergeFrom(from.current());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void State::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void State::CopyFrom(const State& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool State::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;

  if (has_framework_id()) {
    if (!this->framework_id().IsInitialized()) return false;
  }
  if (has_targets()) {
    if (!this->targets().IsInitialized()) return false;
  }
  if (has_plan()) {
    if (!this->plan().IsInitialized()) return false;
  }
  if (has_current()) {
    if (!this->current().IsInitialized()) return false;
  }
  return true;
}

void State::Swap(State* other) {
  if (other != this) {
    std::swap(framework_id_, other->framework_id_);
    std::swap(targets_, other->targets_);
    std::swap(plan_, other->plan_);
    std::swap(current_, other->current_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata State::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = State_descriptor_;
  metadata.reflection = State_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace arangodb

// @@protoc_insertion_point(global_scope)
