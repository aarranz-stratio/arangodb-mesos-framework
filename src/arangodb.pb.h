// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: arangodb.proto

#ifndef PROTOBUF_arangodb_2eproto__INCLUDED
#define PROTOBUF_arangodb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)
namespace arangodb {
class Current;
class CurrentDefaultTypeInternal;
extern CurrentDefaultTypeInternal _Current_default_instance_;
class Plan;
class PlanDefaultTypeInternal;
extern PlanDefaultTypeInternal _Plan_default_instance_;
class Restart;
class RestartDefaultTypeInternal;
extern RestartDefaultTypeInternal _Restart_default_instance_;
class RestartBucket;
class RestartBucketDefaultTypeInternal;
extern RestartBucketDefaultTypeInternal _RestartBucket_default_instance_;
class RestartTaskInfo;
class RestartTaskInfoDefaultTypeInternal;
extern RestartTaskInfoDefaultTypeInternal _RestartTaskInfo_default_instance_;
class State;
class StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class Target;
class TargetDefaultTypeInternal;
extern TargetDefaultTypeInternal _Target_default_instance_;
class Targets;
class TargetsDefaultTypeInternal;
extern TargetsDefaultTypeInternal _Targets_default_instance_;
class TaskCurrent;
class TaskCurrentDefaultTypeInternal;
extern TaskCurrentDefaultTypeInternal _TaskCurrent_default_instance_;
class TaskPlan;
class TaskPlanDefaultTypeInternal;
extern TaskPlanDefaultTypeInternal _TaskPlan_default_instance_;
class TasksCurrent;
class TasksCurrentDefaultTypeInternal;
extern TasksCurrentDefaultTypeInternal _TasksCurrent_default_instance_;
class TasksPlan;
class TasksPlanDefaultTypeInternal;
extern TasksPlanDefaultTypeInternal _TasksPlan_default_instance_;
}  // namespace arangodb
namespace mesos {
class Address;
class AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class Attribute;
class AttributeDefaultTypeInternal;
extern AttributeDefaultTypeInternal _Attribute_default_instance_;
class CapabilityInfo;
class CapabilityInfoDefaultTypeInternal;
extern CapabilityInfoDefaultTypeInternal _CapabilityInfo_default_instance_;
class CgroupInfo;
class CgroupInfoDefaultTypeInternal;
extern CgroupInfoDefaultTypeInternal _CgroupInfo_default_instance_;
class CgroupInfo_Blkio;
class CgroupInfo_BlkioDefaultTypeInternal;
extern CgroupInfo_BlkioDefaultTypeInternal _CgroupInfo_Blkio_default_instance_;
class CgroupInfo_Blkio_CFQ;
class CgroupInfo_Blkio_CFQDefaultTypeInternal;
extern CgroupInfo_Blkio_CFQDefaultTypeInternal _CgroupInfo_Blkio_CFQ_default_instance_;
class CgroupInfo_Blkio_CFQ_Statistics;
class CgroupInfo_Blkio_CFQ_StatisticsDefaultTypeInternal;
extern CgroupInfo_Blkio_CFQ_StatisticsDefaultTypeInternal _CgroupInfo_Blkio_CFQ_Statistics_default_instance_;
class CgroupInfo_Blkio_Statistics;
class CgroupInfo_Blkio_StatisticsDefaultTypeInternal;
extern CgroupInfo_Blkio_StatisticsDefaultTypeInternal _CgroupInfo_Blkio_Statistics_default_instance_;
class CgroupInfo_Blkio_Throttling;
class CgroupInfo_Blkio_ThrottlingDefaultTypeInternal;
extern CgroupInfo_Blkio_ThrottlingDefaultTypeInternal _CgroupInfo_Blkio_Throttling_default_instance_;
class CgroupInfo_Blkio_Throttling_Statistics;
class CgroupInfo_Blkio_Throttling_StatisticsDefaultTypeInternal;
extern CgroupInfo_Blkio_Throttling_StatisticsDefaultTypeInternal _CgroupInfo_Blkio_Throttling_Statistics_default_instance_;
class CgroupInfo_Blkio_Value;
class CgroupInfo_Blkio_ValueDefaultTypeInternal;
extern CgroupInfo_Blkio_ValueDefaultTypeInternal _CgroupInfo_Blkio_Value_default_instance_;
class CgroupInfo_NetCls;
class CgroupInfo_NetClsDefaultTypeInternal;
extern CgroupInfo_NetClsDefaultTypeInternal _CgroupInfo_NetCls_default_instance_;
class CheckInfo;
class CheckInfoDefaultTypeInternal;
extern CheckInfoDefaultTypeInternal _CheckInfo_default_instance_;
class CheckInfo_Command;
class CheckInfo_CommandDefaultTypeInternal;
extern CheckInfo_CommandDefaultTypeInternal _CheckInfo_Command_default_instance_;
class CheckInfo_Http;
class CheckInfo_HttpDefaultTypeInternal;
extern CheckInfo_HttpDefaultTypeInternal _CheckInfo_Http_default_instance_;
class CheckInfo_Tcp;
class CheckInfo_TcpDefaultTypeInternal;
extern CheckInfo_TcpDefaultTypeInternal _CheckInfo_Tcp_default_instance_;
class CheckStatusInfo;
class CheckStatusInfoDefaultTypeInternal;
extern CheckStatusInfoDefaultTypeInternal _CheckStatusInfo_default_instance_;
class CheckStatusInfo_Command;
class CheckStatusInfo_CommandDefaultTypeInternal;
extern CheckStatusInfo_CommandDefaultTypeInternal _CheckStatusInfo_Command_default_instance_;
class CheckStatusInfo_Http;
class CheckStatusInfo_HttpDefaultTypeInternal;
extern CheckStatusInfo_HttpDefaultTypeInternal _CheckStatusInfo_Http_default_instance_;
class CheckStatusInfo_Tcp;
class CheckStatusInfo_TcpDefaultTypeInternal;
extern CheckStatusInfo_TcpDefaultTypeInternal _CheckStatusInfo_Tcp_default_instance_;
class CommandInfo;
class CommandInfoDefaultTypeInternal;
extern CommandInfoDefaultTypeInternal _CommandInfo_default_instance_;
class CommandInfo_URI;
class CommandInfo_URIDefaultTypeInternal;
extern CommandInfo_URIDefaultTypeInternal _CommandInfo_URI_default_instance_;
class ContainerID;
class ContainerIDDefaultTypeInternal;
extern ContainerIDDefaultTypeInternal _ContainerID_default_instance_;
class ContainerInfo;
class ContainerInfoDefaultTypeInternal;
extern ContainerInfoDefaultTypeInternal _ContainerInfo_default_instance_;
class ContainerInfo_DockerInfo;
class ContainerInfo_DockerInfoDefaultTypeInternal;
extern ContainerInfo_DockerInfoDefaultTypeInternal _ContainerInfo_DockerInfo_default_instance_;
class ContainerInfo_DockerInfo_PortMapping;
class ContainerInfo_DockerInfo_PortMappingDefaultTypeInternal;
extern ContainerInfo_DockerInfo_PortMappingDefaultTypeInternal _ContainerInfo_DockerInfo_PortMapping_default_instance_;
class ContainerInfo_MesosInfo;
class ContainerInfo_MesosInfoDefaultTypeInternal;
extern ContainerInfo_MesosInfoDefaultTypeInternal _ContainerInfo_MesosInfo_default_instance_;
class ContainerStatus;
class ContainerStatusDefaultTypeInternal;
extern ContainerStatusDefaultTypeInternal _ContainerStatus_default_instance_;
class Credential;
class CredentialDefaultTypeInternal;
extern CredentialDefaultTypeInternal _Credential_default_instance_;
class Credentials;
class CredentialsDefaultTypeInternal;
extern CredentialsDefaultTypeInternal _Credentials_default_instance_;
class Device;
class DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
class DeviceAccess;
class DeviceAccessDefaultTypeInternal;
extern DeviceAccessDefaultTypeInternal _DeviceAccess_default_instance_;
class DeviceAccess_Access;
class DeviceAccess_AccessDefaultTypeInternal;
extern DeviceAccess_AccessDefaultTypeInternal _DeviceAccess_Access_default_instance_;
class DeviceWhitelist;
class DeviceWhitelistDefaultTypeInternal;
extern DeviceWhitelistDefaultTypeInternal _DeviceWhitelist_default_instance_;
class Device_Number;
class Device_NumberDefaultTypeInternal;
extern Device_NumberDefaultTypeInternal _Device_Number_default_instance_;
class DiscoveryInfo;
class DiscoveryInfoDefaultTypeInternal;
extern DiscoveryInfoDefaultTypeInternal _DiscoveryInfo_default_instance_;
class DiskStatistics;
class DiskStatisticsDefaultTypeInternal;
extern DiskStatisticsDefaultTypeInternal _DiskStatistics_default_instance_;
class DomainInfo;
class DomainInfoDefaultTypeInternal;
extern DomainInfoDefaultTypeInternal _DomainInfo_default_instance_;
class DomainInfo_FaultDomain;
class DomainInfo_FaultDomainDefaultTypeInternal;
extern DomainInfo_FaultDomainDefaultTypeInternal _DomainInfo_FaultDomain_default_instance_;
class DomainInfo_FaultDomain_RegionInfo;
class DomainInfo_FaultDomain_RegionInfoDefaultTypeInternal;
extern DomainInfo_FaultDomain_RegionInfoDefaultTypeInternal _DomainInfo_FaultDomain_RegionInfo_default_instance_;
class DomainInfo_FaultDomain_ZoneInfo;
class DomainInfo_FaultDomain_ZoneInfoDefaultTypeInternal;
extern DomainInfo_FaultDomain_ZoneInfoDefaultTypeInternal _DomainInfo_FaultDomain_ZoneInfo_default_instance_;
class DurationInfo;
class DurationInfoDefaultTypeInternal;
extern DurationInfoDefaultTypeInternal _DurationInfo_default_instance_;
class Environment;
class EnvironmentDefaultTypeInternal;
extern EnvironmentDefaultTypeInternal _Environment_default_instance_;
class Environment_Variable;
class Environment_VariableDefaultTypeInternal;
extern Environment_VariableDefaultTypeInternal _Environment_Variable_default_instance_;
class ExecutorID;
class ExecutorIDDefaultTypeInternal;
extern ExecutorIDDefaultTypeInternal _ExecutorID_default_instance_;
class ExecutorInfo;
class ExecutorInfoDefaultTypeInternal;
extern ExecutorInfoDefaultTypeInternal _ExecutorInfo_default_instance_;
class FileInfo;
class FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class Filters;
class FiltersDefaultTypeInternal;
extern FiltersDefaultTypeInternal _Filters_default_instance_;
class Flag;
class FlagDefaultTypeInternal;
extern FlagDefaultTypeInternal _Flag_default_instance_;
class FrameworkID;
class FrameworkIDDefaultTypeInternal;
extern FrameworkIDDefaultTypeInternal _FrameworkID_default_instance_;
class FrameworkInfo;
class FrameworkInfoDefaultTypeInternal;
extern FrameworkInfoDefaultTypeInternal _FrameworkInfo_default_instance_;
class FrameworkInfo_Capability;
class FrameworkInfo_CapabilityDefaultTypeInternal;
extern FrameworkInfo_CapabilityDefaultTypeInternal _FrameworkInfo_Capability_default_instance_;
class HealthCheck;
class HealthCheckDefaultTypeInternal;
extern HealthCheckDefaultTypeInternal _HealthCheck_default_instance_;
class HealthCheck_HTTPCheckInfo;
class HealthCheck_HTTPCheckInfoDefaultTypeInternal;
extern HealthCheck_HTTPCheckInfoDefaultTypeInternal _HealthCheck_HTTPCheckInfo_default_instance_;
class HealthCheck_TCPCheckInfo;
class HealthCheck_TCPCheckInfoDefaultTypeInternal;
extern HealthCheck_TCPCheckInfoDefaultTypeInternal _HealthCheck_TCPCheckInfo_default_instance_;
class IcmpStatistics;
class IcmpStatisticsDefaultTypeInternal;
extern IcmpStatisticsDefaultTypeInternal _IcmpStatistics_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Image_Appc;
class Image_AppcDefaultTypeInternal;
extern Image_AppcDefaultTypeInternal _Image_Appc_default_instance_;
class Image_Docker;
class Image_DockerDefaultTypeInternal;
extern Image_DockerDefaultTypeInternal _Image_Docker_default_instance_;
class InverseOffer;
class InverseOfferDefaultTypeInternal;
extern InverseOfferDefaultTypeInternal _InverseOffer_default_instance_;
class IpStatistics;
class IpStatisticsDefaultTypeInternal;
extern IpStatisticsDefaultTypeInternal _IpStatistics_default_instance_;
class KillPolicy;
class KillPolicyDefaultTypeInternal;
extern KillPolicyDefaultTypeInternal _KillPolicy_default_instance_;
class Label;
class LabelDefaultTypeInternal;
extern LabelDefaultTypeInternal _Label_default_instance_;
class Labels;
class LabelsDefaultTypeInternal;
extern LabelsDefaultTypeInternal _Labels_default_instance_;
class LinuxInfo;
class LinuxInfoDefaultTypeInternal;
extern LinuxInfoDefaultTypeInternal _LinuxInfo_default_instance_;
class MachineID;
class MachineIDDefaultTypeInternal;
extern MachineIDDefaultTypeInternal _MachineID_default_instance_;
class MachineInfo;
class MachineInfoDefaultTypeInternal;
extern MachineInfoDefaultTypeInternal _MachineInfo_default_instance_;
class MasterInfo;
class MasterInfoDefaultTypeInternal;
extern MasterInfoDefaultTypeInternal _MasterInfo_default_instance_;
class Metric;
class MetricDefaultTypeInternal;
extern MetricDefaultTypeInternal _Metric_default_instance_;
class NetworkInfo;
class NetworkInfoDefaultTypeInternal;
extern NetworkInfoDefaultTypeInternal _NetworkInfo_default_instance_;
class NetworkInfo_IPAddress;
class NetworkInfo_IPAddressDefaultTypeInternal;
extern NetworkInfo_IPAddressDefaultTypeInternal _NetworkInfo_IPAddress_default_instance_;
class NetworkInfo_PortMapping;
class NetworkInfo_PortMappingDefaultTypeInternal;
extern NetworkInfo_PortMappingDefaultTypeInternal _NetworkInfo_PortMapping_default_instance_;
class Offer;
class OfferDefaultTypeInternal;
extern OfferDefaultTypeInternal _Offer_default_instance_;
class OfferID;
class OfferIDDefaultTypeInternal;
extern OfferIDDefaultTypeInternal _OfferID_default_instance_;
class Offer_Operation;
class Offer_OperationDefaultTypeInternal;
extern Offer_OperationDefaultTypeInternal _Offer_Operation_default_instance_;
class Offer_Operation_Create;
class Offer_Operation_CreateDefaultTypeInternal;
extern Offer_Operation_CreateDefaultTypeInternal _Offer_Operation_Create_default_instance_;
class Offer_Operation_Destroy;
class Offer_Operation_DestroyDefaultTypeInternal;
extern Offer_Operation_DestroyDefaultTypeInternal _Offer_Operation_Destroy_default_instance_;
class Offer_Operation_Launch;
class Offer_Operation_LaunchDefaultTypeInternal;
extern Offer_Operation_LaunchDefaultTypeInternal _Offer_Operation_Launch_default_instance_;
class Offer_Operation_LaunchGroup;
class Offer_Operation_LaunchGroupDefaultTypeInternal;
extern Offer_Operation_LaunchGroupDefaultTypeInternal _Offer_Operation_LaunchGroup_default_instance_;
class Offer_Operation_Reserve;
class Offer_Operation_ReserveDefaultTypeInternal;
extern Offer_Operation_ReserveDefaultTypeInternal _Offer_Operation_Reserve_default_instance_;
class Offer_Operation_Unreserve;
class Offer_Operation_UnreserveDefaultTypeInternal;
extern Offer_Operation_UnreserveDefaultTypeInternal _Offer_Operation_Unreserve_default_instance_;
class Parameter;
class ParameterDefaultTypeInternal;
extern ParameterDefaultTypeInternal _Parameter_default_instance_;
class Parameters;
class ParametersDefaultTypeInternal;
extern ParametersDefaultTypeInternal _Parameters_default_instance_;
class PerfStatistics;
class PerfStatisticsDefaultTypeInternal;
extern PerfStatisticsDefaultTypeInternal _PerfStatistics_default_instance_;
class Port;
class PortDefaultTypeInternal;
extern PortDefaultTypeInternal _Port_default_instance_;
class Ports;
class PortsDefaultTypeInternal;
extern PortsDefaultTypeInternal _Ports_default_instance_;
class RLimitInfo;
class RLimitInfoDefaultTypeInternal;
extern RLimitInfoDefaultTypeInternal _RLimitInfo_default_instance_;
class RLimitInfo_RLimit;
class RLimitInfo_RLimitDefaultTypeInternal;
extern RLimitInfo_RLimitDefaultTypeInternal _RLimitInfo_RLimit_default_instance_;
class RateLimit;
class RateLimitDefaultTypeInternal;
extern RateLimitDefaultTypeInternal _RateLimit_default_instance_;
class RateLimits;
class RateLimitsDefaultTypeInternal;
extern RateLimitsDefaultTypeInternal _RateLimits_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Resource;
class ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class ResourceProviderID;
class ResourceProviderIDDefaultTypeInternal;
extern ResourceProviderIDDefaultTypeInternal _ResourceProviderID_default_instance_;
class ResourceProviderInfo;
class ResourceProviderInfoDefaultTypeInternal;
extern ResourceProviderInfoDefaultTypeInternal _ResourceProviderInfo_default_instance_;
class ResourceStatistics;
class ResourceStatisticsDefaultTypeInternal;
extern ResourceStatisticsDefaultTypeInternal _ResourceStatistics_default_instance_;
class ResourceUsage;
class ResourceUsageDefaultTypeInternal;
extern ResourceUsageDefaultTypeInternal _ResourceUsage_default_instance_;
class ResourceUsage_Executor;
class ResourceUsage_ExecutorDefaultTypeInternal;
extern ResourceUsage_ExecutorDefaultTypeInternal _ResourceUsage_Executor_default_instance_;
class ResourceUsage_Executor_Task;
class ResourceUsage_Executor_TaskDefaultTypeInternal;
extern ResourceUsage_Executor_TaskDefaultTypeInternal _ResourceUsage_Executor_Task_default_instance_;
class Resource_AllocationInfo;
class Resource_AllocationInfoDefaultTypeInternal;
extern Resource_AllocationInfoDefaultTypeInternal _Resource_AllocationInfo_default_instance_;
class Resource_DiskInfo;
class Resource_DiskInfoDefaultTypeInternal;
extern Resource_DiskInfoDefaultTypeInternal _Resource_DiskInfo_default_instance_;
class Resource_DiskInfo_Persistence;
class Resource_DiskInfo_PersistenceDefaultTypeInternal;
extern Resource_DiskInfo_PersistenceDefaultTypeInternal _Resource_DiskInfo_Persistence_default_instance_;
class Resource_DiskInfo_Source;
class Resource_DiskInfo_SourceDefaultTypeInternal;
extern Resource_DiskInfo_SourceDefaultTypeInternal _Resource_DiskInfo_Source_default_instance_;
class Resource_DiskInfo_Source_Mount;
class Resource_DiskInfo_Source_MountDefaultTypeInternal;
extern Resource_DiskInfo_Source_MountDefaultTypeInternal _Resource_DiskInfo_Source_Mount_default_instance_;
class Resource_DiskInfo_Source_Path;
class Resource_DiskInfo_Source_PathDefaultTypeInternal;
extern Resource_DiskInfo_Source_PathDefaultTypeInternal _Resource_DiskInfo_Source_Path_default_instance_;
class Resource_ReservationInfo;
class Resource_ReservationInfoDefaultTypeInternal;
extern Resource_ReservationInfoDefaultTypeInternal _Resource_ReservationInfo_default_instance_;
class Resource_RevocableInfo;
class Resource_RevocableInfoDefaultTypeInternal;
extern Resource_RevocableInfoDefaultTypeInternal _Resource_RevocableInfo_default_instance_;
class Resource_SharedInfo;
class Resource_SharedInfoDefaultTypeInternal;
extern Resource_SharedInfoDefaultTypeInternal _Resource_SharedInfo_default_instance_;
class Role;
class RoleDefaultTypeInternal;
extern RoleDefaultTypeInternal _Role_default_instance_;
class SNMPStatistics;
class SNMPStatisticsDefaultTypeInternal;
extern SNMPStatisticsDefaultTypeInternal _SNMPStatistics_default_instance_;
class Secret;
class SecretDefaultTypeInternal;
extern SecretDefaultTypeInternal _Secret_default_instance_;
class Secret_Reference;
class Secret_ReferenceDefaultTypeInternal;
extern Secret_ReferenceDefaultTypeInternal _Secret_Reference_default_instance_;
class Secret_Value;
class Secret_ValueDefaultTypeInternal;
extern Secret_ValueDefaultTypeInternal _Secret_Value_default_instance_;
class SlaveID;
class SlaveIDDefaultTypeInternal;
extern SlaveIDDefaultTypeInternal _SlaveID_default_instance_;
class SlaveInfo;
class SlaveInfoDefaultTypeInternal;
extern SlaveInfoDefaultTypeInternal _SlaveInfo_default_instance_;
class SlaveInfo_Capability;
class SlaveInfo_CapabilityDefaultTypeInternal;
extern SlaveInfo_CapabilityDefaultTypeInternal _SlaveInfo_Capability_default_instance_;
class TTYInfo;
class TTYInfoDefaultTypeInternal;
extern TTYInfoDefaultTypeInternal _TTYInfo_default_instance_;
class TTYInfo_WindowSize;
class TTYInfo_WindowSizeDefaultTypeInternal;
extern TTYInfo_WindowSizeDefaultTypeInternal _TTYInfo_WindowSize_default_instance_;
class Task;
class TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskGroupInfo;
class TaskGroupInfoDefaultTypeInternal;
extern TaskGroupInfoDefaultTypeInternal _TaskGroupInfo_default_instance_;
class TaskID;
class TaskIDDefaultTypeInternal;
extern TaskIDDefaultTypeInternal _TaskID_default_instance_;
class TaskInfo;
class TaskInfoDefaultTypeInternal;
extern TaskInfoDefaultTypeInternal _TaskInfo_default_instance_;
class TaskStatus;
class TaskStatusDefaultTypeInternal;
extern TaskStatusDefaultTypeInternal _TaskStatus_default_instance_;
class TcpStatistics;
class TcpStatisticsDefaultTypeInternal;
extern TcpStatisticsDefaultTypeInternal _TcpStatistics_default_instance_;
class TimeInfo;
class TimeInfoDefaultTypeInternal;
extern TimeInfoDefaultTypeInternal _TimeInfo_default_instance_;
class TrafficControlStatistics;
class TrafficControlStatisticsDefaultTypeInternal;
extern TrafficControlStatisticsDefaultTypeInternal _TrafficControlStatistics_default_instance_;
class URL;
class URLDefaultTypeInternal;
extern URLDefaultTypeInternal _URL_default_instance_;
class UdpStatistics;
class UdpStatisticsDefaultTypeInternal;
extern UdpStatisticsDefaultTypeInternal _UdpStatistics_default_instance_;
class Unavailability;
class UnavailabilityDefaultTypeInternal;
extern UnavailabilityDefaultTypeInternal _Unavailability_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class Value_Range;
class Value_RangeDefaultTypeInternal;
extern Value_RangeDefaultTypeInternal _Value_Range_default_instance_;
class Value_Ranges;
class Value_RangesDefaultTypeInternal;
extern Value_RangesDefaultTypeInternal _Value_Ranges_default_instance_;
class Value_Scalar;
class Value_ScalarDefaultTypeInternal;
extern Value_ScalarDefaultTypeInternal _Value_Scalar_default_instance_;
class Value_Set;
class Value_SetDefaultTypeInternal;
extern Value_SetDefaultTypeInternal _Value_Set_default_instance_;
class Value_Text;
class Value_TextDefaultTypeInternal;
extern Value_TextDefaultTypeInternal _Value_Text_default_instance_;
class VersionInfo;
class VersionInfoDefaultTypeInternal;
extern VersionInfoDefaultTypeInternal _VersionInfo_default_instance_;
class Volume;
class VolumeDefaultTypeInternal;
extern VolumeDefaultTypeInternal _Volume_default_instance_;
class Volume_Source;
class Volume_SourceDefaultTypeInternal;
extern Volume_SourceDefaultTypeInternal _Volume_Source_default_instance_;
class Volume_Source_DockerVolume;
class Volume_Source_DockerVolumeDefaultTypeInternal;
extern Volume_Source_DockerVolumeDefaultTypeInternal _Volume_Source_DockerVolume_default_instance_;
class Volume_Source_SandboxPath;
class Volume_Source_SandboxPathDefaultTypeInternal;
extern Volume_Source_SandboxPathDefaultTypeInternal _Volume_Source_SandboxPath_default_instance_;
class WeightInfo;
class WeightInfoDefaultTypeInternal;
extern WeightInfoDefaultTypeInternal _WeightInfo_default_instance_;
}  // namespace mesos

namespace arangodb {

namespace protobuf_arangodb_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_arangodb_2eproto

enum TaskPlanState {
  TASK_STATE_NEW = 1,
  TASK_STATE_TRYING_TO_RESERVE = 2,
  TASK_STATE_TRYING_TO_PERSIST = 3,
  TASK_STATE_TRYING_TO_START = 4,
  TASK_STATE_TRYING_TO_RESTART = 5,
  TASK_STATE_RUNNING = 6,
  TASK_STATE_KILLED = 7,
  TASK_STATE_FAILED_OVER = 8,
  TASK_STATE_DEAD = 9,
  TASK_STATE_SHUTTING_DOWN = 10
};
bool TaskPlanState_IsValid(int value);
const TaskPlanState TaskPlanState_MIN = TASK_STATE_NEW;
const TaskPlanState TaskPlanState_MAX = TASK_STATE_SHUTTING_DOWN;
const int TaskPlanState_ARRAYSIZE = TaskPlanState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskPlanState_descriptor();
inline const ::std::string& TaskPlanState_Name(TaskPlanState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskPlanState_descriptor(), value);
}
inline bool TaskPlanState_Parse(
    const ::std::string& name, TaskPlanState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskPlanState>(
    TaskPlanState_descriptor(), name, value);
}
// ===================================================================

class Restart : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.Restart) */ {
 public:
  Restart();
  virtual ~Restart();

  Restart(const Restart& from);

  inline Restart& operator=(const Restart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Restart& default_instance();

  static inline const Restart* internal_default_instance() {
    return reinterpret_cast<const Restart*>(
               &_Restart_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Restart* other);

  // implements Message ----------------------------------------------

  inline Restart* New() const PROTOBUF_FINAL { return New(NULL); }

  Restart* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Restart& from);
  void MergeFrom(const Restart& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Restart* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.RestartBucket buckets = 1;
  int buckets_size() const;
  void clear_buckets();
  static const int kBucketsFieldNumber = 1;
  const ::arangodb::RestartBucket& buckets(int index) const;
  ::arangodb::RestartBucket* mutable_buckets(int index);
  ::arangodb::RestartBucket* add_buckets();
  ::google::protobuf::RepeatedPtrField< ::arangodb::RestartBucket >*
      mutable_buckets();
  const ::google::protobuf::RepeatedPtrField< ::arangodb::RestartBucket >&
      buckets() const;

  // required double timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:arangodb.Restart)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::arangodb::RestartBucket > buckets_;
  double timestamp_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RestartBucket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.RestartBucket) */ {
 public:
  RestartBucket();
  virtual ~RestartBucket();

  RestartBucket(const RestartBucket& from);

  inline RestartBucket& operator=(const RestartBucket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RestartBucket& default_instance();

  static inline const RestartBucket* internal_default_instance() {
    return reinterpret_cast<const RestartBucket*>(
               &_RestartBucket_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RestartBucket* other);

  // implements Message ----------------------------------------------

  inline RestartBucket* New() const PROTOBUF_FINAL { return New(NULL); }

  RestartBucket* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RestartBucket& from);
  void MergeFrom(const RestartBucket& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RestartBucket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.RestartTaskInfo restart_tasks = 1;
  int restart_tasks_size() const;
  void clear_restart_tasks();
  static const int kRestartTasksFieldNumber = 1;
  const ::arangodb::RestartTaskInfo& restart_tasks(int index) const;
  ::arangodb::RestartTaskInfo* mutable_restart_tasks(int index);
  ::arangodb::RestartTaskInfo* add_restart_tasks();
  ::google::protobuf::RepeatedPtrField< ::arangodb::RestartTaskInfo >*
      mutable_restart_tasks();
  const ::google::protobuf::RepeatedPtrField< ::arangodb::RestartTaskInfo >&
      restart_tasks() const;

  // @@protoc_insertion_point(class_scope:arangodb.RestartBucket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::arangodb::RestartTaskInfo > restart_tasks_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RestartTaskInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.RestartTaskInfo) */ {
 public:
  RestartTaskInfo();
  virtual ~RestartTaskInfo();

  RestartTaskInfo(const RestartTaskInfo& from);

  inline RestartTaskInfo& operator=(const RestartTaskInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RestartTaskInfo& default_instance();

  static inline const RestartTaskInfo* internal_default_instance() {
    return reinterpret_cast<const RestartTaskInfo*>(
               &_RestartTaskInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RestartTaskInfo* other);

  // implements Message ----------------------------------------------

  inline RestartTaskInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RestartTaskInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RestartTaskInfo& from);
  void MergeFrom(const RestartTaskInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RestartTaskInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string task_name = 2;
  bool has_task_name() const;
  void clear_task_name();
  static const int kTaskNameFieldNumber = 2;
  const ::std::string& task_name() const;
  void set_task_name(const ::std::string& value);
  #if LANG_CXX11
  void set_task_name(::std::string&& value);
  #endif
  void set_task_name(const char* value);
  void set_task_name(const char* value, size_t size);
  ::std::string* mutable_task_name();
  ::std::string* release_task_name();
  void set_allocated_task_name(::std::string* task_name);

  // required uint32 task_type = 1;
  bool has_task_type() const;
  void clear_task_type();
  static const int kTaskTypeFieldNumber = 1;
  ::google::protobuf::uint32 task_type() const;
  void set_task_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:arangodb.RestartTaskInfo)
 private:
  void set_has_task_type();
  void clear_has_task_type();
  void set_has_task_name();
  void clear_has_task_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_name_;
  ::google::protobuf::uint32 task_type_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Target : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.Target) */ {
 public:
  Target();
  virtual ~Target();

  Target(const Target& from);

  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Target& default_instance();

  static inline const Target* internal_default_instance() {
    return reinterpret_cast<const Target*>(
               &_Target_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Target* other);

  // implements Message ----------------------------------------------

  inline Target* New() const PROTOBUF_FINAL { return New(NULL); }

  Target* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Target& from);
  void MergeFrom(const Target& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Target* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource minimal_resources = 2;
  int minimal_resources_size() const;
  void clear_minimal_resources();
  static const int kMinimalResourcesFieldNumber = 2;
  const ::mesos::Resource& minimal_resources(int index) const;
  ::mesos::Resource* mutable_minimal_resources(int index);
  ::mesos::Resource* add_minimal_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_minimal_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      minimal_resources() const;

  // repeated .mesos.Resource additional_resources = 3;
  int additional_resources_size() const;
  void clear_additional_resources();
  static const int kAdditionalResourcesFieldNumber = 3;
  const ::mesos::Resource& additional_resources(int index) const;
  ::mesos::Resource* mutable_additional_resources(int index);
  ::mesos::Resource* add_additional_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_additional_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      additional_resources() const;

  // required uint32 instances = 1;
  bool has_instances() const;
  void clear_instances();
  static const int kInstancesFieldNumber = 1;
  ::google::protobuf::uint32 instances() const;
  void set_instances(::google::protobuf::uint32 value);

  // required uint32 number_ports = 4;
  bool has_number_ports() const;
  void clear_number_ports();
  static const int kNumberPortsFieldNumber = 4;
  ::google::protobuf::uint32 number_ports() const;
  void set_number_ports(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:arangodb.Target)
 private:
  void set_has_instances();
  void clear_has_instances();
  void set_has_number_ports();
  void clear_has_number_ports();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > minimal_resources_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > additional_resources_;
  ::google::protobuf::uint32 instances_;
  ::google::protobuf::uint32 number_ports_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Targets : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.Targets) */ {
 public:
  Targets();
  virtual ~Targets();

  Targets(const Targets& from);

  inline Targets& operator=(const Targets& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Targets& default_instance();

  static inline const Targets* internal_default_instance() {
    return reinterpret_cast<const Targets*>(
               &_Targets_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Targets* other);

  // implements Message ----------------------------------------------

  inline Targets* New() const PROTOBUF_FINAL { return New(NULL); }

  Targets* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Targets& from);
  void MergeFrom(const Targets& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Targets* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mode = 1;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  const ::std::string& mode() const;
  void set_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_mode(::std::string&& value);
  #endif
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  ::std::string* mutable_mode();
  ::std::string* release_mode();
  void set_allocated_mode(::std::string* mode);

  // required .arangodb.Target agents = 2;
  bool has_agents() const;
  void clear_agents();
  static const int kAgentsFieldNumber = 2;
  const ::arangodb::Target& agents() const;
  ::arangodb::Target* mutable_agents();
  ::arangodb::Target* release_agents();
  void set_allocated_agents(::arangodb::Target* agents);

  // required .arangodb.Target coordinators = 3;
  bool has_coordinators() const;
  void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 3;
  const ::arangodb::Target& coordinators() const;
  ::arangodb::Target* mutable_coordinators();
  ::arangodb::Target* release_coordinators();
  void set_allocated_coordinators(::arangodb::Target* coordinators);

  // required .arangodb.Target dbservers = 4;
  bool has_dbservers() const;
  void clear_dbservers();
  static const int kDbserversFieldNumber = 4;
  const ::arangodb::Target& dbservers() const;
  ::arangodb::Target* mutable_dbservers();
  ::arangodb::Target* release_dbservers();
  void set_allocated_dbservers(::arangodb::Target* dbservers);

  // required .arangodb.Target secondaries = 5;
  bool has_secondaries() const;
  void clear_secondaries();
  static const int kSecondariesFieldNumber = 5;
  const ::arangodb::Target& secondaries() const;
  ::arangodb::Target* mutable_secondaries();
  ::arangodb::Target* release_secondaries();
  void set_allocated_secondaries(::arangodb::Target* secondaries);

  // optional bool asynchronous_replication = 6;
  bool has_asynchronous_replication() const;
  void clear_asynchronous_replication();
  static const int kAsynchronousReplicationFieldNumber = 6;
  bool asynchronous_replication() const;
  void set_asynchronous_replication(bool value);

  // @@protoc_insertion_point(class_scope:arangodb.Targets)
 private:
  void set_has_mode();
  void clear_has_mode();
  void set_has_agents();
  void clear_has_agents();
  void set_has_coordinators();
  void clear_has_coordinators();
  void set_has_dbservers();
  void clear_has_dbservers();
  void set_has_secondaries();
  void clear_has_secondaries();
  void set_has_asynchronous_replication();
  void clear_has_asynchronous_replication();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr mode_;
  ::arangodb::Target* agents_;
  ::arangodb::Target* coordinators_;
  ::arangodb::Target* dbservers_;
  ::arangodb::Target* secondaries_;
  bool asynchronous_replication_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskPlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.TaskPlan) */ {
 public:
  TaskPlan();
  virtual ~TaskPlan();

  TaskPlan(const TaskPlan& from);

  inline TaskPlan& operator=(const TaskPlan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskPlan& default_instance();

  static inline const TaskPlan* internal_default_instance() {
    return reinterpret_cast<const TaskPlan*>(
               &_TaskPlan_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TaskPlan* other);

  // implements Message ----------------------------------------------

  inline TaskPlan* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskPlan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskPlan& from);
  void MergeFrom(const TaskPlan& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskPlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string persistence_id = 2;
  bool has_persistence_id() const;
  void clear_persistence_id();
  static const int kPersistenceIdFieldNumber = 2;
  const ::std::string& persistence_id() const;
  void set_persistence_id(const ::std::string& value);
  #if LANG_CXX11
  void set_persistence_id(::std::string&& value);
  #endif
  void set_persistence_id(const char* value);
  void set_persistence_id(const char* value, size_t size);
  ::std::string* mutable_persistence_id();
  ::std::string* release_persistence_id();
  void set_allocated_persistence_id(::std::string* persistence_id);

  // required string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string sync_partner = 5;
  bool has_sync_partner() const;
  void clear_sync_partner();
  static const int kSyncPartnerFieldNumber = 5;
  const ::std::string& sync_partner() const;
  void set_sync_partner(const ::std::string& value);
  #if LANG_CXX11
  void set_sync_partner(::std::string&& value);
  #endif
  void set_sync_partner(const char* value);
  void set_sync_partner(const char* value, size_t size);
  ::std::string* mutable_sync_partner();
  ::std::string* release_sync_partner();
  void set_allocated_sync_partner(::std::string* sync_partner);

  // optional string server_id = 6;
  bool has_server_id() const;
  void clear_server_id();
  static const int kServerIdFieldNumber = 6;
  const ::std::string& server_id() const;
  void set_server_id(const ::std::string& value);
  #if LANG_CXX11
  void set_server_id(::std::string&& value);
  #endif
  void set_server_id(const char* value);
  void set_server_id(const char* value, size_t size);
  ::std::string* mutable_server_id();
  ::std::string* release_server_id();
  void set_allocated_server_id(::std::string* server_id);

  // optional double timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  double timestamp() const;
  void set_timestamp(double value);

  // required .arangodb.TaskPlanState state = 1 [default = TASK_STATE_NEW];
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::arangodb::TaskPlanState state() const;
  void set_state(::arangodb::TaskPlanState value);

  // @@protoc_insertion_point(class_scope:arangodb.TaskPlan)
 private:
  void set_has_state();
  void clear_has_state();
  void set_has_persistence_id();
  void clear_has_persistence_id();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_name();
  void clear_has_name();
  void set_has_sync_partner();
  void clear_has_sync_partner();
  void set_has_server_id();
  void clear_has_server_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr persistence_id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr sync_partner_;
  ::google::protobuf::internal::ArenaStringPtr server_id_;
  double timestamp_;
  int state_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TasksPlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.TasksPlan) */ {
 public:
  TasksPlan();
  virtual ~TasksPlan();

  TasksPlan(const TasksPlan& from);

  inline TasksPlan& operator=(const TasksPlan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TasksPlan& default_instance();

  static inline const TasksPlan* internal_default_instance() {
    return reinterpret_cast<const TasksPlan*>(
               &_TasksPlan_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TasksPlan* other);

  // implements Message ----------------------------------------------

  inline TasksPlan* New() const PROTOBUF_FINAL { return New(NULL); }

  TasksPlan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TasksPlan& from);
  void MergeFrom(const TasksPlan& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TasksPlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.TaskPlan entries = 1;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 1;
  const ::arangodb::TaskPlan& entries(int index) const;
  ::arangodb::TaskPlan* mutable_entries(int index);
  ::arangodb::TaskPlan* add_entries();
  ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >*
      mutable_entries();
  const ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >&
      entries() const;

  // @@protoc_insertion_point(class_scope:arangodb.TasksPlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan > entries_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Plan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.Plan) */ {
 public:
  Plan();
  virtual ~Plan();

  Plan(const Plan& from);

  inline Plan& operator=(const Plan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Plan& default_instance();

  static inline const Plan* internal_default_instance() {
    return reinterpret_cast<const Plan*>(
               &_Plan_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Plan* other);

  // implements Message ----------------------------------------------

  inline Plan* New() const PROTOBUF_FINAL { return New(NULL); }

  Plan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Plan& from);
  void MergeFrom(const Plan& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Plan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .arangodb.TasksPlan agents = 1;
  bool has_agents() const;
  void clear_agents();
  static const int kAgentsFieldNumber = 1;
  const ::arangodb::TasksPlan& agents() const;
  ::arangodb::TasksPlan* mutable_agents();
  ::arangodb::TasksPlan* release_agents();
  void set_allocated_agents(::arangodb::TasksPlan* agents);

  // required .arangodb.TasksPlan coordinators = 2;
  bool has_coordinators() const;
  void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 2;
  const ::arangodb::TasksPlan& coordinators() const;
  ::arangodb::TasksPlan* mutable_coordinators();
  ::arangodb::TasksPlan* release_coordinators();
  void set_allocated_coordinators(::arangodb::TasksPlan* coordinators);

  // required .arangodb.TasksPlan dbservers = 3;
  bool has_dbservers() const;
  void clear_dbservers();
  static const int kDbserversFieldNumber = 3;
  const ::arangodb::TasksPlan& dbservers() const;
  ::arangodb::TasksPlan* mutable_dbservers();
  ::arangodb::TasksPlan* release_dbservers();
  void set_allocated_dbservers(::arangodb::TasksPlan* dbservers);

  // required .arangodb.TasksPlan secondaries = 4;
  bool has_secondaries() const;
  void clear_secondaries();
  static const int kSecondariesFieldNumber = 4;
  const ::arangodb::TasksPlan& secondaries() const;
  ::arangodb::TasksPlan* mutable_secondaries();
  ::arangodb::TasksPlan* release_secondaries();
  void set_allocated_secondaries(::arangodb::TasksPlan* secondaries);

  // @@protoc_insertion_point(class_scope:arangodb.Plan)
 private:
  void set_has_agents();
  void clear_has_agents();
  void set_has_coordinators();
  void clear_has_coordinators();
  void set_has_dbservers();
  void clear_has_dbservers();
  void set_has_secondaries();
  void clear_has_secondaries();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::arangodb::TasksPlan* agents_;
  ::arangodb::TasksPlan* coordinators_;
  ::arangodb::TasksPlan* dbservers_;
  ::arangodb::TasksPlan* secondaries_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskCurrent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.TaskCurrent) */ {
 public:
  TaskCurrent();
  virtual ~TaskCurrent();

  TaskCurrent(const TaskCurrent& from);

  inline TaskCurrent& operator=(const TaskCurrent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskCurrent& default_instance();

  static inline const TaskCurrent* internal_default_instance() {
    return reinterpret_cast<const TaskCurrent*>(
               &_TaskCurrent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(TaskCurrent* other);

  // implements Message ----------------------------------------------

  inline TaskCurrent* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskCurrent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskCurrent& from);
  void MergeFrom(const TaskCurrent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskCurrent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mesos.Resource resources = 3;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 3;
  const ::mesos::Resource& resources(int index) const;
  ::mesos::Resource* mutable_resources(int index);
  ::mesos::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;

  // repeated uint32 ports = 4;
  int ports_size() const;
  void clear_ports();
  static const int kPortsFieldNumber = 4;
  ::google::protobuf::uint32 ports(int index) const;
  void set_ports(int index, ::google::protobuf::uint32 value);
  void add_ports(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ports() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ports();

  // optional string hostname = 5;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 5;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // optional string container_path = 6;
  bool has_container_path() const;
  void clear_container_path();
  static const int kContainerPathFieldNumber = 6;
  const ::std::string& container_path() const;
  void set_container_path(const ::std::string& value);
  #if LANG_CXX11
  void set_container_path(::std::string&& value);
  #endif
  void set_container_path(const char* value);
  void set_container_path(const char* value, size_t size);
  ::std::string* mutable_container_path();
  ::std::string* release_container_path();
  void set_allocated_container_path(::std::string* container_path);

  // optional .mesos.SlaveID slave_id = 1;
  bool has_slave_id() const;
  void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  const ::mesos::SlaveID& slave_id() const;
  ::mesos::SlaveID* mutable_slave_id();
  ::mesos::SlaveID* release_slave_id();
  void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional .mesos.OfferID offer_id = 2;
  bool has_offer_id() const;
  void clear_offer_id();
  static const int kOfferIdFieldNumber = 2;
  const ::mesos::OfferID& offer_id() const;
  ::mesos::OfferID* mutable_offer_id();
  ::mesos::OfferID* release_offer_id();
  void set_allocated_offer_id(::mesos::OfferID* offer_id);

  // optional .mesos.TaskInfo task_info = 7;
  bool has_task_info() const;
  void clear_task_info();
  static const int kTaskInfoFieldNumber = 7;
  const ::mesos::TaskInfo& task_info() const;
  ::mesos::TaskInfo* mutable_task_info();
  ::mesos::TaskInfo* release_task_info();
  void set_allocated_task_info(::mesos::TaskInfo* task_info);

  // optional double start_time = 8;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 8;
  double start_time() const;
  void set_start_time(double value);

  // optional double kill_time = 9;
  bool has_kill_time() const;
  void clear_kill_time();
  static const int kKillTimeFieldNumber = 9;
  double kill_time() const;
  void set_kill_time(double value);

  // @@protoc_insertion_point(class_scope:arangodb.TaskCurrent)
 private:
  void set_has_slave_id();
  void clear_has_slave_id();
  void set_has_offer_id();
  void clear_has_offer_id();
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_container_path();
  void clear_has_container_path();
  void set_has_task_info();
  void clear_has_task_info();
  void set_has_start_time();
  void clear_has_start_time();
  void set_has_kill_time();
  void clear_has_kill_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ports_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr container_path_;
  ::mesos::SlaveID* slave_id_;
  ::mesos::OfferID* offer_id_;
  ::mesos::TaskInfo* task_info_;
  double start_time_;
  double kill_time_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TasksCurrent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.TasksCurrent) */ {
 public:
  TasksCurrent();
  virtual ~TasksCurrent();

  TasksCurrent(const TasksCurrent& from);

  inline TasksCurrent& operator=(const TasksCurrent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TasksCurrent& default_instance();

  static inline const TasksCurrent* internal_default_instance() {
    return reinterpret_cast<const TasksCurrent*>(
               &_TasksCurrent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(TasksCurrent* other);

  // implements Message ----------------------------------------------

  inline TasksCurrent* New() const PROTOBUF_FINAL { return New(NULL); }

  TasksCurrent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TasksCurrent& from);
  void MergeFrom(const TasksCurrent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TasksCurrent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.TaskCurrent entries = 1;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 1;
  const ::arangodb::TaskCurrent& entries(int index) const;
  ::arangodb::TaskCurrent* mutable_entries(int index);
  ::arangodb::TaskCurrent* add_entries();
  ::google::protobuf::RepeatedPtrField< ::arangodb::TaskCurrent >*
      mutable_entries();
  const ::google::protobuf::RepeatedPtrField< ::arangodb::TaskCurrent >&
      entries() const;

  // @@protoc_insertion_point(class_scope:arangodb.TasksCurrent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::arangodb::TaskCurrent > entries_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Current : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.Current) */ {
 public:
  Current();
  virtual ~Current();

  Current(const Current& from);

  inline Current& operator=(const Current& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Current& default_instance();

  static inline const Current* internal_default_instance() {
    return reinterpret_cast<const Current*>(
               &_Current_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Current* other);

  // implements Message ----------------------------------------------

  inline Current* New() const PROTOBUF_FINAL { return New(NULL); }

  Current* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Current& from);
  void MergeFrom(const Current& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Current* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .arangodb.TasksCurrent agents = 1;
  bool has_agents() const;
  void clear_agents();
  static const int kAgentsFieldNumber = 1;
  const ::arangodb::TasksCurrent& agents() const;
  ::arangodb::TasksCurrent* mutable_agents();
  ::arangodb::TasksCurrent* release_agents();
  void set_allocated_agents(::arangodb::TasksCurrent* agents);

  // required .arangodb.TasksCurrent coordinators = 2;
  bool has_coordinators() const;
  void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 2;
  const ::arangodb::TasksCurrent& coordinators() const;
  ::arangodb::TasksCurrent* mutable_coordinators();
  ::arangodb::TasksCurrent* release_coordinators();
  void set_allocated_coordinators(::arangodb::TasksCurrent* coordinators);

  // required .arangodb.TasksCurrent dbservers = 3;
  bool has_dbservers() const;
  void clear_dbservers();
  static const int kDbserversFieldNumber = 3;
  const ::arangodb::TasksCurrent& dbservers() const;
  ::arangodb::TasksCurrent* mutable_dbservers();
  ::arangodb::TasksCurrent* release_dbservers();
  void set_allocated_dbservers(::arangodb::TasksCurrent* dbservers);

  // required .arangodb.TasksCurrent secondaries = 4;
  bool has_secondaries() const;
  void clear_secondaries();
  static const int kSecondariesFieldNumber = 4;
  const ::arangodb::TasksCurrent& secondaries() const;
  ::arangodb::TasksCurrent* mutable_secondaries();
  ::arangodb::TasksCurrent* release_secondaries();
  void set_allocated_secondaries(::arangodb::TasksCurrent* secondaries);

  // required bool cluster_complete = 5;
  bool has_cluster_complete() const;
  void clear_cluster_complete();
  static const int kClusterCompleteFieldNumber = 5;
  bool cluster_complete() const;
  void set_cluster_complete(bool value);

  // @@protoc_insertion_point(class_scope:arangodb.Current)
 private:
  void set_has_agents();
  void clear_has_agents();
  void set_has_coordinators();
  void clear_has_coordinators();
  void set_has_dbservers();
  void clear_has_dbservers();
  void set_has_secondaries();
  void clear_has_secondaries();
  void set_has_cluster_complete();
  void clear_has_cluster_complete();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::arangodb::TasksCurrent* agents_;
  ::arangodb::TasksCurrent* coordinators_;
  ::arangodb::TasksCurrent* dbservers_;
  ::arangodb::TasksCurrent* secondaries_;
  bool cluster_complete_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arangodb.State) */ {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(State* other);

  // implements Message ----------------------------------------------

  inline State* New() const PROTOBUF_FINAL { return New(NULL); }

  State* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(State* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.FrameworkID framework_id = 1;
  bool has_framework_id() const;
  void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  const ::mesos::FrameworkID& framework_id() const;
  ::mesos::FrameworkID* mutable_framework_id();
  ::mesos::FrameworkID* release_framework_id();
  void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .arangodb.Targets targets = 2;
  bool has_targets() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 2;
  const ::arangodb::Targets& targets() const;
  ::arangodb::Targets* mutable_targets();
  ::arangodb::Targets* release_targets();
  void set_allocated_targets(::arangodb::Targets* targets);

  // required .arangodb.Plan plan = 3;
  bool has_plan() const;
  void clear_plan();
  static const int kPlanFieldNumber = 3;
  const ::arangodb::Plan& plan() const;
  ::arangodb::Plan* mutable_plan();
  ::arangodb::Plan* release_plan();
  void set_allocated_plan(::arangodb::Plan* plan);

  // required .arangodb.Current current = 4;
  bool has_current() const;
  void clear_current();
  static const int kCurrentFieldNumber = 4;
  const ::arangodb::Current& current() const;
  ::arangodb::Current* mutable_current();
  ::arangodb::Current* release_current();
  void set_allocated_current(::arangodb::Current* current);

  // optional .arangodb.Restart restart = 5;
  bool has_restart() const;
  void clear_restart();
  static const int kRestartFieldNumber = 5;
  const ::arangodb::Restart& restart() const;
  ::arangodb::Restart* mutable_restart();
  ::arangodb::Restart* release_restart();
  void set_allocated_restart(::arangodb::Restart* restart);

  // @@protoc_insertion_point(class_scope:arangodb.State)
 private:
  void set_has_framework_id();
  void clear_has_framework_id();
  void set_has_targets();
  void clear_has_targets();
  void set_has_plan();
  void clear_has_plan();
  void set_has_current();
  void clear_has_current();
  void set_has_restart();
  void clear_has_restart();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mesos::FrameworkID* framework_id_;
  ::arangodb::Targets* targets_;
  ::arangodb::Plan* plan_;
  ::arangodb::Current* current_;
  ::arangodb::Restart* restart_;
  friend struct protobuf_arangodb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Restart

// repeated .arangodb.RestartBucket buckets = 1;
inline int Restart::buckets_size() const {
  return buckets_.size();
}
inline void Restart::clear_buckets() {
  buckets_.Clear();
}
inline const ::arangodb::RestartBucket& Restart::buckets(int index) const {
  // @@protoc_insertion_point(field_get:arangodb.Restart.buckets)
  return buckets_.Get(index);
}
inline ::arangodb::RestartBucket* Restart::mutable_buckets(int index) {
  // @@protoc_insertion_point(field_mutable:arangodb.Restart.buckets)
  return buckets_.Mutable(index);
}
inline ::arangodb::RestartBucket* Restart::add_buckets() {
  // @@protoc_insertion_point(field_add:arangodb.Restart.buckets)
  return buckets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::RestartBucket >*
Restart::mutable_buckets() {
  // @@protoc_insertion_point(field_mutable_list:arangodb.Restart.buckets)
  return &buckets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::RestartBucket >&
Restart::buckets() const {
  // @@protoc_insertion_point(field_list:arangodb.Restart.buckets)
  return buckets_;
}

// required double timestamp = 2;
inline bool Restart::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Restart::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Restart::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Restart::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double Restart::timestamp() const {
  // @@protoc_insertion_point(field_get:arangodb.Restart.timestamp)
  return timestamp_;
}
inline void Restart::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:arangodb.Restart.timestamp)
}

// -------------------------------------------------------------------

// RestartBucket

// repeated .arangodb.RestartTaskInfo restart_tasks = 1;
inline int RestartBucket::restart_tasks_size() const {
  return restart_tasks_.size();
}
inline void RestartBucket::clear_restart_tasks() {
  restart_tasks_.Clear();
}
inline const ::arangodb::RestartTaskInfo& RestartBucket::restart_tasks(int index) const {
  // @@protoc_insertion_point(field_get:arangodb.RestartBucket.restart_tasks)
  return restart_tasks_.Get(index);
}
inline ::arangodb::RestartTaskInfo* RestartBucket::mutable_restart_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:arangodb.RestartBucket.restart_tasks)
  return restart_tasks_.Mutable(index);
}
inline ::arangodb::RestartTaskInfo* RestartBucket::add_restart_tasks() {
  // @@protoc_insertion_point(field_add:arangodb.RestartBucket.restart_tasks)
  return restart_tasks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::RestartTaskInfo >*
RestartBucket::mutable_restart_tasks() {
  // @@protoc_insertion_point(field_mutable_list:arangodb.RestartBucket.restart_tasks)
  return &restart_tasks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::RestartTaskInfo >&
RestartBucket::restart_tasks() const {
  // @@protoc_insertion_point(field_list:arangodb.RestartBucket.restart_tasks)
  return restart_tasks_;
}

// -------------------------------------------------------------------

// RestartTaskInfo

// required uint32 task_type = 1;
inline bool RestartTaskInfo::has_task_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RestartTaskInfo::set_has_task_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RestartTaskInfo::clear_has_task_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RestartTaskInfo::clear_task_type() {
  task_type_ = 0u;
  clear_has_task_type();
}
inline ::google::protobuf::uint32 RestartTaskInfo::task_type() const {
  // @@protoc_insertion_point(field_get:arangodb.RestartTaskInfo.task_type)
  return task_type_;
}
inline void RestartTaskInfo::set_task_type(::google::protobuf::uint32 value) {
  set_has_task_type();
  task_type_ = value;
  // @@protoc_insertion_point(field_set:arangodb.RestartTaskInfo.task_type)
}

// required string task_name = 2;
inline bool RestartTaskInfo::has_task_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RestartTaskInfo::set_has_task_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RestartTaskInfo::clear_has_task_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RestartTaskInfo::clear_task_name() {
  task_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_name();
}
inline const ::std::string& RestartTaskInfo::task_name() const {
  // @@protoc_insertion_point(field_get:arangodb.RestartTaskInfo.task_name)
  return task_name_.GetNoArena();
}
inline void RestartTaskInfo::set_task_name(const ::std::string& value) {
  set_has_task_name();
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arangodb.RestartTaskInfo.task_name)
}
#if LANG_CXX11
inline void RestartTaskInfo::set_task_name(::std::string&& value) {
  set_has_task_name();
  task_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arangodb.RestartTaskInfo.task_name)
}
#endif
inline void RestartTaskInfo::set_task_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_task_name();
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arangodb.RestartTaskInfo.task_name)
}
inline void RestartTaskInfo::set_task_name(const char* value, size_t size) {
  set_has_task_name();
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arangodb.RestartTaskInfo.task_name)
}
inline ::std::string* RestartTaskInfo::mutable_task_name() {
  set_has_task_name();
  // @@protoc_insertion_point(field_mutable:arangodb.RestartTaskInfo.task_name)
  return task_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RestartTaskInfo::release_task_name() {
  // @@protoc_insertion_point(field_release:arangodb.RestartTaskInfo.task_name)
  clear_has_task_name();
  return task_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RestartTaskInfo::set_allocated_task_name(::std::string* task_name) {
  if (task_name != NULL) {
    set_has_task_name();
  } else {
    clear_has_task_name();
  }
  task_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_name);
  // @@protoc_insertion_point(field_set_allocated:arangodb.RestartTaskInfo.task_name)
}

// -------------------------------------------------------------------

// Target

// required uint32 instances = 1;
inline bool Target::has_instances() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Target::set_has_instances() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Target::clear_has_instances() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Target::clear_instances() {
  instances_ = 0u;
  clear_has_instances();
}
inline ::google::protobuf::uint32 Target::instances() const {
  // @@protoc_insertion_point(field_get:arangodb.Target.instances)
  return instances_;
}
inline void Target::set_instances(::google::protobuf::uint32 value) {
  set_has_instances();
  instances_ = value;
  // @@protoc_insertion_point(field_set:arangodb.Target.instances)
}

// repeated .mesos.Resource minimal_resources = 2;
inline int Target::minimal_resources_size() const {
  return minimal_resources_.size();
}
inline void Target::clear_minimal_resources() {
  minimal_resources_.Clear();
}
inline const ::mesos::Resource& Target::minimal_resources(int index) const {
  // @@protoc_insertion_point(field_get:arangodb.Target.minimal_resources)
  return minimal_resources_.Get(index);
}
inline ::mesos::Resource* Target::mutable_minimal_resources(int index) {
  // @@protoc_insertion_point(field_mutable:arangodb.Target.minimal_resources)
  return minimal_resources_.Mutable(index);
}
inline ::mesos::Resource* Target::add_minimal_resources() {
  // @@protoc_insertion_point(field_add:arangodb.Target.minimal_resources)
  return minimal_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Target::mutable_minimal_resources() {
  // @@protoc_insertion_point(field_mutable_list:arangodb.Target.minimal_resources)
  return &minimal_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Target::minimal_resources() const {
  // @@protoc_insertion_point(field_list:arangodb.Target.minimal_resources)
  return minimal_resources_;
}

// repeated .mesos.Resource additional_resources = 3;
inline int Target::additional_resources_size() const {
  return additional_resources_.size();
}
inline void Target::clear_additional_resources() {
  additional_resources_.Clear();
}
inline const ::mesos::Resource& Target::additional_resources(int index) const {
  // @@protoc_insertion_point(field_get:arangodb.Target.additional_resources)
  return additional_resources_.Get(index);
}
inline ::mesos::Resource* Target::mutable_additional_resources(int index) {
  // @@protoc_insertion_point(field_mutable:arangodb.Target.additional_resources)
  return additional_resources_.Mutable(index);
}
inline ::mesos::Resource* Target::add_additional_resources() {
  // @@protoc_insertion_point(field_add:arangodb.Target.additional_resources)
  return additional_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Target::mutable_additional_resources() {
  // @@protoc_insertion_point(field_mutable_list:arangodb.Target.additional_resources)
  return &additional_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Target::additional_resources() const {
  // @@protoc_insertion_point(field_list:arangodb.Target.additional_resources)
  return additional_resources_;
}

// required uint32 number_ports = 4;
inline bool Target::has_number_ports() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Target::set_has_number_ports() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Target::clear_has_number_ports() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Target::clear_number_ports() {
  number_ports_ = 0u;
  clear_has_number_ports();
}
inline ::google::protobuf::uint32 Target::number_ports() const {
  // @@protoc_insertion_point(field_get:arangodb.Target.number_ports)
  return number_ports_;
}
inline void Target::set_number_ports(::google::protobuf::uint32 value) {
  set_has_number_ports();
  number_ports_ = value;
  // @@protoc_insertion_point(field_set:arangodb.Target.number_ports)
}

// -------------------------------------------------------------------

// Targets

// required string mode = 1;
inline bool Targets::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Targets::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Targets::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Targets::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mode();
}
inline const ::std::string& Targets::mode() const {
  // @@protoc_insertion_point(field_get:arangodb.Targets.mode)
  return mode_.GetNoArena();
}
inline void Targets::set_mode(const ::std::string& value) {
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arangodb.Targets.mode)
}
#if LANG_CXX11
inline void Targets::set_mode(::std::string&& value) {
  set_has_mode();
  mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arangodb.Targets.mode)
}
#endif
inline void Targets::set_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arangodb.Targets.mode)
}
inline void Targets::set_mode(const char* value, size_t size) {
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arangodb.Targets.mode)
}
inline ::std::string* Targets::mutable_mode() {
  set_has_mode();
  // @@protoc_insertion_point(field_mutable:arangodb.Targets.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Targets::release_mode() {
  // @@protoc_insertion_point(field_release:arangodb.Targets.mode)
  clear_has_mode();
  return mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Targets::set_allocated_mode(::std::string* mode) {
  if (mode != NULL) {
    set_has_mode();
  } else {
    clear_has_mode();
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:arangodb.Targets.mode)
}

// required .arangodb.Target agents = 2;
inline bool Targets::has_agents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Targets::set_has_agents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Targets::clear_has_agents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Targets::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::Target::Clear();
  clear_has_agents();
}
inline const ::arangodb::Target& Targets::agents() const {
  // @@protoc_insertion_point(field_get:arangodb.Targets.agents)
  return agents_ != NULL ? *agents_
                         : *::arangodb::Target::internal_default_instance();
}
inline ::arangodb::Target* Targets::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) {
    agents_ = new ::arangodb::Target;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Targets.agents)
  return agents_;
}
inline ::arangodb::Target* Targets::release_agents() {
  // @@protoc_insertion_point(field_release:arangodb.Targets.agents)
  clear_has_agents();
  ::arangodb::Target* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Targets::set_allocated_agents(::arangodb::Target* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Targets.agents)
}

// required .arangodb.Target coordinators = 3;
inline bool Targets::has_coordinators() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Targets::set_has_coordinators() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Targets::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Targets::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::Target::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::Target& Targets::coordinators() const {
  // @@protoc_insertion_point(field_get:arangodb.Targets.coordinators)
  return coordinators_ != NULL ? *coordinators_
                         : *::arangodb::Target::internal_default_instance();
}
inline ::arangodb::Target* Targets::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) {
    coordinators_ = new ::arangodb::Target;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Targets.coordinators)
  return coordinators_;
}
inline ::arangodb::Target* Targets::release_coordinators() {
  // @@protoc_insertion_point(field_release:arangodb.Targets.coordinators)
  clear_has_coordinators();
  ::arangodb::Target* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Targets::set_allocated_coordinators(::arangodb::Target* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Targets.coordinators)
}

// required .arangodb.Target dbservers = 4;
inline bool Targets::has_dbservers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Targets::set_has_dbservers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Targets::clear_has_dbservers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Targets::clear_dbservers() {
  if (dbservers_ != NULL) dbservers_->::arangodb::Target::Clear();
  clear_has_dbservers();
}
inline const ::arangodb::Target& Targets::dbservers() const {
  // @@protoc_insertion_point(field_get:arangodb.Targets.dbservers)
  return dbservers_ != NULL ? *dbservers_
                         : *::arangodb::Target::internal_default_instance();
}
inline ::arangodb::Target* Targets::mutable_dbservers() {
  set_has_dbservers();
  if (dbservers_ == NULL) {
    dbservers_ = new ::arangodb::Target;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Targets.dbservers)
  return dbservers_;
}
inline ::arangodb::Target* Targets::release_dbservers() {
  // @@protoc_insertion_point(field_release:arangodb.Targets.dbservers)
  clear_has_dbservers();
  ::arangodb::Target* temp = dbservers_;
  dbservers_ = NULL;
  return temp;
}
inline void Targets::set_allocated_dbservers(::arangodb::Target* dbservers) {
  delete dbservers_;
  dbservers_ = dbservers;
  if (dbservers) {
    set_has_dbservers();
  } else {
    clear_has_dbservers();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Targets.dbservers)
}

// required .arangodb.Target secondaries = 5;
inline bool Targets::has_secondaries() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Targets::set_has_secondaries() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Targets::clear_has_secondaries() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Targets::clear_secondaries() {
  if (secondaries_ != NULL) secondaries_->::arangodb::Target::Clear();
  clear_has_secondaries();
}
inline const ::arangodb::Target& Targets::secondaries() const {
  // @@protoc_insertion_point(field_get:arangodb.Targets.secondaries)
  return secondaries_ != NULL ? *secondaries_
                         : *::arangodb::Target::internal_default_instance();
}
inline ::arangodb::Target* Targets::mutable_secondaries() {
  set_has_secondaries();
  if (secondaries_ == NULL) {
    secondaries_ = new ::arangodb::Target;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Targets.secondaries)
  return secondaries_;
}
inline ::arangodb::Target* Targets::release_secondaries() {
  // @@protoc_insertion_point(field_release:arangodb.Targets.secondaries)
  clear_has_secondaries();
  ::arangodb::Target* temp = secondaries_;
  secondaries_ = NULL;
  return temp;
}
inline void Targets::set_allocated_secondaries(::arangodb::Target* secondaries) {
  delete secondaries_;
  secondaries_ = secondaries;
  if (secondaries) {
    set_has_secondaries();
  } else {
    clear_has_secondaries();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Targets.secondaries)
}

// optional bool asynchronous_replication = 6;
inline bool Targets::has_asynchronous_replication() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Targets::set_has_asynchronous_replication() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Targets::clear_has_asynchronous_replication() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Targets::clear_asynchronous_replication() {
  asynchronous_replication_ = false;
  clear_has_asynchronous_replication();
}
inline bool Targets::asynchronous_replication() const {
  // @@protoc_insertion_point(field_get:arangodb.Targets.asynchronous_replication)
  return asynchronous_replication_;
}
inline void Targets::set_asynchronous_replication(bool value) {
  set_has_asynchronous_replication();
  asynchronous_replication_ = value;
  // @@protoc_insertion_point(field_set:arangodb.Targets.asynchronous_replication)
}

// -------------------------------------------------------------------

// TaskPlan

// required .arangodb.TaskPlanState state = 1 [default = TASK_STATE_NEW];
inline bool TaskPlan::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskPlan::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskPlan::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskPlan::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::arangodb::TaskPlanState TaskPlan::state() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskPlan.state)
  return static_cast< ::arangodb::TaskPlanState >(state_);
}
inline void TaskPlan::set_state(::arangodb::TaskPlanState value) {
  assert(::arangodb::TaskPlanState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:arangodb.TaskPlan.state)
}

// optional string persistence_id = 2;
inline bool TaskPlan::has_persistence_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskPlan::set_has_persistence_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskPlan::clear_has_persistence_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskPlan::clear_persistence_id() {
  persistence_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_persistence_id();
}
inline const ::std::string& TaskPlan::persistence_id() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskPlan.persistence_id)
  return persistence_id_.GetNoArena();
}
inline void TaskPlan::set_persistence_id(const ::std::string& value) {
  set_has_persistence_id();
  persistence_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arangodb.TaskPlan.persistence_id)
}
#if LANG_CXX11
inline void TaskPlan::set_persistence_id(::std::string&& value) {
  set_has_persistence_id();
  persistence_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arangodb.TaskPlan.persistence_id)
}
#endif
inline void TaskPlan::set_persistence_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_persistence_id();
  persistence_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arangodb.TaskPlan.persistence_id)
}
inline void TaskPlan::set_persistence_id(const char* value, size_t size) {
  set_has_persistence_id();
  persistence_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arangodb.TaskPlan.persistence_id)
}
inline ::std::string* TaskPlan::mutable_persistence_id() {
  set_has_persistence_id();
  // @@protoc_insertion_point(field_mutable:arangodb.TaskPlan.persistence_id)
  return persistence_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskPlan::release_persistence_id() {
  // @@protoc_insertion_point(field_release:arangodb.TaskPlan.persistence_id)
  clear_has_persistence_id();
  return persistence_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskPlan::set_allocated_persistence_id(::std::string* persistence_id) {
  if (persistence_id != NULL) {
    set_has_persistence_id();
  } else {
    clear_has_persistence_id();
  }
  persistence_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), persistence_id);
  // @@protoc_insertion_point(field_set_allocated:arangodb.TaskPlan.persistence_id)
}

// optional double timestamp = 3;
inline bool TaskPlan::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskPlan::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskPlan::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskPlan::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double TaskPlan::timestamp() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskPlan.timestamp)
  return timestamp_;
}
inline void TaskPlan::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:arangodb.TaskPlan.timestamp)
}

// required string name = 4;
inline bool TaskPlan::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskPlan::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskPlan::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskPlan::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TaskPlan::name() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskPlan.name)
  return name_.GetNoArena();
}
inline void TaskPlan::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arangodb.TaskPlan.name)
}
#if LANG_CXX11
inline void TaskPlan::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arangodb.TaskPlan.name)
}
#endif
inline void TaskPlan::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arangodb.TaskPlan.name)
}
inline void TaskPlan::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arangodb.TaskPlan.name)
}
inline ::std::string* TaskPlan::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:arangodb.TaskPlan.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskPlan::release_name() {
  // @@protoc_insertion_point(field_release:arangodb.TaskPlan.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskPlan::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:arangodb.TaskPlan.name)
}

// optional string sync_partner = 5;
inline bool TaskPlan::has_sync_partner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskPlan::set_has_sync_partner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskPlan::clear_has_sync_partner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskPlan::clear_sync_partner() {
  sync_partner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sync_partner();
}
inline const ::std::string& TaskPlan::sync_partner() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskPlan.sync_partner)
  return sync_partner_.GetNoArena();
}
inline void TaskPlan::set_sync_partner(const ::std::string& value) {
  set_has_sync_partner();
  sync_partner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arangodb.TaskPlan.sync_partner)
}
#if LANG_CXX11
inline void TaskPlan::set_sync_partner(::std::string&& value) {
  set_has_sync_partner();
  sync_partner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arangodb.TaskPlan.sync_partner)
}
#endif
inline void TaskPlan::set_sync_partner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sync_partner();
  sync_partner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arangodb.TaskPlan.sync_partner)
}
inline void TaskPlan::set_sync_partner(const char* value, size_t size) {
  set_has_sync_partner();
  sync_partner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arangodb.TaskPlan.sync_partner)
}
inline ::std::string* TaskPlan::mutable_sync_partner() {
  set_has_sync_partner();
  // @@protoc_insertion_point(field_mutable:arangodb.TaskPlan.sync_partner)
  return sync_partner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskPlan::release_sync_partner() {
  // @@protoc_insertion_point(field_release:arangodb.TaskPlan.sync_partner)
  clear_has_sync_partner();
  return sync_partner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskPlan::set_allocated_sync_partner(::std::string* sync_partner) {
  if (sync_partner != NULL) {
    set_has_sync_partner();
  } else {
    clear_has_sync_partner();
  }
  sync_partner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sync_partner);
  // @@protoc_insertion_point(field_set_allocated:arangodb.TaskPlan.sync_partner)
}

// optional string server_id = 6;
inline bool TaskPlan::has_server_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskPlan::set_has_server_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskPlan::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskPlan::clear_server_id() {
  server_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_server_id();
}
inline const ::std::string& TaskPlan::server_id() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskPlan.server_id)
  return server_id_.GetNoArena();
}
inline void TaskPlan::set_server_id(const ::std::string& value) {
  set_has_server_id();
  server_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arangodb.TaskPlan.server_id)
}
#if LANG_CXX11
inline void TaskPlan::set_server_id(::std::string&& value) {
  set_has_server_id();
  server_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arangodb.TaskPlan.server_id)
}
#endif
inline void TaskPlan::set_server_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_server_id();
  server_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arangodb.TaskPlan.server_id)
}
inline void TaskPlan::set_server_id(const char* value, size_t size) {
  set_has_server_id();
  server_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arangodb.TaskPlan.server_id)
}
inline ::std::string* TaskPlan::mutable_server_id() {
  set_has_server_id();
  // @@protoc_insertion_point(field_mutable:arangodb.TaskPlan.server_id)
  return server_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskPlan::release_server_id() {
  // @@protoc_insertion_point(field_release:arangodb.TaskPlan.server_id)
  clear_has_server_id();
  return server_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskPlan::set_allocated_server_id(::std::string* server_id) {
  if (server_id != NULL) {
    set_has_server_id();
  } else {
    clear_has_server_id();
  }
  server_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_id);
  // @@protoc_insertion_point(field_set_allocated:arangodb.TaskPlan.server_id)
}

// -------------------------------------------------------------------

// TasksPlan

// repeated .arangodb.TaskPlan entries = 1;
inline int TasksPlan::entries_size() const {
  return entries_.size();
}
inline void TasksPlan::clear_entries() {
  entries_.Clear();
}
inline const ::arangodb::TaskPlan& TasksPlan::entries(int index) const {
  // @@protoc_insertion_point(field_get:arangodb.TasksPlan.entries)
  return entries_.Get(index);
}
inline ::arangodb::TaskPlan* TasksPlan::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:arangodb.TasksPlan.entries)
  return entries_.Mutable(index);
}
inline ::arangodb::TaskPlan* TasksPlan::add_entries() {
  // @@protoc_insertion_point(field_add:arangodb.TasksPlan.entries)
  return entries_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >*
TasksPlan::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:arangodb.TasksPlan.entries)
  return &entries_;
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >&
TasksPlan::entries() const {
  // @@protoc_insertion_point(field_list:arangodb.TasksPlan.entries)
  return entries_;
}

// -------------------------------------------------------------------

// Plan

// required .arangodb.TasksPlan agents = 1;
inline bool Plan::has_agents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Plan::set_has_agents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Plan::clear_has_agents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Plan::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::TasksPlan::Clear();
  clear_has_agents();
}
inline const ::arangodb::TasksPlan& Plan::agents() const {
  // @@protoc_insertion_point(field_get:arangodb.Plan.agents)
  return agents_ != NULL ? *agents_
                         : *::arangodb::TasksPlan::internal_default_instance();
}
inline ::arangodb::TasksPlan* Plan::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) {
    agents_ = new ::arangodb::TasksPlan;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Plan.agents)
  return agents_;
}
inline ::arangodb::TasksPlan* Plan::release_agents() {
  // @@protoc_insertion_point(field_release:arangodb.Plan.agents)
  clear_has_agents();
  ::arangodb::TasksPlan* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Plan::set_allocated_agents(::arangodb::TasksPlan* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Plan.agents)
}

// required .arangodb.TasksPlan coordinators = 2;
inline bool Plan::has_coordinators() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Plan::set_has_coordinators() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Plan::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Plan::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::TasksPlan::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::TasksPlan& Plan::coordinators() const {
  // @@protoc_insertion_point(field_get:arangodb.Plan.coordinators)
  return coordinators_ != NULL ? *coordinators_
                         : *::arangodb::TasksPlan::internal_default_instance();
}
inline ::arangodb::TasksPlan* Plan::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) {
    coordinators_ = new ::arangodb::TasksPlan;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Plan.coordinators)
  return coordinators_;
}
inline ::arangodb::TasksPlan* Plan::release_coordinators() {
  // @@protoc_insertion_point(field_release:arangodb.Plan.coordinators)
  clear_has_coordinators();
  ::arangodb::TasksPlan* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Plan::set_allocated_coordinators(::arangodb::TasksPlan* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Plan.coordinators)
}

// required .arangodb.TasksPlan dbservers = 3;
inline bool Plan::has_dbservers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Plan::set_has_dbservers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Plan::clear_has_dbservers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Plan::clear_dbservers() {
  if (dbservers_ != NULL) dbservers_->::arangodb::TasksPlan::Clear();
  clear_has_dbservers();
}
inline const ::arangodb::TasksPlan& Plan::dbservers() const {
  // @@protoc_insertion_point(field_get:arangodb.Plan.dbservers)
  return dbservers_ != NULL ? *dbservers_
                         : *::arangodb::TasksPlan::internal_default_instance();
}
inline ::arangodb::TasksPlan* Plan::mutable_dbservers() {
  set_has_dbservers();
  if (dbservers_ == NULL) {
    dbservers_ = new ::arangodb::TasksPlan;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Plan.dbservers)
  return dbservers_;
}
inline ::arangodb::TasksPlan* Plan::release_dbservers() {
  // @@protoc_insertion_point(field_release:arangodb.Plan.dbservers)
  clear_has_dbservers();
  ::arangodb::TasksPlan* temp = dbservers_;
  dbservers_ = NULL;
  return temp;
}
inline void Plan::set_allocated_dbservers(::arangodb::TasksPlan* dbservers) {
  delete dbservers_;
  dbservers_ = dbservers;
  if (dbservers) {
    set_has_dbservers();
  } else {
    clear_has_dbservers();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Plan.dbservers)
}

// required .arangodb.TasksPlan secondaries = 4;
inline bool Plan::has_secondaries() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Plan::set_has_secondaries() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Plan::clear_has_secondaries() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Plan::clear_secondaries() {
  if (secondaries_ != NULL) secondaries_->::arangodb::TasksPlan::Clear();
  clear_has_secondaries();
}
inline const ::arangodb::TasksPlan& Plan::secondaries() const {
  // @@protoc_insertion_point(field_get:arangodb.Plan.secondaries)
  return secondaries_ != NULL ? *secondaries_
                         : *::arangodb::TasksPlan::internal_default_instance();
}
inline ::arangodb::TasksPlan* Plan::mutable_secondaries() {
  set_has_secondaries();
  if (secondaries_ == NULL) {
    secondaries_ = new ::arangodb::TasksPlan;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Plan.secondaries)
  return secondaries_;
}
inline ::arangodb::TasksPlan* Plan::release_secondaries() {
  // @@protoc_insertion_point(field_release:arangodb.Plan.secondaries)
  clear_has_secondaries();
  ::arangodb::TasksPlan* temp = secondaries_;
  secondaries_ = NULL;
  return temp;
}
inline void Plan::set_allocated_secondaries(::arangodb::TasksPlan* secondaries) {
  delete secondaries_;
  secondaries_ = secondaries;
  if (secondaries) {
    set_has_secondaries();
  } else {
    clear_has_secondaries();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Plan.secondaries)
}

// -------------------------------------------------------------------

// TaskCurrent

// optional .mesos.SlaveID slave_id = 1;
inline bool TaskCurrent::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskCurrent::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskCurrent::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskCurrent::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TaskCurrent::slave_id() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskCurrent.slave_id)
  return slave_id_ != NULL ? *slave_id_
                         : *::mesos::SlaveID::internal_default_instance();
}
inline ::mesos::SlaveID* TaskCurrent::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    slave_id_ = new ::mesos::SlaveID;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.TaskCurrent.slave_id)
  return slave_id_;
}
inline ::mesos::SlaveID* TaskCurrent::release_slave_id() {
  // @@protoc_insertion_point(field_release:arangodb.TaskCurrent.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void TaskCurrent::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.TaskCurrent.slave_id)
}

// optional .mesos.OfferID offer_id = 2;
inline bool TaskCurrent::has_offer_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskCurrent::set_has_offer_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskCurrent::clear_has_offer_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskCurrent::clear_offer_id() {
  if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
  clear_has_offer_id();
}
inline const ::mesos::OfferID& TaskCurrent::offer_id() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskCurrent.offer_id)
  return offer_id_ != NULL ? *offer_id_
                         : *::mesos::OfferID::internal_default_instance();
}
inline ::mesos::OfferID* TaskCurrent::mutable_offer_id() {
  set_has_offer_id();
  if (offer_id_ == NULL) {
    offer_id_ = new ::mesos::OfferID;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.TaskCurrent.offer_id)
  return offer_id_;
}
inline ::mesos::OfferID* TaskCurrent::release_offer_id() {
  // @@protoc_insertion_point(field_release:arangodb.TaskCurrent.offer_id)
  clear_has_offer_id();
  ::mesos::OfferID* temp = offer_id_;
  offer_id_ = NULL;
  return temp;
}
inline void TaskCurrent::set_allocated_offer_id(::mesos::OfferID* offer_id) {
  delete offer_id_;
  offer_id_ = offer_id;
  if (offer_id) {
    set_has_offer_id();
  } else {
    clear_has_offer_id();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.TaskCurrent.offer_id)
}

// repeated .mesos.Resource resources = 3;
inline int TaskCurrent::resources_size() const {
  return resources_.size();
}
inline void TaskCurrent::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& TaskCurrent::resources(int index) const {
  // @@protoc_insertion_point(field_get:arangodb.TaskCurrent.resources)
  return resources_.Get(index);
}
inline ::mesos::Resource* TaskCurrent::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:arangodb.TaskCurrent.resources)
  return resources_.Mutable(index);
}
inline ::mesos::Resource* TaskCurrent::add_resources() {
  // @@protoc_insertion_point(field_add:arangodb.TaskCurrent.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TaskCurrent::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:arangodb.TaskCurrent.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TaskCurrent::resources() const {
  // @@protoc_insertion_point(field_list:arangodb.TaskCurrent.resources)
  return resources_;
}

// repeated uint32 ports = 4;
inline int TaskCurrent::ports_size() const {
  return ports_.size();
}
inline void TaskCurrent::clear_ports() {
  ports_.Clear();
}
inline ::google::protobuf::uint32 TaskCurrent::ports(int index) const {
  // @@protoc_insertion_point(field_get:arangodb.TaskCurrent.ports)
  return ports_.Get(index);
}
inline void TaskCurrent::set_ports(int index, ::google::protobuf::uint32 value) {
  ports_.Set(index, value);
  // @@protoc_insertion_point(field_set:arangodb.TaskCurrent.ports)
}
inline void TaskCurrent::add_ports(::google::protobuf::uint32 value) {
  ports_.Add(value);
  // @@protoc_insertion_point(field_add:arangodb.TaskCurrent.ports)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TaskCurrent::ports() const {
  // @@protoc_insertion_point(field_list:arangodb.TaskCurrent.ports)
  return ports_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TaskCurrent::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:arangodb.TaskCurrent.ports)
  return &ports_;
}

// optional string hostname = 5;
inline bool TaskCurrent::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskCurrent::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskCurrent::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskCurrent::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
inline const ::std::string& TaskCurrent::hostname() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskCurrent.hostname)
  return hostname_.GetNoArena();
}
inline void TaskCurrent::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arangodb.TaskCurrent.hostname)
}
#if LANG_CXX11
inline void TaskCurrent::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arangodb.TaskCurrent.hostname)
}
#endif
inline void TaskCurrent::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arangodb.TaskCurrent.hostname)
}
inline void TaskCurrent::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arangodb.TaskCurrent.hostname)
}
inline ::std::string* TaskCurrent::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:arangodb.TaskCurrent.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskCurrent::release_hostname() {
  // @@protoc_insertion_point(field_release:arangodb.TaskCurrent.hostname)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskCurrent::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:arangodb.TaskCurrent.hostname)
}

// optional string container_path = 6;
inline bool TaskCurrent::has_container_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskCurrent::set_has_container_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskCurrent::clear_has_container_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskCurrent::clear_container_path() {
  container_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_container_path();
}
inline const ::std::string& TaskCurrent::container_path() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskCurrent.container_path)
  return container_path_.GetNoArena();
}
inline void TaskCurrent::set_container_path(const ::std::string& value) {
  set_has_container_path();
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arangodb.TaskCurrent.container_path)
}
#if LANG_CXX11
inline void TaskCurrent::set_container_path(::std::string&& value) {
  set_has_container_path();
  container_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arangodb.TaskCurrent.container_path)
}
#endif
inline void TaskCurrent::set_container_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_container_path();
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arangodb.TaskCurrent.container_path)
}
inline void TaskCurrent::set_container_path(const char* value, size_t size) {
  set_has_container_path();
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arangodb.TaskCurrent.container_path)
}
inline ::std::string* TaskCurrent::mutable_container_path() {
  set_has_container_path();
  // @@protoc_insertion_point(field_mutable:arangodb.TaskCurrent.container_path)
  return container_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskCurrent::release_container_path() {
  // @@protoc_insertion_point(field_release:arangodb.TaskCurrent.container_path)
  clear_has_container_path();
  return container_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskCurrent::set_allocated_container_path(::std::string* container_path) {
  if (container_path != NULL) {
    set_has_container_path();
  } else {
    clear_has_container_path();
  }
  container_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_path);
  // @@protoc_insertion_point(field_set_allocated:arangodb.TaskCurrent.container_path)
}

// optional .mesos.TaskInfo task_info = 7;
inline bool TaskCurrent::has_task_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskCurrent::set_has_task_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskCurrent::clear_has_task_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskCurrent::clear_task_info() {
  if (task_info_ != NULL) task_info_->::mesos::TaskInfo::Clear();
  clear_has_task_info();
}
inline const ::mesos::TaskInfo& TaskCurrent::task_info() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskCurrent.task_info)
  return task_info_ != NULL ? *task_info_
                         : *::mesos::TaskInfo::internal_default_instance();
}
inline ::mesos::TaskInfo* TaskCurrent::mutable_task_info() {
  set_has_task_info();
  if (task_info_ == NULL) {
    task_info_ = new ::mesos::TaskInfo;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.TaskCurrent.task_info)
  return task_info_;
}
inline ::mesos::TaskInfo* TaskCurrent::release_task_info() {
  // @@protoc_insertion_point(field_release:arangodb.TaskCurrent.task_info)
  clear_has_task_info();
  ::mesos::TaskInfo* temp = task_info_;
  task_info_ = NULL;
  return temp;
}
inline void TaskCurrent::set_allocated_task_info(::mesos::TaskInfo* task_info) {
  delete task_info_;
  task_info_ = task_info;
  if (task_info) {
    set_has_task_info();
  } else {
    clear_has_task_info();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.TaskCurrent.task_info)
}

// optional double start_time = 8;
inline bool TaskCurrent::has_start_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskCurrent::set_has_start_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskCurrent::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskCurrent::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline double TaskCurrent::start_time() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskCurrent.start_time)
  return start_time_;
}
inline void TaskCurrent::set_start_time(double value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:arangodb.TaskCurrent.start_time)
}

// optional double kill_time = 9;
inline bool TaskCurrent::has_kill_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskCurrent::set_has_kill_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskCurrent::clear_has_kill_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskCurrent::clear_kill_time() {
  kill_time_ = 0;
  clear_has_kill_time();
}
inline double TaskCurrent::kill_time() const {
  // @@protoc_insertion_point(field_get:arangodb.TaskCurrent.kill_time)
  return kill_time_;
}
inline void TaskCurrent::set_kill_time(double value) {
  set_has_kill_time();
  kill_time_ = value;
  // @@protoc_insertion_point(field_set:arangodb.TaskCurrent.kill_time)
}

// -------------------------------------------------------------------

// TasksCurrent

// repeated .arangodb.TaskCurrent entries = 1;
inline int TasksCurrent::entries_size() const {
  return entries_.size();
}
inline void TasksCurrent::clear_entries() {
  entries_.Clear();
}
inline const ::arangodb::TaskCurrent& TasksCurrent::entries(int index) const {
  // @@protoc_insertion_point(field_get:arangodb.TasksCurrent.entries)
  return entries_.Get(index);
}
inline ::arangodb::TaskCurrent* TasksCurrent::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:arangodb.TasksCurrent.entries)
  return entries_.Mutable(index);
}
inline ::arangodb::TaskCurrent* TasksCurrent::add_entries() {
  // @@protoc_insertion_point(field_add:arangodb.TasksCurrent.entries)
  return entries_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::TaskCurrent >*
TasksCurrent::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:arangodb.TasksCurrent.entries)
  return &entries_;
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::TaskCurrent >&
TasksCurrent::entries() const {
  // @@protoc_insertion_point(field_list:arangodb.TasksCurrent.entries)
  return entries_;
}

// -------------------------------------------------------------------

// Current

// required .arangodb.TasksCurrent agents = 1;
inline bool Current::has_agents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Current::set_has_agents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Current::clear_has_agents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Current::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::TasksCurrent::Clear();
  clear_has_agents();
}
inline const ::arangodb::TasksCurrent& Current::agents() const {
  // @@protoc_insertion_point(field_get:arangodb.Current.agents)
  return agents_ != NULL ? *agents_
                         : *::arangodb::TasksCurrent::internal_default_instance();
}
inline ::arangodb::TasksCurrent* Current::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) {
    agents_ = new ::arangodb::TasksCurrent;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Current.agents)
  return agents_;
}
inline ::arangodb::TasksCurrent* Current::release_agents() {
  // @@protoc_insertion_point(field_release:arangodb.Current.agents)
  clear_has_agents();
  ::arangodb::TasksCurrent* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Current::set_allocated_agents(::arangodb::TasksCurrent* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Current.agents)
}

// required .arangodb.TasksCurrent coordinators = 2;
inline bool Current::has_coordinators() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Current::set_has_coordinators() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Current::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Current::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::TasksCurrent::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::TasksCurrent& Current::coordinators() const {
  // @@protoc_insertion_point(field_get:arangodb.Current.coordinators)
  return coordinators_ != NULL ? *coordinators_
                         : *::arangodb::TasksCurrent::internal_default_instance();
}
inline ::arangodb::TasksCurrent* Current::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) {
    coordinators_ = new ::arangodb::TasksCurrent;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Current.coordinators)
  return coordinators_;
}
inline ::arangodb::TasksCurrent* Current::release_coordinators() {
  // @@protoc_insertion_point(field_release:arangodb.Current.coordinators)
  clear_has_coordinators();
  ::arangodb::TasksCurrent* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Current::set_allocated_coordinators(::arangodb::TasksCurrent* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Current.coordinators)
}

// required .arangodb.TasksCurrent dbservers = 3;
inline bool Current::has_dbservers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Current::set_has_dbservers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Current::clear_has_dbservers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Current::clear_dbservers() {
  if (dbservers_ != NULL) dbservers_->::arangodb::TasksCurrent::Clear();
  clear_has_dbservers();
}
inline const ::arangodb::TasksCurrent& Current::dbservers() const {
  // @@protoc_insertion_point(field_get:arangodb.Current.dbservers)
  return dbservers_ != NULL ? *dbservers_
                         : *::arangodb::TasksCurrent::internal_default_instance();
}
inline ::arangodb::TasksCurrent* Current::mutable_dbservers() {
  set_has_dbservers();
  if (dbservers_ == NULL) {
    dbservers_ = new ::arangodb::TasksCurrent;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Current.dbservers)
  return dbservers_;
}
inline ::arangodb::TasksCurrent* Current::release_dbservers() {
  // @@protoc_insertion_point(field_release:arangodb.Current.dbservers)
  clear_has_dbservers();
  ::arangodb::TasksCurrent* temp = dbservers_;
  dbservers_ = NULL;
  return temp;
}
inline void Current::set_allocated_dbservers(::arangodb::TasksCurrent* dbservers) {
  delete dbservers_;
  dbservers_ = dbservers;
  if (dbservers) {
    set_has_dbservers();
  } else {
    clear_has_dbservers();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Current.dbservers)
}

// required .arangodb.TasksCurrent secondaries = 4;
inline bool Current::has_secondaries() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Current::set_has_secondaries() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Current::clear_has_secondaries() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Current::clear_secondaries() {
  if (secondaries_ != NULL) secondaries_->::arangodb::TasksCurrent::Clear();
  clear_has_secondaries();
}
inline const ::arangodb::TasksCurrent& Current::secondaries() const {
  // @@protoc_insertion_point(field_get:arangodb.Current.secondaries)
  return secondaries_ != NULL ? *secondaries_
                         : *::arangodb::TasksCurrent::internal_default_instance();
}
inline ::arangodb::TasksCurrent* Current::mutable_secondaries() {
  set_has_secondaries();
  if (secondaries_ == NULL) {
    secondaries_ = new ::arangodb::TasksCurrent;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.Current.secondaries)
  return secondaries_;
}
inline ::arangodb::TasksCurrent* Current::release_secondaries() {
  // @@protoc_insertion_point(field_release:arangodb.Current.secondaries)
  clear_has_secondaries();
  ::arangodb::TasksCurrent* temp = secondaries_;
  secondaries_ = NULL;
  return temp;
}
inline void Current::set_allocated_secondaries(::arangodb::TasksCurrent* secondaries) {
  delete secondaries_;
  secondaries_ = secondaries;
  if (secondaries) {
    set_has_secondaries();
  } else {
    clear_has_secondaries();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.Current.secondaries)
}

// required bool cluster_complete = 5;
inline bool Current::has_cluster_complete() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Current::set_has_cluster_complete() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Current::clear_has_cluster_complete() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Current::clear_cluster_complete() {
  cluster_complete_ = false;
  clear_has_cluster_complete();
}
inline bool Current::cluster_complete() const {
  // @@protoc_insertion_point(field_get:arangodb.Current.cluster_complete)
  return cluster_complete_;
}
inline void Current::set_cluster_complete(bool value) {
  set_has_cluster_complete();
  cluster_complete_ = value;
  // @@protoc_insertion_point(field_set:arangodb.Current.cluster_complete)
}

// -------------------------------------------------------------------

// State

// optional .mesos.FrameworkID framework_id = 1;
inline bool State::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void State::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& State::framework_id() const {
  // @@protoc_insertion_point(field_get:arangodb.State.framework_id)
  return framework_id_ != NULL ? *framework_id_
                         : *::mesos::FrameworkID::internal_default_instance();
}
inline ::mesos::FrameworkID* State::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    framework_id_ = new ::mesos::FrameworkID;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.State.framework_id)
  return framework_id_;
}
inline ::mesos::FrameworkID* State::release_framework_id() {
  // @@protoc_insertion_point(field_release:arangodb.State.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void State::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.State.framework_id)
}

// required .arangodb.Targets targets = 2;
inline bool State::has_targets() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::set_has_targets() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State::clear_has_targets() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void State::clear_targets() {
  if (targets_ != NULL) targets_->::arangodb::Targets::Clear();
  clear_has_targets();
}
inline const ::arangodb::Targets& State::targets() const {
  // @@protoc_insertion_point(field_get:arangodb.State.targets)
  return targets_ != NULL ? *targets_
                         : *::arangodb::Targets::internal_default_instance();
}
inline ::arangodb::Targets* State::mutable_targets() {
  set_has_targets();
  if (targets_ == NULL) {
    targets_ = new ::arangodb::Targets;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.State.targets)
  return targets_;
}
inline ::arangodb::Targets* State::release_targets() {
  // @@protoc_insertion_point(field_release:arangodb.State.targets)
  clear_has_targets();
  ::arangodb::Targets* temp = targets_;
  targets_ = NULL;
  return temp;
}
inline void State::set_allocated_targets(::arangodb::Targets* targets) {
  delete targets_;
  targets_ = targets;
  if (targets) {
    set_has_targets();
  } else {
    clear_has_targets();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.State.targets)
}

// required .arangodb.Plan plan = 3;
inline bool State::has_plan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State::set_has_plan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void State::clear_has_plan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void State::clear_plan() {
  if (plan_ != NULL) plan_->::arangodb::Plan::Clear();
  clear_has_plan();
}
inline const ::arangodb::Plan& State::plan() const {
  // @@protoc_insertion_point(field_get:arangodb.State.plan)
  return plan_ != NULL ? *plan_
                         : *::arangodb::Plan::internal_default_instance();
}
inline ::arangodb::Plan* State::mutable_plan() {
  set_has_plan();
  if (plan_ == NULL) {
    plan_ = new ::arangodb::Plan;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.State.plan)
  return plan_;
}
inline ::arangodb::Plan* State::release_plan() {
  // @@protoc_insertion_point(field_release:arangodb.State.plan)
  clear_has_plan();
  ::arangodb::Plan* temp = plan_;
  plan_ = NULL;
  return temp;
}
inline void State::set_allocated_plan(::arangodb::Plan* plan) {
  delete plan_;
  plan_ = plan;
  if (plan) {
    set_has_plan();
  } else {
    clear_has_plan();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.State.plan)
}

// required .arangodb.Current current = 4;
inline bool State::has_current() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void State::set_has_current() {
  _has_bits_[0] |= 0x00000008u;
}
inline void State::clear_has_current() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void State::clear_current() {
  if (current_ != NULL) current_->::arangodb::Current::Clear();
  clear_has_current();
}
inline const ::arangodb::Current& State::current() const {
  // @@protoc_insertion_point(field_get:arangodb.State.current)
  return current_ != NULL ? *current_
                         : *::arangodb::Current::internal_default_instance();
}
inline ::arangodb::Current* State::mutable_current() {
  set_has_current();
  if (current_ == NULL) {
    current_ = new ::arangodb::Current;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.State.current)
  return current_;
}
inline ::arangodb::Current* State::release_current() {
  // @@protoc_insertion_point(field_release:arangodb.State.current)
  clear_has_current();
  ::arangodb::Current* temp = current_;
  current_ = NULL;
  return temp;
}
inline void State::set_allocated_current(::arangodb::Current* current) {
  delete current_;
  current_ = current;
  if (current) {
    set_has_current();
  } else {
    clear_has_current();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.State.current)
}

// optional .arangodb.Restart restart = 5;
inline bool State::has_restart() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void State::set_has_restart() {
  _has_bits_[0] |= 0x00000010u;
}
inline void State::clear_has_restart() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void State::clear_restart() {
  if (restart_ != NULL) restart_->::arangodb::Restart::Clear();
  clear_has_restart();
}
inline const ::arangodb::Restart& State::restart() const {
  // @@protoc_insertion_point(field_get:arangodb.State.restart)
  return restart_ != NULL ? *restart_
                         : *::arangodb::Restart::internal_default_instance();
}
inline ::arangodb::Restart* State::mutable_restart() {
  set_has_restart();
  if (restart_ == NULL) {
    restart_ = new ::arangodb::Restart;
  }
  // @@protoc_insertion_point(field_mutable:arangodb.State.restart)
  return restart_;
}
inline ::arangodb::Restart* State::release_restart() {
  // @@protoc_insertion_point(field_release:arangodb.State.restart)
  clear_has_restart();
  ::arangodb::Restart* temp = restart_;
  restart_ = NULL;
  return temp;
}
inline void State::set_allocated_restart(::arangodb::Restart* restart) {
  delete restart_;
  restart_ = restart;
  if (restart) {
    set_has_restart();
  } else {
    clear_has_restart();
  }
  // @@protoc_insertion_point(field_set_allocated:arangodb.State.restart)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace arangodb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::arangodb::TaskPlanState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arangodb::TaskPlanState>() {
  return ::arangodb::TaskPlanState_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_arangodb_2eproto__INCLUDED
