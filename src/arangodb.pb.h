// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: arangodb.proto

#ifndef PROTOBUF_arangodb_2eproto__INCLUDED
#define PROTOBUF_arangodb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace arangodb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_arangodb_2eproto();
void protobuf_AssignDesc_arangodb_2eproto();
void protobuf_ShutdownFile_arangodb_2eproto();

class TargetEntry;
class Target;
class TasksPlanEntry;
class TasksPlan;
class Plan;
class ResourcesCurrentEntry;
class ResourcesCurrent;
class InstancesCurrentEntry;
class InstancesCurrent;
class Current;
class State;

enum ResourcesCurrentState {
  RESOURCE_STATE_UNKNOWN = 1,
  RESOURCE_STATE_REQUIRED = 2,
  RESOURCE_STATE_TRYING_TO_RESERVE = 3,
  RESOURCE_STATE_TRYING_TO_PERSIST = 4,
  RESOURCE_STATE_USEABLE = 5,
  RESOURCE_STATE_USED = 6,
  RESOURCE_STATE_LOST = 7
};
bool ResourcesCurrentState_IsValid(int value);
const ResourcesCurrentState ResourcesCurrentState_MIN = RESOURCE_STATE_UNKNOWN;
const ResourcesCurrentState ResourcesCurrentState_MAX = RESOURCE_STATE_LOST;
const int ResourcesCurrentState_ARRAYSIZE = ResourcesCurrentState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResourcesCurrentState_descriptor();
inline const ::std::string& ResourcesCurrentState_Name(ResourcesCurrentState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResourcesCurrentState_descriptor(), value);
}
inline bool ResourcesCurrentState_Parse(
    const ::std::string& name, ResourcesCurrentState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResourcesCurrentState>(
    ResourcesCurrentState_descriptor(), name, value);
}
enum InstancesCurrentState {
  INSTANCE_STATE_UNUSED = 1,
  INSTANCE_STATE_STARTING = 2,
  INSTANCE_STATE_RUNNING = 3,
  INSTANCE_STATE_STOPPED = 4
};
bool InstancesCurrentState_IsValid(int value);
const InstancesCurrentState InstancesCurrentState_MIN = INSTANCE_STATE_UNUSED;
const InstancesCurrentState InstancesCurrentState_MAX = INSTANCE_STATE_STOPPED;
const int InstancesCurrentState_ARRAYSIZE = InstancesCurrentState_MAX + 1;

const ::google::protobuf::EnumDescriptor* InstancesCurrentState_descriptor();
inline const ::std::string& InstancesCurrentState_Name(InstancesCurrentState value) {
  return ::google::protobuf::internal::NameOfEnum(
    InstancesCurrentState_descriptor(), value);
}
inline bool InstancesCurrentState_Parse(
    const ::std::string& name, InstancesCurrentState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InstancesCurrentState>(
    InstancesCurrentState_descriptor(), name, value);
}
// ===================================================================

class TargetEntry : public ::google::protobuf::Message {
 public:
  TargetEntry();
  virtual ~TargetEntry();

  TargetEntry(const TargetEntry& from);

  inline TargetEntry& operator=(const TargetEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetEntry& default_instance();

  void Swap(TargetEntry* other);

  // implements Message ----------------------------------------------

  TargetEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetEntry& from);
  void MergeFrom(const TargetEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 instances = 1;
  inline bool has_instances() const;
  inline void clear_instances();
  static const int kInstancesFieldNumber = 1;
  inline ::google::protobuf::uint32 instances() const;
  inline void set_instances(::google::protobuf::uint32 value);

  // repeated .mesos.Resource minimal_resources = 2;
  inline int minimal_resources_size() const;
  inline void clear_minimal_resources();
  static const int kMinimalResourcesFieldNumber = 2;
  inline const ::mesos::Resource& minimal_resources(int index) const;
  inline ::mesos::Resource* mutable_minimal_resources(int index);
  inline ::mesos::Resource* add_minimal_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      minimal_resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_minimal_resources();

  // repeated .mesos.Resource additional_resouces = 3;
  inline int additional_resouces_size() const;
  inline void clear_additional_resouces();
  static const int kAdditionalResoucesFieldNumber = 3;
  inline const ::mesos::Resource& additional_resouces(int index) const;
  inline ::mesos::Resource* mutable_additional_resouces(int index);
  inline ::mesos::Resource* add_additional_resouces();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      additional_resouces() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_additional_resouces();

  // required uint32 number_ports = 4;
  inline bool has_number_ports() const;
  inline void clear_number_ports();
  static const int kNumberPortsFieldNumber = 4;
  inline ::google::protobuf::uint32 number_ports() const;
  inline void set_number_ports(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:arangodb.TargetEntry)
 private:
  inline void set_has_instances();
  inline void clear_has_instances();
  inline void set_has_number_ports();
  inline void clear_has_number_ports();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > minimal_resources_;
  ::google::protobuf::uint32 instances_;
  ::google::protobuf::uint32 number_ports_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > additional_resouces_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static TargetEntry* default_instance_;
};
// -------------------------------------------------------------------

class Target : public ::google::protobuf::Message {
 public:
  Target();
  virtual ~Target();

  Target(const Target& from);

  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Target& default_instance();

  void Swap(Target* other);

  // implements Message ----------------------------------------------

  Target* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Target& from);
  void MergeFrom(const Target& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline const ::std::string& mode() const;
  inline void set_mode(const ::std::string& value);
  inline void set_mode(const char* value);
  inline void set_mode(const char* value, size_t size);
  inline ::std::string* mutable_mode();
  inline ::std::string* release_mode();
  inline void set_allocated_mode(::std::string* mode);

  // required .arangodb.TargetEntry agents = 2;
  inline bool has_agents() const;
  inline void clear_agents();
  static const int kAgentsFieldNumber = 2;
  inline const ::arangodb::TargetEntry& agents() const;
  inline ::arangodb::TargetEntry* mutable_agents();
  inline ::arangodb::TargetEntry* release_agents();
  inline void set_allocated_agents(::arangodb::TargetEntry* agents);

  // required .arangodb.TargetEntry coordinators = 3;
  inline bool has_coordinators() const;
  inline void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 3;
  inline const ::arangodb::TargetEntry& coordinators() const;
  inline ::arangodb::TargetEntry* mutable_coordinators();
  inline ::arangodb::TargetEntry* release_coordinators();
  inline void set_allocated_coordinators(::arangodb::TargetEntry* coordinators);

  // required .arangodb.TargetEntry dbservers = 4;
  inline bool has_dbservers() const;
  inline void clear_dbservers();
  static const int kDbserversFieldNumber = 4;
  inline const ::arangodb::TargetEntry& dbservers() const;
  inline ::arangodb::TargetEntry* mutable_dbservers();
  inline ::arangodb::TargetEntry* release_dbservers();
  inline void set_allocated_dbservers(::arangodb::TargetEntry* dbservers);

  // @@protoc_insertion_point(class_scope:arangodb.Target)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_agents();
  inline void clear_has_agents();
  inline void set_has_coordinators();
  inline void clear_has_coordinators();
  inline void set_has_dbservers();
  inline void clear_has_dbservers();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mode_;
  ::arangodb::TargetEntry* agents_;
  ::arangodb::TargetEntry* coordinators_;
  ::arangodb::TargetEntry* dbservers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static Target* default_instance_;
};
// -------------------------------------------------------------------

class TasksPlanEntry : public ::google::protobuf::Message {
 public:
  TasksPlanEntry();
  virtual ~TasksPlanEntry();

  TasksPlanEntry(const TasksPlanEntry& from);

  inline TasksPlanEntry& operator=(const TasksPlanEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TasksPlanEntry& default_instance();

  void Swap(TasksPlanEntry* other);

  // implements Message ----------------------------------------------

  TasksPlanEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TasksPlanEntry& from);
  void MergeFrom(const TasksPlanEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_primary = 1;
  inline bool has_is_primary() const;
  inline void clear_is_primary();
  static const int kIsPrimaryFieldNumber = 1;
  inline bool is_primary() const;
  inline void set_is_primary(bool value);

  // optional .mesos.SlaveID slave_id = 2;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional string persistence_id = 3;
  inline bool has_persistence_id() const;
  inline void clear_persistence_id();
  static const int kPersistenceIdFieldNumber = 3;
  inline const ::std::string& persistence_id() const;
  inline void set_persistence_id(const ::std::string& value);
  inline void set_persistence_id(const char* value);
  inline void set_persistence_id(const char* value, size_t size);
  inline ::std::string* mutable_persistence_id();
  inline ::std::string* release_persistence_id();
  inline void set_allocated_persistence_id(::std::string* persistence_id);

  // @@protoc_insertion_point(class_scope:arangodb.TasksPlanEntry)
 private:
  inline void set_has_is_primary();
  inline void clear_has_is_primary();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_persistence_id();
  inline void clear_has_persistence_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::std::string* persistence_id_;
  bool is_primary_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static TasksPlanEntry* default_instance_;
};
// -------------------------------------------------------------------

class TasksPlan : public ::google::protobuf::Message {
 public:
  TasksPlan();
  virtual ~TasksPlan();

  TasksPlan(const TasksPlan& from);

  inline TasksPlan& operator=(const TasksPlan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TasksPlan& default_instance();

  void Swap(TasksPlan* other);

  // implements Message ----------------------------------------------

  TasksPlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TasksPlan& from);
  void MergeFrom(const TasksPlan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.TasksPlanEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::arangodb::TasksPlanEntry& entries(int index) const;
  inline ::arangodb::TasksPlanEntry* mutable_entries(int index);
  inline ::arangodb::TasksPlanEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::arangodb::TasksPlanEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::arangodb::TasksPlanEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:arangodb.TasksPlan)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::arangodb::TasksPlanEntry > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static TasksPlan* default_instance_;
};
// -------------------------------------------------------------------

class Plan : public ::google::protobuf::Message {
 public:
  Plan();
  virtual ~Plan();

  Plan(const Plan& from);

  inline Plan& operator=(const Plan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Plan& default_instance();

  void Swap(Plan* other);

  // implements Message ----------------------------------------------

  Plan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Plan& from);
  void MergeFrom(const Plan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .arangodb.TasksPlan agents = 1;
  inline bool has_agents() const;
  inline void clear_agents();
  static const int kAgentsFieldNumber = 1;
  inline const ::arangodb::TasksPlan& agents() const;
  inline ::arangodb::TasksPlan* mutable_agents();
  inline ::arangodb::TasksPlan* release_agents();
  inline void set_allocated_agents(::arangodb::TasksPlan* agents);

  // required .arangodb.TasksPlan coordinators = 2;
  inline bool has_coordinators() const;
  inline void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 2;
  inline const ::arangodb::TasksPlan& coordinators() const;
  inline ::arangodb::TasksPlan* mutable_coordinators();
  inline ::arangodb::TasksPlan* release_coordinators();
  inline void set_allocated_coordinators(::arangodb::TasksPlan* coordinators);

  // required .arangodb.TasksPlan dbservers = 3;
  inline bool has_dbservers() const;
  inline void clear_dbservers();
  static const int kDbserversFieldNumber = 3;
  inline const ::arangodb::TasksPlan& dbservers() const;
  inline ::arangodb::TasksPlan* mutable_dbservers();
  inline ::arangodb::TasksPlan* release_dbservers();
  inline void set_allocated_dbservers(::arangodb::TasksPlan* dbservers);

  // @@protoc_insertion_point(class_scope:arangodb.Plan)
 private:
  inline void set_has_agents();
  inline void clear_has_agents();
  inline void set_has_coordinators();
  inline void clear_has_coordinators();
  inline void set_has_dbservers();
  inline void clear_has_dbservers();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::arangodb::TasksPlan* agents_;
  ::arangodb::TasksPlan* coordinators_;
  ::arangodb::TasksPlan* dbservers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static Plan* default_instance_;
};
// -------------------------------------------------------------------

class ResourcesCurrentEntry : public ::google::protobuf::Message {
 public:
  ResourcesCurrentEntry();
  virtual ~ResourcesCurrentEntry();

  ResourcesCurrentEntry(const ResourcesCurrentEntry& from);

  inline ResourcesCurrentEntry& operator=(const ResourcesCurrentEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourcesCurrentEntry& default_instance();

  void Swap(ResourcesCurrentEntry* other);

  // implements Message ----------------------------------------------

  ResourcesCurrentEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourcesCurrentEntry& from);
  void MergeFrom(const ResourcesCurrentEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .arangodb.ResourcesCurrentState state = 1 [default = RESOURCE_STATE_UNKNOWN];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::arangodb::ResourcesCurrentState state() const;
  inline void set_state(::arangodb::ResourcesCurrentState value);

  // optional .mesos.SlaveID slave_id = 2;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 2;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional .mesos.OfferID offer_id = 3;
  inline bool has_offer_id() const;
  inline void clear_offer_id();
  static const int kOfferIdFieldNumber = 3;
  inline const ::mesos::OfferID& offer_id() const;
  inline ::mesos::OfferID* mutable_offer_id();
  inline ::mesos::OfferID* release_offer_id();
  inline void set_allocated_offer_id(::mesos::OfferID* offer_id);

  // repeated .mesos.Resource resources = 4;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 4;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // repeated uint32 ports = 5;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 5;
  inline ::google::protobuf::uint32 ports(int index) const;
  inline void set_ports(int index, ::google::protobuf::uint32 value);
  inline void add_ports(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ports() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ports();

  // optional string hostname = 6;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 6;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string container_path = 7;
  inline bool has_container_path() const;
  inline void clear_container_path();
  static const int kContainerPathFieldNumber = 7;
  inline const ::std::string& container_path() const;
  inline void set_container_path(const ::std::string& value);
  inline void set_container_path(const char* value);
  inline void set_container_path(const char* value, size_t size);
  inline ::std::string* mutable_container_path();
  inline ::std::string* release_container_path();
  inline void set_allocated_container_path(::std::string* container_path);

  // @@protoc_insertion_point(class_scope:arangodb.ResourcesCurrentEntry)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_offer_id();
  inline void clear_has_offer_id();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_container_path();
  inline void clear_has_container_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::OfferID* offer_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ports_;
  ::std::string* hostname_;
  ::std::string* container_path_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static ResourcesCurrentEntry* default_instance_;
};
// -------------------------------------------------------------------

class ResourcesCurrent : public ::google::protobuf::Message {
 public:
  ResourcesCurrent();
  virtual ~ResourcesCurrent();

  ResourcesCurrent(const ResourcesCurrent& from);

  inline ResourcesCurrent& operator=(const ResourcesCurrent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourcesCurrent& default_instance();

  void Swap(ResourcesCurrent* other);

  // implements Message ----------------------------------------------

  ResourcesCurrent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourcesCurrent& from);
  void MergeFrom(const ResourcesCurrent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.ResourcesCurrentEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::arangodb::ResourcesCurrentEntry& entries(int index) const;
  inline ::arangodb::ResourcesCurrentEntry* mutable_entries(int index);
  inline ::arangodb::ResourcesCurrentEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::arangodb::ResourcesCurrentEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::arangodb::ResourcesCurrentEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:arangodb.ResourcesCurrent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::arangodb::ResourcesCurrentEntry > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static ResourcesCurrent* default_instance_;
};
// -------------------------------------------------------------------

class InstancesCurrentEntry : public ::google::protobuf::Message {
 public:
  InstancesCurrentEntry();
  virtual ~InstancesCurrentEntry();

  InstancesCurrentEntry(const InstancesCurrentEntry& from);

  inline InstancesCurrentEntry& operator=(const InstancesCurrentEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstancesCurrentEntry& default_instance();

  void Swap(InstancesCurrentEntry* other);

  // implements Message ----------------------------------------------

  InstancesCurrentEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstancesCurrentEntry& from);
  void MergeFrom(const InstancesCurrentEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .arangodb.InstancesCurrentState state = 1 [default = INSTANCE_STATE_UNUSED];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::arangodb::InstancesCurrentState state() const;
  inline void set_state(::arangodb::InstancesCurrentState value);

  // optional .mesos.TaskInfo task_info = 2;
  inline bool has_task_info() const;
  inline void clear_task_info();
  static const int kTaskInfoFieldNumber = 2;
  inline const ::mesos::TaskInfo& task_info() const;
  inline ::mesos::TaskInfo* mutable_task_info();
  inline ::mesos::TaskInfo* release_task_info();
  inline void set_allocated_task_info(::mesos::TaskInfo* task_info);

  // optional .mesos.TaskStatus task_status = 3;
  inline bool has_task_status() const;
  inline void clear_task_status();
  static const int kTaskStatusFieldNumber = 3;
  inline const ::mesos::TaskStatus& task_status() const;
  inline ::mesos::TaskStatus* mutable_task_status();
  inline ::mesos::TaskStatus* release_task_status();
  inline void set_allocated_task_status(::mesos::TaskStatus* task_status);

  // repeated uint32 ports = 4;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 4;
  inline ::google::protobuf::uint32 ports(int index) const;
  inline void set_ports(int index, ::google::protobuf::uint32 value);
  inline void add_ports(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ports() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ports();

  // optional string hostname = 5;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 5;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // @@protoc_insertion_point(class_scope:arangodb.InstancesCurrentEntry)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_task_info();
  inline void clear_has_task_info();
  inline void set_has_task_status();
  inline void clear_has_task_status();
  inline void set_has_hostname();
  inline void clear_has_hostname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::TaskInfo* task_info_;
  ::mesos::TaskStatus* task_status_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ports_;
  ::std::string* hostname_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static InstancesCurrentEntry* default_instance_;
};
// -------------------------------------------------------------------

class InstancesCurrent : public ::google::protobuf::Message {
 public:
  InstancesCurrent();
  virtual ~InstancesCurrent();

  InstancesCurrent(const InstancesCurrent& from);

  inline InstancesCurrent& operator=(const InstancesCurrent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstancesCurrent& default_instance();

  void Swap(InstancesCurrent* other);

  // implements Message ----------------------------------------------

  InstancesCurrent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstancesCurrent& from);
  void MergeFrom(const InstancesCurrent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.InstancesCurrentEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::arangodb::InstancesCurrentEntry& entries(int index) const;
  inline ::arangodb::InstancesCurrentEntry* mutable_entries(int index);
  inline ::arangodb::InstancesCurrentEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::arangodb::InstancesCurrentEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::arangodb::InstancesCurrentEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:arangodb.InstancesCurrent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::arangodb::InstancesCurrentEntry > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static InstancesCurrent* default_instance_;
};
// -------------------------------------------------------------------

class Current : public ::google::protobuf::Message {
 public:
  Current();
  virtual ~Current();

  Current(const Current& from);

  inline Current& operator=(const Current& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Current& default_instance();

  void Swap(Current* other);

  // implements Message ----------------------------------------------

  Current* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Current& from);
  void MergeFrom(const Current& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .arangodb.ResourcesCurrent agency_resources = 1;
  inline bool has_agency_resources() const;
  inline void clear_agency_resources();
  static const int kAgencyResourcesFieldNumber = 1;
  inline const ::arangodb::ResourcesCurrent& agency_resources() const;
  inline ::arangodb::ResourcesCurrent* mutable_agency_resources();
  inline ::arangodb::ResourcesCurrent* release_agency_resources();
  inline void set_allocated_agency_resources(::arangodb::ResourcesCurrent* agency_resources);

  // required .arangodb.ResourcesCurrent coordinator_resources = 2;
  inline bool has_coordinator_resources() const;
  inline void clear_coordinator_resources();
  static const int kCoordinatorResourcesFieldNumber = 2;
  inline const ::arangodb::ResourcesCurrent& coordinator_resources() const;
  inline ::arangodb::ResourcesCurrent* mutable_coordinator_resources();
  inline ::arangodb::ResourcesCurrent* release_coordinator_resources();
  inline void set_allocated_coordinator_resources(::arangodb::ResourcesCurrent* coordinator_resources);

  // required .arangodb.ResourcesCurrent primary_dbserver_resources = 3;
  inline bool has_primary_dbserver_resources() const;
  inline void clear_primary_dbserver_resources();
  static const int kPrimaryDbserverResourcesFieldNumber = 3;
  inline const ::arangodb::ResourcesCurrent& primary_dbserver_resources() const;
  inline ::arangodb::ResourcesCurrent* mutable_primary_dbserver_resources();
  inline ::arangodb::ResourcesCurrent* release_primary_dbserver_resources();
  inline void set_allocated_primary_dbserver_resources(::arangodb::ResourcesCurrent* primary_dbserver_resources);

  // required .arangodb.ResourcesCurrent secondary_dbserver_resources = 4;
  inline bool has_secondary_dbserver_resources() const;
  inline void clear_secondary_dbserver_resources();
  static const int kSecondaryDbserverResourcesFieldNumber = 4;
  inline const ::arangodb::ResourcesCurrent& secondary_dbserver_resources() const;
  inline ::arangodb::ResourcesCurrent* mutable_secondary_dbserver_resources();
  inline ::arangodb::ResourcesCurrent* release_secondary_dbserver_resources();
  inline void set_allocated_secondary_dbserver_resources(::arangodb::ResourcesCurrent* secondary_dbserver_resources);

  // required .arangodb.InstancesCurrent agents = 5;
  inline bool has_agents() const;
  inline void clear_agents();
  static const int kAgentsFieldNumber = 5;
  inline const ::arangodb::InstancesCurrent& agents() const;
  inline ::arangodb::InstancesCurrent* mutable_agents();
  inline ::arangodb::InstancesCurrent* release_agents();
  inline void set_allocated_agents(::arangodb::InstancesCurrent* agents);

  // required .arangodb.InstancesCurrent coordinators = 6;
  inline bool has_coordinators() const;
  inline void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 6;
  inline const ::arangodb::InstancesCurrent& coordinators() const;
  inline ::arangodb::InstancesCurrent* mutable_coordinators();
  inline ::arangodb::InstancesCurrent* release_coordinators();
  inline void set_allocated_coordinators(::arangodb::InstancesCurrent* coordinators);

  // required .arangodb.InstancesCurrent primary_dbservers = 7;
  inline bool has_primary_dbservers() const;
  inline void clear_primary_dbservers();
  static const int kPrimaryDbserversFieldNumber = 7;
  inline const ::arangodb::InstancesCurrent& primary_dbservers() const;
  inline ::arangodb::InstancesCurrent* mutable_primary_dbservers();
  inline ::arangodb::InstancesCurrent* release_primary_dbservers();
  inline void set_allocated_primary_dbservers(::arangodb::InstancesCurrent* primary_dbservers);

  // required .arangodb.InstancesCurrent secondary_dbservers = 8;
  inline bool has_secondary_dbservers() const;
  inline void clear_secondary_dbservers();
  static const int kSecondaryDbserversFieldNumber = 8;
  inline const ::arangodb::InstancesCurrent& secondary_dbservers() const;
  inline ::arangodb::InstancesCurrent* mutable_secondary_dbservers();
  inline ::arangodb::InstancesCurrent* release_secondary_dbservers();
  inline void set_allocated_secondary_dbservers(::arangodb::InstancesCurrent* secondary_dbservers);

  // required bool agency_initialized = 9;
  inline bool has_agency_initialized() const;
  inline void clear_agency_initialized();
  static const int kAgencyInitializedFieldNumber = 9;
  inline bool agency_initialized() const;
  inline void set_agency_initialized(bool value);

  // required bool cluster_initialized = 10;
  inline bool has_cluster_initialized() const;
  inline void clear_cluster_initialized();
  static const int kClusterInitializedFieldNumber = 10;
  inline bool cluster_initialized() const;
  inline void set_cluster_initialized(bool value);

  // @@protoc_insertion_point(class_scope:arangodb.Current)
 private:
  inline void set_has_agency_resources();
  inline void clear_has_agency_resources();
  inline void set_has_coordinator_resources();
  inline void clear_has_coordinator_resources();
  inline void set_has_primary_dbserver_resources();
  inline void clear_has_primary_dbserver_resources();
  inline void set_has_secondary_dbserver_resources();
  inline void clear_has_secondary_dbserver_resources();
  inline void set_has_agents();
  inline void clear_has_agents();
  inline void set_has_coordinators();
  inline void clear_has_coordinators();
  inline void set_has_primary_dbservers();
  inline void clear_has_primary_dbservers();
  inline void set_has_secondary_dbservers();
  inline void clear_has_secondary_dbservers();
  inline void set_has_agency_initialized();
  inline void clear_has_agency_initialized();
  inline void set_has_cluster_initialized();
  inline void clear_has_cluster_initialized();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::arangodb::ResourcesCurrent* agency_resources_;
  ::arangodb::ResourcesCurrent* coordinator_resources_;
  ::arangodb::ResourcesCurrent* primary_dbserver_resources_;
  ::arangodb::ResourcesCurrent* secondary_dbserver_resources_;
  ::arangodb::InstancesCurrent* agents_;
  ::arangodb::InstancesCurrent* coordinators_;
  ::arangodb::InstancesCurrent* primary_dbservers_;
  ::arangodb::InstancesCurrent* secondary_dbservers_;
  bool agency_initialized_;
  bool cluster_initialized_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static Current* default_instance_;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  void Swap(State* other);

  // implements Message ----------------------------------------------

  State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .arangodb.Target target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::arangodb::Target& target() const;
  inline ::arangodb::Target* mutable_target();
  inline ::arangodb::Target* release_target();
  inline void set_allocated_target(::arangodb::Target* target);

  // required .arangodb.Plan plan = 3;
  inline bool has_plan() const;
  inline void clear_plan();
  static const int kPlanFieldNumber = 3;
  inline const ::arangodb::Plan& plan() const;
  inline ::arangodb::Plan* mutable_plan();
  inline ::arangodb::Plan* release_plan();
  inline void set_allocated_plan(::arangodb::Plan* plan);

  // required .arangodb.Current current = 4;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 4;
  inline const ::arangodb::Current& current() const;
  inline ::arangodb::Current* mutable_current();
  inline ::arangodb::Current* release_current();
  inline void set_allocated_current(::arangodb::Current* current);

  // @@protoc_insertion_point(class_scope:arangodb.State)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_plan();
  inline void clear_has_plan();
  inline void set_has_current();
  inline void clear_has_current();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::arangodb::Target* target_;
  ::arangodb::Plan* plan_;
  ::arangodb::Current* current_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static State* default_instance_;
};
// ===================================================================


// ===================================================================

// TargetEntry

// required uint32 instances = 1;
inline bool TargetEntry::has_instances() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetEntry::set_has_instances() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetEntry::clear_has_instances() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetEntry::clear_instances() {
  instances_ = 0u;
  clear_has_instances();
}
inline ::google::protobuf::uint32 TargetEntry::instances() const {
  return instances_;
}
inline void TargetEntry::set_instances(::google::protobuf::uint32 value) {
  set_has_instances();
  instances_ = value;
}

// repeated .mesos.Resource minimal_resources = 2;
inline int TargetEntry::minimal_resources_size() const {
  return minimal_resources_.size();
}
inline void TargetEntry::clear_minimal_resources() {
  minimal_resources_.Clear();
}
inline const ::mesos::Resource& TargetEntry::minimal_resources(int index) const {
  return minimal_resources_.Get(index);
}
inline ::mesos::Resource* TargetEntry::mutable_minimal_resources(int index) {
  return minimal_resources_.Mutable(index);
}
inline ::mesos::Resource* TargetEntry::add_minimal_resources() {
  return minimal_resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TargetEntry::minimal_resources() const {
  return minimal_resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TargetEntry::mutable_minimal_resources() {
  return &minimal_resources_;
}

// repeated .mesos.Resource additional_resouces = 3;
inline int TargetEntry::additional_resouces_size() const {
  return additional_resouces_.size();
}
inline void TargetEntry::clear_additional_resouces() {
  additional_resouces_.Clear();
}
inline const ::mesos::Resource& TargetEntry::additional_resouces(int index) const {
  return additional_resouces_.Get(index);
}
inline ::mesos::Resource* TargetEntry::mutable_additional_resouces(int index) {
  return additional_resouces_.Mutable(index);
}
inline ::mesos::Resource* TargetEntry::add_additional_resouces() {
  return additional_resouces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TargetEntry::additional_resouces() const {
  return additional_resouces_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TargetEntry::mutable_additional_resouces() {
  return &additional_resouces_;
}

// required uint32 number_ports = 4;
inline bool TargetEntry::has_number_ports() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TargetEntry::set_has_number_ports() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TargetEntry::clear_has_number_ports() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TargetEntry::clear_number_ports() {
  number_ports_ = 0u;
  clear_has_number_ports();
}
inline ::google::protobuf::uint32 TargetEntry::number_ports() const {
  return number_ports_;
}
inline void TargetEntry::set_number_ports(::google::protobuf::uint32 value) {
  set_has_number_ports();
  number_ports_ = value;
}

// -------------------------------------------------------------------

// Target

// required string mode = 1;
inline bool Target::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Target::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Target::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Target::clear_mode() {
  if (mode_ != &::google::protobuf::internal::kEmptyString) {
    mode_->clear();
  }
  clear_has_mode();
}
inline const ::std::string& Target::mode() const {
  return *mode_;
}
inline void Target::set_mode(const ::std::string& value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
}
inline void Target::set_mode(const char* value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
}
inline void Target::set_mode(const char* value, size_t size) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Target::mutable_mode() {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  return mode_;
}
inline ::std::string* Target::release_mode() {
  clear_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mode_;
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Target::set_allocated_mode(::std::string* mode) {
  if (mode_ != &::google::protobuf::internal::kEmptyString) {
    delete mode_;
  }
  if (mode) {
    set_has_mode();
    mode_ = mode;
  } else {
    clear_has_mode();
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .arangodb.TargetEntry agents = 2;
inline bool Target::has_agents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Target::set_has_agents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Target::clear_has_agents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Target::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::TargetEntry::Clear();
  clear_has_agents();
}
inline const ::arangodb::TargetEntry& Target::agents() const {
  return agents_ != NULL ? *agents_ : *default_instance_->agents_;
}
inline ::arangodb::TargetEntry* Target::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) agents_ = new ::arangodb::TargetEntry;
  return agents_;
}
inline ::arangodb::TargetEntry* Target::release_agents() {
  clear_has_agents();
  ::arangodb::TargetEntry* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Target::set_allocated_agents(::arangodb::TargetEntry* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
}

// required .arangodb.TargetEntry coordinators = 3;
inline bool Target::has_coordinators() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Target::set_has_coordinators() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Target::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Target::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::TargetEntry::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::TargetEntry& Target::coordinators() const {
  return coordinators_ != NULL ? *coordinators_ : *default_instance_->coordinators_;
}
inline ::arangodb::TargetEntry* Target::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) coordinators_ = new ::arangodb::TargetEntry;
  return coordinators_;
}
inline ::arangodb::TargetEntry* Target::release_coordinators() {
  clear_has_coordinators();
  ::arangodb::TargetEntry* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Target::set_allocated_coordinators(::arangodb::TargetEntry* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
}

// required .arangodb.TargetEntry dbservers = 4;
inline bool Target::has_dbservers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Target::set_has_dbservers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Target::clear_has_dbservers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Target::clear_dbservers() {
  if (dbservers_ != NULL) dbservers_->::arangodb::TargetEntry::Clear();
  clear_has_dbservers();
}
inline const ::arangodb::TargetEntry& Target::dbservers() const {
  return dbservers_ != NULL ? *dbservers_ : *default_instance_->dbservers_;
}
inline ::arangodb::TargetEntry* Target::mutable_dbservers() {
  set_has_dbservers();
  if (dbservers_ == NULL) dbservers_ = new ::arangodb::TargetEntry;
  return dbservers_;
}
inline ::arangodb::TargetEntry* Target::release_dbservers() {
  clear_has_dbservers();
  ::arangodb::TargetEntry* temp = dbservers_;
  dbservers_ = NULL;
  return temp;
}
inline void Target::set_allocated_dbservers(::arangodb::TargetEntry* dbservers) {
  delete dbservers_;
  dbservers_ = dbservers;
  if (dbservers) {
    set_has_dbservers();
  } else {
    clear_has_dbservers();
  }
}

// -------------------------------------------------------------------

// TasksPlanEntry

// required bool is_primary = 1;
inline bool TasksPlanEntry::has_is_primary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TasksPlanEntry::set_has_is_primary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TasksPlanEntry::clear_has_is_primary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TasksPlanEntry::clear_is_primary() {
  is_primary_ = false;
  clear_has_is_primary();
}
inline bool TasksPlanEntry::is_primary() const {
  return is_primary_;
}
inline void TasksPlanEntry::set_is_primary(bool value) {
  set_has_is_primary();
  is_primary_ = value;
}

// optional .mesos.SlaveID slave_id = 2;
inline bool TasksPlanEntry::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TasksPlanEntry::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TasksPlanEntry::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TasksPlanEntry::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TasksPlanEntry::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* TasksPlanEntry::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* TasksPlanEntry::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void TasksPlanEntry::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// optional string persistence_id = 3;
inline bool TasksPlanEntry::has_persistence_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TasksPlanEntry::set_has_persistence_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TasksPlanEntry::clear_has_persistence_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TasksPlanEntry::clear_persistence_id() {
  if (persistence_id_ != &::google::protobuf::internal::kEmptyString) {
    persistence_id_->clear();
  }
  clear_has_persistence_id();
}
inline const ::std::string& TasksPlanEntry::persistence_id() const {
  return *persistence_id_;
}
inline void TasksPlanEntry::set_persistence_id(const ::std::string& value) {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  persistence_id_->assign(value);
}
inline void TasksPlanEntry::set_persistence_id(const char* value) {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  persistence_id_->assign(value);
}
inline void TasksPlanEntry::set_persistence_id(const char* value, size_t size) {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  persistence_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TasksPlanEntry::mutable_persistence_id() {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  return persistence_id_;
}
inline ::std::string* TasksPlanEntry::release_persistence_id() {
  clear_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persistence_id_;
    persistence_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TasksPlanEntry::set_allocated_persistence_id(::std::string* persistence_id) {
  if (persistence_id_ != &::google::protobuf::internal::kEmptyString) {
    delete persistence_id_;
  }
  if (persistence_id) {
    set_has_persistence_id();
    persistence_id_ = persistence_id;
  } else {
    clear_has_persistence_id();
    persistence_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TasksPlan

// repeated .arangodb.TasksPlanEntry entries = 1;
inline int TasksPlan::entries_size() const {
  return entries_.size();
}
inline void TasksPlan::clear_entries() {
  entries_.Clear();
}
inline const ::arangodb::TasksPlanEntry& TasksPlan::entries(int index) const {
  return entries_.Get(index);
}
inline ::arangodb::TasksPlanEntry* TasksPlan::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::arangodb::TasksPlanEntry* TasksPlan::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::TasksPlanEntry >&
TasksPlan::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::TasksPlanEntry >*
TasksPlan::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// Plan

// required .arangodb.TasksPlan agents = 1;
inline bool Plan::has_agents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Plan::set_has_agents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Plan::clear_has_agents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Plan::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::TasksPlan::Clear();
  clear_has_agents();
}
inline const ::arangodb::TasksPlan& Plan::agents() const {
  return agents_ != NULL ? *agents_ : *default_instance_->agents_;
}
inline ::arangodb::TasksPlan* Plan::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) agents_ = new ::arangodb::TasksPlan;
  return agents_;
}
inline ::arangodb::TasksPlan* Plan::release_agents() {
  clear_has_agents();
  ::arangodb::TasksPlan* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Plan::set_allocated_agents(::arangodb::TasksPlan* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
}

// required .arangodb.TasksPlan coordinators = 2;
inline bool Plan::has_coordinators() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Plan::set_has_coordinators() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Plan::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Plan::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::TasksPlan::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::TasksPlan& Plan::coordinators() const {
  return coordinators_ != NULL ? *coordinators_ : *default_instance_->coordinators_;
}
inline ::arangodb::TasksPlan* Plan::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) coordinators_ = new ::arangodb::TasksPlan;
  return coordinators_;
}
inline ::arangodb::TasksPlan* Plan::release_coordinators() {
  clear_has_coordinators();
  ::arangodb::TasksPlan* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Plan::set_allocated_coordinators(::arangodb::TasksPlan* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
}

// required .arangodb.TasksPlan dbservers = 3;
inline bool Plan::has_dbservers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Plan::set_has_dbservers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Plan::clear_has_dbservers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Plan::clear_dbservers() {
  if (dbservers_ != NULL) dbservers_->::arangodb::TasksPlan::Clear();
  clear_has_dbservers();
}
inline const ::arangodb::TasksPlan& Plan::dbservers() const {
  return dbservers_ != NULL ? *dbservers_ : *default_instance_->dbservers_;
}
inline ::arangodb::TasksPlan* Plan::mutable_dbservers() {
  set_has_dbservers();
  if (dbservers_ == NULL) dbservers_ = new ::arangodb::TasksPlan;
  return dbservers_;
}
inline ::arangodb::TasksPlan* Plan::release_dbservers() {
  clear_has_dbservers();
  ::arangodb::TasksPlan* temp = dbservers_;
  dbservers_ = NULL;
  return temp;
}
inline void Plan::set_allocated_dbservers(::arangodb::TasksPlan* dbservers) {
  delete dbservers_;
  dbservers_ = dbservers;
  if (dbservers) {
    set_has_dbservers();
  } else {
    clear_has_dbservers();
  }
}

// -------------------------------------------------------------------

// ResourcesCurrentEntry

// optional .arangodb.ResourcesCurrentState state = 1 [default = RESOURCE_STATE_UNKNOWN];
inline bool ResourcesCurrentEntry::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourcesCurrentEntry::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourcesCurrentEntry::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourcesCurrentEntry::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::arangodb::ResourcesCurrentState ResourcesCurrentEntry::state() const {
  return static_cast< ::arangodb::ResourcesCurrentState >(state_);
}
inline void ResourcesCurrentEntry::set_state(::arangodb::ResourcesCurrentState value) {
  assert(::arangodb::ResourcesCurrentState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .mesos.SlaveID slave_id = 2;
inline bool ResourcesCurrentEntry::has_slave_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourcesCurrentEntry::set_has_slave_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourcesCurrentEntry::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourcesCurrentEntry::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& ResourcesCurrentEntry::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ResourcesCurrentEntry::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* ResourcesCurrentEntry::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void ResourcesCurrentEntry::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// optional .mesos.OfferID offer_id = 3;
inline bool ResourcesCurrentEntry::has_offer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourcesCurrentEntry::set_has_offer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourcesCurrentEntry::clear_has_offer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourcesCurrentEntry::clear_offer_id() {
  if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
  clear_has_offer_id();
}
inline const ::mesos::OfferID& ResourcesCurrentEntry::offer_id() const {
  return offer_id_ != NULL ? *offer_id_ : *default_instance_->offer_id_;
}
inline ::mesos::OfferID* ResourcesCurrentEntry::mutable_offer_id() {
  set_has_offer_id();
  if (offer_id_ == NULL) offer_id_ = new ::mesos::OfferID;
  return offer_id_;
}
inline ::mesos::OfferID* ResourcesCurrentEntry::release_offer_id() {
  clear_has_offer_id();
  ::mesos::OfferID* temp = offer_id_;
  offer_id_ = NULL;
  return temp;
}
inline void ResourcesCurrentEntry::set_allocated_offer_id(::mesos::OfferID* offer_id) {
  delete offer_id_;
  offer_id_ = offer_id;
  if (offer_id) {
    set_has_offer_id();
  } else {
    clear_has_offer_id();
  }
}

// repeated .mesos.Resource resources = 4;
inline int ResourcesCurrentEntry::resources_size() const {
  return resources_.size();
}
inline void ResourcesCurrentEntry::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ResourcesCurrentEntry::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* ResourcesCurrentEntry::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ResourcesCurrentEntry::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourcesCurrentEntry::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourcesCurrentEntry::mutable_resources() {
  return &resources_;
}

// repeated uint32 ports = 5;
inline int ResourcesCurrentEntry::ports_size() const {
  return ports_.size();
}
inline void ResourcesCurrentEntry::clear_ports() {
  ports_.Clear();
}
inline ::google::protobuf::uint32 ResourcesCurrentEntry::ports(int index) const {
  return ports_.Get(index);
}
inline void ResourcesCurrentEntry::set_ports(int index, ::google::protobuf::uint32 value) {
  ports_.Set(index, value);
}
inline void ResourcesCurrentEntry::add_ports(::google::protobuf::uint32 value) {
  ports_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ResourcesCurrentEntry::ports() const {
  return ports_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ResourcesCurrentEntry::mutable_ports() {
  return &ports_;
}

// optional string hostname = 6;
inline bool ResourcesCurrentEntry::has_hostname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResourcesCurrentEntry::set_has_hostname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResourcesCurrentEntry::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResourcesCurrentEntry::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& ResourcesCurrentEntry::hostname() const {
  return *hostname_;
}
inline void ResourcesCurrentEntry::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ResourcesCurrentEntry::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ResourcesCurrentEntry::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourcesCurrentEntry::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* ResourcesCurrentEntry::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourcesCurrentEntry::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string container_path = 7;
inline bool ResourcesCurrentEntry::has_container_path() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResourcesCurrentEntry::set_has_container_path() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResourcesCurrentEntry::clear_has_container_path() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResourcesCurrentEntry::clear_container_path() {
  if (container_path_ != &::google::protobuf::internal::kEmptyString) {
    container_path_->clear();
  }
  clear_has_container_path();
}
inline const ::std::string& ResourcesCurrentEntry::container_path() const {
  return *container_path_;
}
inline void ResourcesCurrentEntry::set_container_path(const ::std::string& value) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(value);
}
inline void ResourcesCurrentEntry::set_container_path(const char* value) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(value);
}
inline void ResourcesCurrentEntry::set_container_path(const char* value, size_t size) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourcesCurrentEntry::mutable_container_path() {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  return container_path_;
}
inline ::std::string* ResourcesCurrentEntry::release_container_path() {
  clear_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = container_path_;
    container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourcesCurrentEntry::set_allocated_container_path(::std::string* container_path) {
  if (container_path_ != &::google::protobuf::internal::kEmptyString) {
    delete container_path_;
  }
  if (container_path) {
    set_has_container_path();
    container_path_ = container_path;
  } else {
    clear_has_container_path();
    container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResourcesCurrent

// repeated .arangodb.ResourcesCurrentEntry entries = 1;
inline int ResourcesCurrent::entries_size() const {
  return entries_.size();
}
inline void ResourcesCurrent::clear_entries() {
  entries_.Clear();
}
inline const ::arangodb::ResourcesCurrentEntry& ResourcesCurrent::entries(int index) const {
  return entries_.Get(index);
}
inline ::arangodb::ResourcesCurrentEntry* ResourcesCurrent::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::arangodb::ResourcesCurrentEntry* ResourcesCurrent::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::ResourcesCurrentEntry >&
ResourcesCurrent::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::ResourcesCurrentEntry >*
ResourcesCurrent::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// InstancesCurrentEntry

// optional .arangodb.InstancesCurrentState state = 1 [default = INSTANCE_STATE_UNUSED];
inline bool InstancesCurrentEntry::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstancesCurrentEntry::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstancesCurrentEntry::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstancesCurrentEntry::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::arangodb::InstancesCurrentState InstancesCurrentEntry::state() const {
  return static_cast< ::arangodb::InstancesCurrentState >(state_);
}
inline void InstancesCurrentEntry::set_state(::arangodb::InstancesCurrentState value) {
  assert(::arangodb::InstancesCurrentState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .mesos.TaskInfo task_info = 2;
inline bool InstancesCurrentEntry::has_task_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstancesCurrentEntry::set_has_task_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstancesCurrentEntry::clear_has_task_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstancesCurrentEntry::clear_task_info() {
  if (task_info_ != NULL) task_info_->::mesos::TaskInfo::Clear();
  clear_has_task_info();
}
inline const ::mesos::TaskInfo& InstancesCurrentEntry::task_info() const {
  return task_info_ != NULL ? *task_info_ : *default_instance_->task_info_;
}
inline ::mesos::TaskInfo* InstancesCurrentEntry::mutable_task_info() {
  set_has_task_info();
  if (task_info_ == NULL) task_info_ = new ::mesos::TaskInfo;
  return task_info_;
}
inline ::mesos::TaskInfo* InstancesCurrentEntry::release_task_info() {
  clear_has_task_info();
  ::mesos::TaskInfo* temp = task_info_;
  task_info_ = NULL;
  return temp;
}
inline void InstancesCurrentEntry::set_allocated_task_info(::mesos::TaskInfo* task_info) {
  delete task_info_;
  task_info_ = task_info;
  if (task_info) {
    set_has_task_info();
  } else {
    clear_has_task_info();
  }
}

// optional .mesos.TaskStatus task_status = 3;
inline bool InstancesCurrentEntry::has_task_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstancesCurrentEntry::set_has_task_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstancesCurrentEntry::clear_has_task_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstancesCurrentEntry::clear_task_status() {
  if (task_status_ != NULL) task_status_->::mesos::TaskStatus::Clear();
  clear_has_task_status();
}
inline const ::mesos::TaskStatus& InstancesCurrentEntry::task_status() const {
  return task_status_ != NULL ? *task_status_ : *default_instance_->task_status_;
}
inline ::mesos::TaskStatus* InstancesCurrentEntry::mutable_task_status() {
  set_has_task_status();
  if (task_status_ == NULL) task_status_ = new ::mesos::TaskStatus;
  return task_status_;
}
inline ::mesos::TaskStatus* InstancesCurrentEntry::release_task_status() {
  clear_has_task_status();
  ::mesos::TaskStatus* temp = task_status_;
  task_status_ = NULL;
  return temp;
}
inline void InstancesCurrentEntry::set_allocated_task_status(::mesos::TaskStatus* task_status) {
  delete task_status_;
  task_status_ = task_status;
  if (task_status) {
    set_has_task_status();
  } else {
    clear_has_task_status();
  }
}

// repeated uint32 ports = 4;
inline int InstancesCurrentEntry::ports_size() const {
  return ports_.size();
}
inline void InstancesCurrentEntry::clear_ports() {
  ports_.Clear();
}
inline ::google::protobuf::uint32 InstancesCurrentEntry::ports(int index) const {
  return ports_.Get(index);
}
inline void InstancesCurrentEntry::set_ports(int index, ::google::protobuf::uint32 value) {
  ports_.Set(index, value);
}
inline void InstancesCurrentEntry::add_ports(::google::protobuf::uint32 value) {
  ports_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
InstancesCurrentEntry::ports() const {
  return ports_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
InstancesCurrentEntry::mutable_ports() {
  return &ports_;
}

// optional string hostname = 5;
inline bool InstancesCurrentEntry::has_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstancesCurrentEntry::set_has_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstancesCurrentEntry::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstancesCurrentEntry::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& InstancesCurrentEntry::hostname() const {
  return *hostname_;
}
inline void InstancesCurrentEntry::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void InstancesCurrentEntry::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void InstancesCurrentEntry::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstancesCurrentEntry::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* InstancesCurrentEntry::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstancesCurrentEntry::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InstancesCurrent

// repeated .arangodb.InstancesCurrentEntry entries = 1;
inline int InstancesCurrent::entries_size() const {
  return entries_.size();
}
inline void InstancesCurrent::clear_entries() {
  entries_.Clear();
}
inline const ::arangodb::InstancesCurrentEntry& InstancesCurrent::entries(int index) const {
  return entries_.Get(index);
}
inline ::arangodb::InstancesCurrentEntry* InstancesCurrent::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::arangodb::InstancesCurrentEntry* InstancesCurrent::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::InstancesCurrentEntry >&
InstancesCurrent::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::InstancesCurrentEntry >*
InstancesCurrent::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// Current

// required .arangodb.ResourcesCurrent agency_resources = 1;
inline bool Current::has_agency_resources() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Current::set_has_agency_resources() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Current::clear_has_agency_resources() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Current::clear_agency_resources() {
  if (agency_resources_ != NULL) agency_resources_->::arangodb::ResourcesCurrent::Clear();
  clear_has_agency_resources();
}
inline const ::arangodb::ResourcesCurrent& Current::agency_resources() const {
  return agency_resources_ != NULL ? *agency_resources_ : *default_instance_->agency_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::mutable_agency_resources() {
  set_has_agency_resources();
  if (agency_resources_ == NULL) agency_resources_ = new ::arangodb::ResourcesCurrent;
  return agency_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::release_agency_resources() {
  clear_has_agency_resources();
  ::arangodb::ResourcesCurrent* temp = agency_resources_;
  agency_resources_ = NULL;
  return temp;
}
inline void Current::set_allocated_agency_resources(::arangodb::ResourcesCurrent* agency_resources) {
  delete agency_resources_;
  agency_resources_ = agency_resources;
  if (agency_resources) {
    set_has_agency_resources();
  } else {
    clear_has_agency_resources();
  }
}

// required .arangodb.ResourcesCurrent coordinator_resources = 2;
inline bool Current::has_coordinator_resources() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Current::set_has_coordinator_resources() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Current::clear_has_coordinator_resources() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Current::clear_coordinator_resources() {
  if (coordinator_resources_ != NULL) coordinator_resources_->::arangodb::ResourcesCurrent::Clear();
  clear_has_coordinator_resources();
}
inline const ::arangodb::ResourcesCurrent& Current::coordinator_resources() const {
  return coordinator_resources_ != NULL ? *coordinator_resources_ : *default_instance_->coordinator_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::mutable_coordinator_resources() {
  set_has_coordinator_resources();
  if (coordinator_resources_ == NULL) coordinator_resources_ = new ::arangodb::ResourcesCurrent;
  return coordinator_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::release_coordinator_resources() {
  clear_has_coordinator_resources();
  ::arangodb::ResourcesCurrent* temp = coordinator_resources_;
  coordinator_resources_ = NULL;
  return temp;
}
inline void Current::set_allocated_coordinator_resources(::arangodb::ResourcesCurrent* coordinator_resources) {
  delete coordinator_resources_;
  coordinator_resources_ = coordinator_resources;
  if (coordinator_resources) {
    set_has_coordinator_resources();
  } else {
    clear_has_coordinator_resources();
  }
}

// required .arangodb.ResourcesCurrent primary_dbserver_resources = 3;
inline bool Current::has_primary_dbserver_resources() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Current::set_has_primary_dbserver_resources() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Current::clear_has_primary_dbserver_resources() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Current::clear_primary_dbserver_resources() {
  if (primary_dbserver_resources_ != NULL) primary_dbserver_resources_->::arangodb::ResourcesCurrent::Clear();
  clear_has_primary_dbserver_resources();
}
inline const ::arangodb::ResourcesCurrent& Current::primary_dbserver_resources() const {
  return primary_dbserver_resources_ != NULL ? *primary_dbserver_resources_ : *default_instance_->primary_dbserver_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::mutable_primary_dbserver_resources() {
  set_has_primary_dbserver_resources();
  if (primary_dbserver_resources_ == NULL) primary_dbserver_resources_ = new ::arangodb::ResourcesCurrent;
  return primary_dbserver_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::release_primary_dbserver_resources() {
  clear_has_primary_dbserver_resources();
  ::arangodb::ResourcesCurrent* temp = primary_dbserver_resources_;
  primary_dbserver_resources_ = NULL;
  return temp;
}
inline void Current::set_allocated_primary_dbserver_resources(::arangodb::ResourcesCurrent* primary_dbserver_resources) {
  delete primary_dbserver_resources_;
  primary_dbserver_resources_ = primary_dbserver_resources;
  if (primary_dbserver_resources) {
    set_has_primary_dbserver_resources();
  } else {
    clear_has_primary_dbserver_resources();
  }
}

// required .arangodb.ResourcesCurrent secondary_dbserver_resources = 4;
inline bool Current::has_secondary_dbserver_resources() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Current::set_has_secondary_dbserver_resources() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Current::clear_has_secondary_dbserver_resources() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Current::clear_secondary_dbserver_resources() {
  if (secondary_dbserver_resources_ != NULL) secondary_dbserver_resources_->::arangodb::ResourcesCurrent::Clear();
  clear_has_secondary_dbserver_resources();
}
inline const ::arangodb::ResourcesCurrent& Current::secondary_dbserver_resources() const {
  return secondary_dbserver_resources_ != NULL ? *secondary_dbserver_resources_ : *default_instance_->secondary_dbserver_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::mutable_secondary_dbserver_resources() {
  set_has_secondary_dbserver_resources();
  if (secondary_dbserver_resources_ == NULL) secondary_dbserver_resources_ = new ::arangodb::ResourcesCurrent;
  return secondary_dbserver_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::release_secondary_dbserver_resources() {
  clear_has_secondary_dbserver_resources();
  ::arangodb::ResourcesCurrent* temp = secondary_dbserver_resources_;
  secondary_dbserver_resources_ = NULL;
  return temp;
}
inline void Current::set_allocated_secondary_dbserver_resources(::arangodb::ResourcesCurrent* secondary_dbserver_resources) {
  delete secondary_dbserver_resources_;
  secondary_dbserver_resources_ = secondary_dbserver_resources;
  if (secondary_dbserver_resources) {
    set_has_secondary_dbserver_resources();
  } else {
    clear_has_secondary_dbserver_resources();
  }
}

// required .arangodb.InstancesCurrent agents = 5;
inline bool Current::has_agents() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Current::set_has_agents() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Current::clear_has_agents() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Current::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::InstancesCurrent::Clear();
  clear_has_agents();
}
inline const ::arangodb::InstancesCurrent& Current::agents() const {
  return agents_ != NULL ? *agents_ : *default_instance_->agents_;
}
inline ::arangodb::InstancesCurrent* Current::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) agents_ = new ::arangodb::InstancesCurrent;
  return agents_;
}
inline ::arangodb::InstancesCurrent* Current::release_agents() {
  clear_has_agents();
  ::arangodb::InstancesCurrent* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Current::set_allocated_agents(::arangodb::InstancesCurrent* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
}

// required .arangodb.InstancesCurrent coordinators = 6;
inline bool Current::has_coordinators() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Current::set_has_coordinators() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Current::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Current::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::InstancesCurrent::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::InstancesCurrent& Current::coordinators() const {
  return coordinators_ != NULL ? *coordinators_ : *default_instance_->coordinators_;
}
inline ::arangodb::InstancesCurrent* Current::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) coordinators_ = new ::arangodb::InstancesCurrent;
  return coordinators_;
}
inline ::arangodb::InstancesCurrent* Current::release_coordinators() {
  clear_has_coordinators();
  ::arangodb::InstancesCurrent* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Current::set_allocated_coordinators(::arangodb::InstancesCurrent* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
}

// required .arangodb.InstancesCurrent primary_dbservers = 7;
inline bool Current::has_primary_dbservers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Current::set_has_primary_dbservers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Current::clear_has_primary_dbservers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Current::clear_primary_dbservers() {
  if (primary_dbservers_ != NULL) primary_dbservers_->::arangodb::InstancesCurrent::Clear();
  clear_has_primary_dbservers();
}
inline const ::arangodb::InstancesCurrent& Current::primary_dbservers() const {
  return primary_dbservers_ != NULL ? *primary_dbservers_ : *default_instance_->primary_dbservers_;
}
inline ::arangodb::InstancesCurrent* Current::mutable_primary_dbservers() {
  set_has_primary_dbservers();
  if (primary_dbservers_ == NULL) primary_dbservers_ = new ::arangodb::InstancesCurrent;
  return primary_dbservers_;
}
inline ::arangodb::InstancesCurrent* Current::release_primary_dbservers() {
  clear_has_primary_dbservers();
  ::arangodb::InstancesCurrent* temp = primary_dbservers_;
  primary_dbservers_ = NULL;
  return temp;
}
inline void Current::set_allocated_primary_dbservers(::arangodb::InstancesCurrent* primary_dbservers) {
  delete primary_dbservers_;
  primary_dbservers_ = primary_dbservers;
  if (primary_dbservers) {
    set_has_primary_dbservers();
  } else {
    clear_has_primary_dbservers();
  }
}

// required .arangodb.InstancesCurrent secondary_dbservers = 8;
inline bool Current::has_secondary_dbservers() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Current::set_has_secondary_dbservers() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Current::clear_has_secondary_dbservers() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Current::clear_secondary_dbservers() {
  if (secondary_dbservers_ != NULL) secondary_dbservers_->::arangodb::InstancesCurrent::Clear();
  clear_has_secondary_dbservers();
}
inline const ::arangodb::InstancesCurrent& Current::secondary_dbservers() const {
  return secondary_dbservers_ != NULL ? *secondary_dbservers_ : *default_instance_->secondary_dbservers_;
}
inline ::arangodb::InstancesCurrent* Current::mutable_secondary_dbservers() {
  set_has_secondary_dbservers();
  if (secondary_dbservers_ == NULL) secondary_dbservers_ = new ::arangodb::InstancesCurrent;
  return secondary_dbservers_;
}
inline ::arangodb::InstancesCurrent* Current::release_secondary_dbservers() {
  clear_has_secondary_dbservers();
  ::arangodb::InstancesCurrent* temp = secondary_dbservers_;
  secondary_dbservers_ = NULL;
  return temp;
}
inline void Current::set_allocated_secondary_dbservers(::arangodb::InstancesCurrent* secondary_dbservers) {
  delete secondary_dbservers_;
  secondary_dbservers_ = secondary_dbservers;
  if (secondary_dbservers) {
    set_has_secondary_dbservers();
  } else {
    clear_has_secondary_dbservers();
  }
}

// required bool agency_initialized = 9;
inline bool Current::has_agency_initialized() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Current::set_has_agency_initialized() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Current::clear_has_agency_initialized() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Current::clear_agency_initialized() {
  agency_initialized_ = false;
  clear_has_agency_initialized();
}
inline bool Current::agency_initialized() const {
  return agency_initialized_;
}
inline void Current::set_agency_initialized(bool value) {
  set_has_agency_initialized();
  agency_initialized_ = value;
}

// required bool cluster_initialized = 10;
inline bool Current::has_cluster_initialized() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Current::set_has_cluster_initialized() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Current::clear_has_cluster_initialized() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Current::clear_cluster_initialized() {
  cluster_initialized_ = false;
  clear_has_cluster_initialized();
}
inline bool Current::cluster_initialized() const {
  return cluster_initialized_;
}
inline void Current::set_cluster_initialized(bool value) {
  set_has_cluster_initialized();
  cluster_initialized_ = value;
}

// -------------------------------------------------------------------

// State

// optional .mesos.FrameworkID framework_id = 1;
inline bool State::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void State::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& State::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* State::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* State::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void State::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .arangodb.Target target = 2;
inline bool State::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void State::clear_target() {
  if (target_ != NULL) target_->::arangodb::Target::Clear();
  clear_has_target();
}
inline const ::arangodb::Target& State::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::arangodb::Target* State::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::arangodb::Target;
  return target_;
}
inline ::arangodb::Target* State::release_target() {
  clear_has_target();
  ::arangodb::Target* temp = target_;
  target_ = NULL;
  return temp;
}
inline void State::set_allocated_target(::arangodb::Target* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// required .arangodb.Plan plan = 3;
inline bool State::has_plan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State::set_has_plan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void State::clear_has_plan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void State::clear_plan() {
  if (plan_ != NULL) plan_->::arangodb::Plan::Clear();
  clear_has_plan();
}
inline const ::arangodb::Plan& State::plan() const {
  return plan_ != NULL ? *plan_ : *default_instance_->plan_;
}
inline ::arangodb::Plan* State::mutable_plan() {
  set_has_plan();
  if (plan_ == NULL) plan_ = new ::arangodb::Plan;
  return plan_;
}
inline ::arangodb::Plan* State::release_plan() {
  clear_has_plan();
  ::arangodb::Plan* temp = plan_;
  plan_ = NULL;
  return temp;
}
inline void State::set_allocated_plan(::arangodb::Plan* plan) {
  delete plan_;
  plan_ = plan;
  if (plan) {
    set_has_plan();
  } else {
    clear_has_plan();
  }
}

// required .arangodb.Current current = 4;
inline bool State::has_current() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void State::set_has_current() {
  _has_bits_[0] |= 0x00000008u;
}
inline void State::clear_has_current() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void State::clear_current() {
  if (current_ != NULL) current_->::arangodb::Current::Clear();
  clear_has_current();
}
inline const ::arangodb::Current& State::current() const {
  return current_ != NULL ? *current_ : *default_instance_->current_;
}
inline ::arangodb::Current* State::mutable_current() {
  set_has_current();
  if (current_ == NULL) current_ = new ::arangodb::Current;
  return current_;
}
inline ::arangodb::Current* State::release_current() {
  clear_has_current();
  ::arangodb::Current* temp = current_;
  current_ = NULL;
  return temp;
}
inline void State::set_allocated_current(::arangodb::Current* current) {
  delete current_;
  current_ = current;
  if (current) {
    set_has_current();
  } else {
    clear_has_current();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace arangodb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arangodb::ResourcesCurrentState>() {
  return ::arangodb::ResourcesCurrentState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arangodb::InstancesCurrentState>() {
  return ::arangodb::InstancesCurrentState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_arangodb_2eproto__INCLUDED
