// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: arangodb.proto

#ifndef PROTOBUF_arangodb_2eproto__INCLUDED
#define PROTOBUF_arangodb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace arangodb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_arangodb_2eproto();
void protobuf_AssignDesc_arangodb_2eproto();
void protobuf_ShutdownFile_arangodb_2eproto();

class Target;
class Targets;
class TaskPlan;
class TasksPlan;
class Plan;
class TaskCurrent;
class TasksCurrent;
class Current;
class State;

enum TaskPlanState {
  TASK_STATE_NEW = 1,
  TASK_STATE_TRYING_TO_RESERVE = 2,
  TASK_STATE_TRYING_TO_PERSIST = 3,
  TASK_STATE_TRYING_TO_START = 4,
  TASK_STATE_TRYING_TO_RESTART = 5,
  TASK_STATE_RUNNING = 6,
  TASK_STATE_KILLED = 7,
  TASK_STATE_FAILED_OVER = 8,
  TASK_STATE_DEAD = 9
};
bool TaskPlanState_IsValid(int value);
const TaskPlanState TaskPlanState_MIN = TASK_STATE_NEW;
const TaskPlanState TaskPlanState_MAX = TASK_STATE_DEAD;
const int TaskPlanState_ARRAYSIZE = TaskPlanState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskPlanState_descriptor();
inline const ::std::string& TaskPlanState_Name(TaskPlanState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskPlanState_descriptor(), value);
}
inline bool TaskPlanState_Parse(
    const ::std::string& name, TaskPlanState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskPlanState>(
    TaskPlanState_descriptor(), name, value);
}
// ===================================================================

class Target : public ::google::protobuf::Message {
 public:
  Target();
  virtual ~Target();

  Target(const Target& from);

  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Target& default_instance();

  void Swap(Target* other);

  // implements Message ----------------------------------------------

  Target* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Target& from);
  void MergeFrom(const Target& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 instances = 1;
  inline bool has_instances() const;
  inline void clear_instances();
  static const int kInstancesFieldNumber = 1;
  inline ::google::protobuf::uint32 instances() const;
  inline void set_instances(::google::protobuf::uint32 value);

  // repeated .mesos.Resource minimal_resources = 2;
  inline int minimal_resources_size() const;
  inline void clear_minimal_resources();
  static const int kMinimalResourcesFieldNumber = 2;
  inline const ::mesos::Resource& minimal_resources(int index) const;
  inline ::mesos::Resource* mutable_minimal_resources(int index);
  inline ::mesos::Resource* add_minimal_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      minimal_resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_minimal_resources();

  // repeated .mesos.Resource additional_resources = 3;
  inline int additional_resources_size() const;
  inline void clear_additional_resources();
  static const int kAdditionalResourcesFieldNumber = 3;
  inline const ::mesos::Resource& additional_resources(int index) const;
  inline ::mesos::Resource* mutable_additional_resources(int index);
  inline ::mesos::Resource* add_additional_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      additional_resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_additional_resources();

  // required uint32 number_ports = 4;
  inline bool has_number_ports() const;
  inline void clear_number_ports();
  static const int kNumberPortsFieldNumber = 4;
  inline ::google::protobuf::uint32 number_ports() const;
  inline void set_number_ports(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:arangodb.Target)
 private:
  inline void set_has_instances();
  inline void clear_has_instances();
  inline void set_has_number_ports();
  inline void clear_has_number_ports();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > minimal_resources_;
  ::google::protobuf::uint32 instances_;
  ::google::protobuf::uint32 number_ports_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > additional_resources_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static Target* default_instance_;
};
// -------------------------------------------------------------------

class Targets : public ::google::protobuf::Message {
 public:
  Targets();
  virtual ~Targets();

  Targets(const Targets& from);

  inline Targets& operator=(const Targets& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Targets& default_instance();

  void Swap(Targets* other);

  // implements Message ----------------------------------------------

  Targets* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Targets& from);
  void MergeFrom(const Targets& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline const ::std::string& mode() const;
  inline void set_mode(const ::std::string& value);
  inline void set_mode(const char* value);
  inline void set_mode(const char* value, size_t size);
  inline ::std::string* mutable_mode();
  inline ::std::string* release_mode();
  inline void set_allocated_mode(::std::string* mode);

  // required .arangodb.Target agents = 2;
  inline bool has_agents() const;
  inline void clear_agents();
  static const int kAgentsFieldNumber = 2;
  inline const ::arangodb::Target& agents() const;
  inline ::arangodb::Target* mutable_agents();
  inline ::arangodb::Target* release_agents();
  inline void set_allocated_agents(::arangodb::Target* agents);

  // required .arangodb.Target coordinators = 3;
  inline bool has_coordinators() const;
  inline void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 3;
  inline const ::arangodb::Target& coordinators() const;
  inline ::arangodb::Target* mutable_coordinators();
  inline ::arangodb::Target* release_coordinators();
  inline void set_allocated_coordinators(::arangodb::Target* coordinators);

  // required .arangodb.Target dbservers = 4;
  inline bool has_dbservers() const;
  inline void clear_dbservers();
  static const int kDbserversFieldNumber = 4;
  inline const ::arangodb::Target& dbservers() const;
  inline ::arangodb::Target* mutable_dbservers();
  inline ::arangodb::Target* release_dbservers();
  inline void set_allocated_dbservers(::arangodb::Target* dbservers);

  // required .arangodb.Target secondaries = 5;
  inline bool has_secondaries() const;
  inline void clear_secondaries();
  static const int kSecondariesFieldNumber = 5;
  inline const ::arangodb::Target& secondaries() const;
  inline ::arangodb::Target* mutable_secondaries();
  inline ::arangodb::Target* release_secondaries();
  inline void set_allocated_secondaries(::arangodb::Target* secondaries);

  // optional bool asynchronous_replication = 6;
  inline bool has_asynchronous_replication() const;
  inline void clear_asynchronous_replication();
  static const int kAsynchronousReplicationFieldNumber = 6;
  inline bool asynchronous_replication() const;
  inline void set_asynchronous_replication(bool value);

  // @@protoc_insertion_point(class_scope:arangodb.Targets)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_agents();
  inline void clear_has_agents();
  inline void set_has_coordinators();
  inline void clear_has_coordinators();
  inline void set_has_dbservers();
  inline void clear_has_dbservers();
  inline void set_has_secondaries();
  inline void clear_has_secondaries();
  inline void set_has_asynchronous_replication();
  inline void clear_has_asynchronous_replication();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mode_;
  ::arangodb::Target* agents_;
  ::arangodb::Target* coordinators_;
  ::arangodb::Target* dbservers_;
  ::arangodb::Target* secondaries_;
  bool asynchronous_replication_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static Targets* default_instance_;
};
// -------------------------------------------------------------------

class TaskPlan : public ::google::protobuf::Message {
 public:
  TaskPlan();
  virtual ~TaskPlan();

  TaskPlan(const TaskPlan& from);

  inline TaskPlan& operator=(const TaskPlan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskPlan& default_instance();

  void Swap(TaskPlan* other);

  // implements Message ----------------------------------------------

  TaskPlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskPlan& from);
  void MergeFrom(const TaskPlan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .arangodb.TaskPlanState state = 1 [default = TASK_STATE_NEW];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::arangodb::TaskPlanState state() const;
  inline void set_state(::arangodb::TaskPlanState value);

  // optional string persistence_id = 2;
  inline bool has_persistence_id() const;
  inline void clear_persistence_id();
  static const int kPersistenceIdFieldNumber = 2;
  inline const ::std::string& persistence_id() const;
  inline void set_persistence_id(const ::std::string& value);
  inline void set_persistence_id(const char* value);
  inline void set_persistence_id(const char* value, size_t size);
  inline ::std::string* mutable_persistence_id();
  inline ::std::string* release_persistence_id();
  inline void set_allocated_persistence_id(::std::string* persistence_id);

  // optional double timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // required string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string sync_partner = 5;
  inline bool has_sync_partner() const;
  inline void clear_sync_partner();
  static const int kSyncPartnerFieldNumber = 5;
  inline const ::std::string& sync_partner() const;
  inline void set_sync_partner(const ::std::string& value);
  inline void set_sync_partner(const char* value);
  inline void set_sync_partner(const char* value, size_t size);
  inline ::std::string* mutable_sync_partner();
  inline ::std::string* release_sync_partner();
  inline void set_allocated_sync_partner(::std::string* sync_partner);

  // @@protoc_insertion_point(class_scope:arangodb.TaskPlan)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_persistence_id();
  inline void clear_has_persistence_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sync_partner();
  inline void clear_has_sync_partner();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* persistence_id_;
  double timestamp_;
  ::std::string* name_;
  ::std::string* sync_partner_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static TaskPlan* default_instance_;
};
// -------------------------------------------------------------------

class TasksPlan : public ::google::protobuf::Message {
 public:
  TasksPlan();
  virtual ~TasksPlan();

  TasksPlan(const TasksPlan& from);

  inline TasksPlan& operator=(const TasksPlan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TasksPlan& default_instance();

  void Swap(TasksPlan* other);

  // implements Message ----------------------------------------------

  TasksPlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TasksPlan& from);
  void MergeFrom(const TasksPlan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.TaskPlan entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::arangodb::TaskPlan& entries(int index) const;
  inline ::arangodb::TaskPlan* mutable_entries(int index);
  inline ::arangodb::TaskPlan* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:arangodb.TasksPlan)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static TasksPlan* default_instance_;
};
// -------------------------------------------------------------------

class Plan : public ::google::protobuf::Message {
 public:
  Plan();
  virtual ~Plan();

  Plan(const Plan& from);

  inline Plan& operator=(const Plan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Plan& default_instance();

  void Swap(Plan* other);

  // implements Message ----------------------------------------------

  Plan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Plan& from);
  void MergeFrom(const Plan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .arangodb.TasksPlan agents = 1;
  inline bool has_agents() const;
  inline void clear_agents();
  static const int kAgentsFieldNumber = 1;
  inline const ::arangodb::TasksPlan& agents() const;
  inline ::arangodb::TasksPlan* mutable_agents();
  inline ::arangodb::TasksPlan* release_agents();
  inline void set_allocated_agents(::arangodb::TasksPlan* agents);

  // required .arangodb.TasksPlan coordinators = 2;
  inline bool has_coordinators() const;
  inline void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 2;
  inline const ::arangodb::TasksPlan& coordinators() const;
  inline ::arangodb::TasksPlan* mutable_coordinators();
  inline ::arangodb::TasksPlan* release_coordinators();
  inline void set_allocated_coordinators(::arangodb::TasksPlan* coordinators);

  // required .arangodb.TasksPlan dbservers = 3;
  inline bool has_dbservers() const;
  inline void clear_dbservers();
  static const int kDbserversFieldNumber = 3;
  inline const ::arangodb::TasksPlan& dbservers() const;
  inline ::arangodb::TasksPlan* mutable_dbservers();
  inline ::arangodb::TasksPlan* release_dbservers();
  inline void set_allocated_dbservers(::arangodb::TasksPlan* dbservers);

  // required .arangodb.TasksPlan secondaries = 4;
  inline bool has_secondaries() const;
  inline void clear_secondaries();
  static const int kSecondariesFieldNumber = 4;
  inline const ::arangodb::TasksPlan& secondaries() const;
  inline ::arangodb::TasksPlan* mutable_secondaries();
  inline ::arangodb::TasksPlan* release_secondaries();
  inline void set_allocated_secondaries(::arangodb::TasksPlan* secondaries);

  // @@protoc_insertion_point(class_scope:arangodb.Plan)
 private:
  inline void set_has_agents();
  inline void clear_has_agents();
  inline void set_has_coordinators();
  inline void clear_has_coordinators();
  inline void set_has_dbservers();
  inline void clear_has_dbservers();
  inline void set_has_secondaries();
  inline void clear_has_secondaries();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::arangodb::TasksPlan* agents_;
  ::arangodb::TasksPlan* coordinators_;
  ::arangodb::TasksPlan* dbservers_;
  ::arangodb::TasksPlan* secondaries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static Plan* default_instance_;
};
// -------------------------------------------------------------------

class TaskCurrent : public ::google::protobuf::Message {
 public:
  TaskCurrent();
  virtual ~TaskCurrent();

  TaskCurrent(const TaskCurrent& from);

  inline TaskCurrent& operator=(const TaskCurrent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskCurrent& default_instance();

  void Swap(TaskCurrent* other);

  // implements Message ----------------------------------------------

  TaskCurrent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskCurrent& from);
  void MergeFrom(const TaskCurrent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional .mesos.OfferID offer_id = 2;
  inline bool has_offer_id() const;
  inline void clear_offer_id();
  static const int kOfferIdFieldNumber = 2;
  inline const ::mesos::OfferID& offer_id() const;
  inline ::mesos::OfferID* mutable_offer_id();
  inline ::mesos::OfferID* release_offer_id();
  inline void set_allocated_offer_id(::mesos::OfferID* offer_id);

  // repeated .mesos.Resource resources = 3;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 3;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // repeated uint32 ports = 4;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 4;
  inline ::google::protobuf::uint32 ports(int index) const;
  inline void set_ports(int index, ::google::protobuf::uint32 value);
  inline void add_ports(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ports() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ports();

  // optional string hostname = 5;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 5;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string container_path = 6;
  inline bool has_container_path() const;
  inline void clear_container_path();
  static const int kContainerPathFieldNumber = 6;
  inline const ::std::string& container_path() const;
  inline void set_container_path(const ::std::string& value);
  inline void set_container_path(const char* value);
  inline void set_container_path(const char* value, size_t size);
  inline ::std::string* mutable_container_path();
  inline ::std::string* release_container_path();
  inline void set_allocated_container_path(::std::string* container_path);

  // optional .mesos.TaskInfo task_info = 7;
  inline bool has_task_info() const;
  inline void clear_task_info();
  static const int kTaskInfoFieldNumber = 7;
  inline const ::mesos::TaskInfo& task_info() const;
  inline ::mesos::TaskInfo* mutable_task_info();
  inline ::mesos::TaskInfo* release_task_info();
  inline void set_allocated_task_info(::mesos::TaskInfo* task_info);

  // optional .mesos.TaskStatus task_status = 8;
  inline bool has_task_status() const;
  inline void clear_task_status();
  static const int kTaskStatusFieldNumber = 8;
  inline const ::mesos::TaskStatus& task_status() const;
  inline ::mesos::TaskStatus* mutable_task_status();
  inline ::mesos::TaskStatus* release_task_status();
  inline void set_allocated_task_status(::mesos::TaskStatus* task_status);

  // @@protoc_insertion_point(class_scope:arangodb.TaskCurrent)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_offer_id();
  inline void clear_has_offer_id();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_container_path();
  inline void clear_has_container_path();
  inline void set_has_task_info();
  inline void clear_has_task_info();
  inline void set_has_task_status();
  inline void clear_has_task_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::OfferID* offer_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ports_;
  ::std::string* hostname_;
  ::std::string* container_path_;
  ::mesos::TaskInfo* task_info_;
  ::mesos::TaskStatus* task_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static TaskCurrent* default_instance_;
};
// -------------------------------------------------------------------

class TasksCurrent : public ::google::protobuf::Message {
 public:
  TasksCurrent();
  virtual ~TasksCurrent();

  TasksCurrent(const TasksCurrent& from);

  inline TasksCurrent& operator=(const TasksCurrent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TasksCurrent& default_instance();

  void Swap(TasksCurrent* other);

  // implements Message ----------------------------------------------

  TasksCurrent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TasksCurrent& from);
  void MergeFrom(const TasksCurrent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.TaskCurrent entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::arangodb::TaskCurrent& entries(int index) const;
  inline ::arangodb::TaskCurrent* mutable_entries(int index);
  inline ::arangodb::TaskCurrent* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::arangodb::TaskCurrent >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::arangodb::TaskCurrent >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:arangodb.TasksCurrent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::arangodb::TaskCurrent > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static TasksCurrent* default_instance_;
};
// -------------------------------------------------------------------

class Current : public ::google::protobuf::Message {
 public:
  Current();
  virtual ~Current();

  Current(const Current& from);

  inline Current& operator=(const Current& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Current& default_instance();

  void Swap(Current* other);

  // implements Message ----------------------------------------------

  Current* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Current& from);
  void MergeFrom(const Current& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .arangodb.TasksCurrent agents = 1;
  inline bool has_agents() const;
  inline void clear_agents();
  static const int kAgentsFieldNumber = 1;
  inline const ::arangodb::TasksCurrent& agents() const;
  inline ::arangodb::TasksCurrent* mutable_agents();
  inline ::arangodb::TasksCurrent* release_agents();
  inline void set_allocated_agents(::arangodb::TasksCurrent* agents);

  // required .arangodb.TasksCurrent coordinators = 2;
  inline bool has_coordinators() const;
  inline void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 2;
  inline const ::arangodb::TasksCurrent& coordinators() const;
  inline ::arangodb::TasksCurrent* mutable_coordinators();
  inline ::arangodb::TasksCurrent* release_coordinators();
  inline void set_allocated_coordinators(::arangodb::TasksCurrent* coordinators);

  // required .arangodb.TasksCurrent dbservers = 3;
  inline bool has_dbservers() const;
  inline void clear_dbservers();
  static const int kDbserversFieldNumber = 3;
  inline const ::arangodb::TasksCurrent& dbservers() const;
  inline ::arangodb::TasksCurrent* mutable_dbservers();
  inline ::arangodb::TasksCurrent* release_dbservers();
  inline void set_allocated_dbservers(::arangodb::TasksCurrent* dbservers);

  // required .arangodb.TasksCurrent secondaries = 4;
  inline bool has_secondaries() const;
  inline void clear_secondaries();
  static const int kSecondariesFieldNumber = 4;
  inline const ::arangodb::TasksCurrent& secondaries() const;
  inline ::arangodb::TasksCurrent* mutable_secondaries();
  inline ::arangodb::TasksCurrent* release_secondaries();
  inline void set_allocated_secondaries(::arangodb::TasksCurrent* secondaries);

  // required bool cluster_complete = 5;
  inline bool has_cluster_complete() const;
  inline void clear_cluster_complete();
  static const int kClusterCompleteFieldNumber = 5;
  inline bool cluster_complete() const;
  inline void set_cluster_complete(bool value);

  // required bool cluster_bootstrappedDBservers = 6;
  inline bool has_cluster_bootstrappeddbservers() const;
  inline void clear_cluster_bootstrappeddbservers();
  static const int kClusterBootstrappedDBserversFieldNumber = 6;
  inline bool cluster_bootstrappeddbservers() const;
  inline void set_cluster_bootstrappeddbservers(bool value);

  // required bool cluster_upgradedDB = 7;
  inline bool has_cluster_upgradeddb() const;
  inline void clear_cluster_upgradeddb();
  static const int kClusterUpgradedDBFieldNumber = 7;
  inline bool cluster_upgradeddb() const;
  inline void set_cluster_upgradeddb(bool value);

  // required bool cluster_bootstrappedCoordinators = 8;
  inline bool has_cluster_bootstrappedcoordinators() const;
  inline void clear_cluster_bootstrappedcoordinators();
  static const int kClusterBootstrappedCoordinatorsFieldNumber = 8;
  inline bool cluster_bootstrappedcoordinators() const;
  inline void set_cluster_bootstrappedcoordinators(bool value);

  // required bool cluster_initialized = 9;
  inline bool has_cluster_initialized() const;
  inline void clear_cluster_initialized();
  static const int kClusterInitializedFieldNumber = 9;
  inline bool cluster_initialized() const;
  inline void set_cluster_initialized(bool value);

  // @@protoc_insertion_point(class_scope:arangodb.Current)
 private:
  inline void set_has_agents();
  inline void clear_has_agents();
  inline void set_has_coordinators();
  inline void clear_has_coordinators();
  inline void set_has_dbservers();
  inline void clear_has_dbservers();
  inline void set_has_secondaries();
  inline void clear_has_secondaries();
  inline void set_has_cluster_complete();
  inline void clear_has_cluster_complete();
  inline void set_has_cluster_bootstrappeddbservers();
  inline void clear_has_cluster_bootstrappeddbservers();
  inline void set_has_cluster_upgradeddb();
  inline void clear_has_cluster_upgradeddb();
  inline void set_has_cluster_bootstrappedcoordinators();
  inline void clear_has_cluster_bootstrappedcoordinators();
  inline void set_has_cluster_initialized();
  inline void clear_has_cluster_initialized();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::arangodb::TasksCurrent* agents_;
  ::arangodb::TasksCurrent* coordinators_;
  ::arangodb::TasksCurrent* dbservers_;
  ::arangodb::TasksCurrent* secondaries_;
  bool cluster_complete_;
  bool cluster_bootstrappeddbservers_;
  bool cluster_upgradeddb_;
  bool cluster_bootstrappedcoordinators_;
  bool cluster_initialized_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static Current* default_instance_;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  void Swap(State* other);

  // implements Message ----------------------------------------------

  State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .arangodb.Targets targets = 2;
  inline bool has_targets() const;
  inline void clear_targets();
  static const int kTargetsFieldNumber = 2;
  inline const ::arangodb::Targets& targets() const;
  inline ::arangodb::Targets* mutable_targets();
  inline ::arangodb::Targets* release_targets();
  inline void set_allocated_targets(::arangodb::Targets* targets);

  // required .arangodb.Plan plan = 3;
  inline bool has_plan() const;
  inline void clear_plan();
  static const int kPlanFieldNumber = 3;
  inline const ::arangodb::Plan& plan() const;
  inline ::arangodb::Plan* mutable_plan();
  inline ::arangodb::Plan* release_plan();
  inline void set_allocated_plan(::arangodb::Plan* plan);

  // required .arangodb.Current current = 4;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 4;
  inline const ::arangodb::Current& current() const;
  inline ::arangodb::Current* mutable_current();
  inline ::arangodb::Current* release_current();
  inline void set_allocated_current(::arangodb::Current* current);

  // @@protoc_insertion_point(class_scope:arangodb.State)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_targets();
  inline void clear_has_targets();
  inline void set_has_plan();
  inline void clear_has_plan();
  inline void set_has_current();
  inline void clear_has_current();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::arangodb::Targets* targets_;
  ::arangodb::Plan* plan_;
  ::arangodb::Current* current_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static State* default_instance_;
};
// ===================================================================


// ===================================================================

// Target

// required uint32 instances = 1;
inline bool Target::has_instances() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Target::set_has_instances() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Target::clear_has_instances() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Target::clear_instances() {
  instances_ = 0u;
  clear_has_instances();
}
inline ::google::protobuf::uint32 Target::instances() const {
  return instances_;
}
inline void Target::set_instances(::google::protobuf::uint32 value) {
  set_has_instances();
  instances_ = value;
}

// repeated .mesos.Resource minimal_resources = 2;
inline int Target::minimal_resources_size() const {
  return minimal_resources_.size();
}
inline void Target::clear_minimal_resources() {
  minimal_resources_.Clear();
}
inline const ::mesos::Resource& Target::minimal_resources(int index) const {
  return minimal_resources_.Get(index);
}
inline ::mesos::Resource* Target::mutable_minimal_resources(int index) {
  return minimal_resources_.Mutable(index);
}
inline ::mesos::Resource* Target::add_minimal_resources() {
  return minimal_resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Target::minimal_resources() const {
  return minimal_resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Target::mutable_minimal_resources() {
  return &minimal_resources_;
}

// repeated .mesos.Resource additional_resources = 3;
inline int Target::additional_resources_size() const {
  return additional_resources_.size();
}
inline void Target::clear_additional_resources() {
  additional_resources_.Clear();
}
inline const ::mesos::Resource& Target::additional_resources(int index) const {
  return additional_resources_.Get(index);
}
inline ::mesos::Resource* Target::mutable_additional_resources(int index) {
  return additional_resources_.Mutable(index);
}
inline ::mesos::Resource* Target::add_additional_resources() {
  return additional_resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Target::additional_resources() const {
  return additional_resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Target::mutable_additional_resources() {
  return &additional_resources_;
}

// required uint32 number_ports = 4;
inline bool Target::has_number_ports() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Target::set_has_number_ports() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Target::clear_has_number_ports() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Target::clear_number_ports() {
  number_ports_ = 0u;
  clear_has_number_ports();
}
inline ::google::protobuf::uint32 Target::number_ports() const {
  return number_ports_;
}
inline void Target::set_number_ports(::google::protobuf::uint32 value) {
  set_has_number_ports();
  number_ports_ = value;
}

// -------------------------------------------------------------------

// Targets

// required string mode = 1;
inline bool Targets::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Targets::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Targets::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Targets::clear_mode() {
  if (mode_ != &::google::protobuf::internal::kEmptyString) {
    mode_->clear();
  }
  clear_has_mode();
}
inline const ::std::string& Targets::mode() const {
  return *mode_;
}
inline void Targets::set_mode(const ::std::string& value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
}
inline void Targets::set_mode(const char* value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
}
inline void Targets::set_mode(const char* value, size_t size) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Targets::mutable_mode() {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  return mode_;
}
inline ::std::string* Targets::release_mode() {
  clear_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mode_;
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Targets::set_allocated_mode(::std::string* mode) {
  if (mode_ != &::google::protobuf::internal::kEmptyString) {
    delete mode_;
  }
  if (mode) {
    set_has_mode();
    mode_ = mode;
  } else {
    clear_has_mode();
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .arangodb.Target agents = 2;
inline bool Targets::has_agents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Targets::set_has_agents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Targets::clear_has_agents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Targets::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::Target::Clear();
  clear_has_agents();
}
inline const ::arangodb::Target& Targets::agents() const {
  return agents_ != NULL ? *agents_ : *default_instance_->agents_;
}
inline ::arangodb::Target* Targets::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) agents_ = new ::arangodb::Target;
  return agents_;
}
inline ::arangodb::Target* Targets::release_agents() {
  clear_has_agents();
  ::arangodb::Target* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Targets::set_allocated_agents(::arangodb::Target* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
}

// required .arangodb.Target coordinators = 3;
inline bool Targets::has_coordinators() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Targets::set_has_coordinators() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Targets::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Targets::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::Target::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::Target& Targets::coordinators() const {
  return coordinators_ != NULL ? *coordinators_ : *default_instance_->coordinators_;
}
inline ::arangodb::Target* Targets::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) coordinators_ = new ::arangodb::Target;
  return coordinators_;
}
inline ::arangodb::Target* Targets::release_coordinators() {
  clear_has_coordinators();
  ::arangodb::Target* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Targets::set_allocated_coordinators(::arangodb::Target* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
}

// required .arangodb.Target dbservers = 4;
inline bool Targets::has_dbservers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Targets::set_has_dbservers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Targets::clear_has_dbservers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Targets::clear_dbservers() {
  if (dbservers_ != NULL) dbservers_->::arangodb::Target::Clear();
  clear_has_dbservers();
}
inline const ::arangodb::Target& Targets::dbservers() const {
  return dbservers_ != NULL ? *dbservers_ : *default_instance_->dbservers_;
}
inline ::arangodb::Target* Targets::mutable_dbservers() {
  set_has_dbservers();
  if (dbservers_ == NULL) dbservers_ = new ::arangodb::Target;
  return dbservers_;
}
inline ::arangodb::Target* Targets::release_dbservers() {
  clear_has_dbservers();
  ::arangodb::Target* temp = dbservers_;
  dbservers_ = NULL;
  return temp;
}
inline void Targets::set_allocated_dbservers(::arangodb::Target* dbservers) {
  delete dbservers_;
  dbservers_ = dbservers;
  if (dbservers) {
    set_has_dbservers();
  } else {
    clear_has_dbservers();
  }
}

// required .arangodb.Target secondaries = 5;
inline bool Targets::has_secondaries() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Targets::set_has_secondaries() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Targets::clear_has_secondaries() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Targets::clear_secondaries() {
  if (secondaries_ != NULL) secondaries_->::arangodb::Target::Clear();
  clear_has_secondaries();
}
inline const ::arangodb::Target& Targets::secondaries() const {
  return secondaries_ != NULL ? *secondaries_ : *default_instance_->secondaries_;
}
inline ::arangodb::Target* Targets::mutable_secondaries() {
  set_has_secondaries();
  if (secondaries_ == NULL) secondaries_ = new ::arangodb::Target;
  return secondaries_;
}
inline ::arangodb::Target* Targets::release_secondaries() {
  clear_has_secondaries();
  ::arangodb::Target* temp = secondaries_;
  secondaries_ = NULL;
  return temp;
}
inline void Targets::set_allocated_secondaries(::arangodb::Target* secondaries) {
  delete secondaries_;
  secondaries_ = secondaries;
  if (secondaries) {
    set_has_secondaries();
  } else {
    clear_has_secondaries();
  }
}

// optional bool asynchronous_replication = 6;
inline bool Targets::has_asynchronous_replication() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Targets::set_has_asynchronous_replication() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Targets::clear_has_asynchronous_replication() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Targets::clear_asynchronous_replication() {
  asynchronous_replication_ = false;
  clear_has_asynchronous_replication();
}
inline bool Targets::asynchronous_replication() const {
  return asynchronous_replication_;
}
inline void Targets::set_asynchronous_replication(bool value) {
  set_has_asynchronous_replication();
  asynchronous_replication_ = value;
}

// -------------------------------------------------------------------

// TaskPlan

// required .arangodb.TaskPlanState state = 1 [default = TASK_STATE_NEW];
inline bool TaskPlan::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskPlan::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskPlan::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskPlan::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::arangodb::TaskPlanState TaskPlan::state() const {
  return static_cast< ::arangodb::TaskPlanState >(state_);
}
inline void TaskPlan::set_state(::arangodb::TaskPlanState value) {
  assert(::arangodb::TaskPlanState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string persistence_id = 2;
inline bool TaskPlan::has_persistence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskPlan::set_has_persistence_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskPlan::clear_has_persistence_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskPlan::clear_persistence_id() {
  if (persistence_id_ != &::google::protobuf::internal::kEmptyString) {
    persistence_id_->clear();
  }
  clear_has_persistence_id();
}
inline const ::std::string& TaskPlan::persistence_id() const {
  return *persistence_id_;
}
inline void TaskPlan::set_persistence_id(const ::std::string& value) {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  persistence_id_->assign(value);
}
inline void TaskPlan::set_persistence_id(const char* value) {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  persistence_id_->assign(value);
}
inline void TaskPlan::set_persistence_id(const char* value, size_t size) {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  persistence_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskPlan::mutable_persistence_id() {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  return persistence_id_;
}
inline ::std::string* TaskPlan::release_persistence_id() {
  clear_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persistence_id_;
    persistence_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskPlan::set_allocated_persistence_id(::std::string* persistence_id) {
  if (persistence_id_ != &::google::protobuf::internal::kEmptyString) {
    delete persistence_id_;
  }
  if (persistence_id) {
    set_has_persistence_id();
    persistence_id_ = persistence_id;
  } else {
    clear_has_persistence_id();
    persistence_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double timestamp = 3;
inline bool TaskPlan::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskPlan::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskPlan::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskPlan::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double TaskPlan::timestamp() const {
  return timestamp_;
}
inline void TaskPlan::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required string name = 4;
inline bool TaskPlan::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskPlan::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskPlan::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskPlan::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TaskPlan::name() const {
  return *name_;
}
inline void TaskPlan::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskPlan::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TaskPlan::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskPlan::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TaskPlan::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskPlan::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sync_partner = 5;
inline bool TaskPlan::has_sync_partner() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskPlan::set_has_sync_partner() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskPlan::clear_has_sync_partner() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskPlan::clear_sync_partner() {
  if (sync_partner_ != &::google::protobuf::internal::kEmptyString) {
    sync_partner_->clear();
  }
  clear_has_sync_partner();
}
inline const ::std::string& TaskPlan::sync_partner() const {
  return *sync_partner_;
}
inline void TaskPlan::set_sync_partner(const ::std::string& value) {
  set_has_sync_partner();
  if (sync_partner_ == &::google::protobuf::internal::kEmptyString) {
    sync_partner_ = new ::std::string;
  }
  sync_partner_->assign(value);
}
inline void TaskPlan::set_sync_partner(const char* value) {
  set_has_sync_partner();
  if (sync_partner_ == &::google::protobuf::internal::kEmptyString) {
    sync_partner_ = new ::std::string;
  }
  sync_partner_->assign(value);
}
inline void TaskPlan::set_sync_partner(const char* value, size_t size) {
  set_has_sync_partner();
  if (sync_partner_ == &::google::protobuf::internal::kEmptyString) {
    sync_partner_ = new ::std::string;
  }
  sync_partner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskPlan::mutable_sync_partner() {
  set_has_sync_partner();
  if (sync_partner_ == &::google::protobuf::internal::kEmptyString) {
    sync_partner_ = new ::std::string;
  }
  return sync_partner_;
}
inline ::std::string* TaskPlan::release_sync_partner() {
  clear_has_sync_partner();
  if (sync_partner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sync_partner_;
    sync_partner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskPlan::set_allocated_sync_partner(::std::string* sync_partner) {
  if (sync_partner_ != &::google::protobuf::internal::kEmptyString) {
    delete sync_partner_;
  }
  if (sync_partner) {
    set_has_sync_partner();
    sync_partner_ = sync_partner;
  } else {
    clear_has_sync_partner();
    sync_partner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TasksPlan

// repeated .arangodb.TaskPlan entries = 1;
inline int TasksPlan::entries_size() const {
  return entries_.size();
}
inline void TasksPlan::clear_entries() {
  entries_.Clear();
}
inline const ::arangodb::TaskPlan& TasksPlan::entries(int index) const {
  return entries_.Get(index);
}
inline ::arangodb::TaskPlan* TasksPlan::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::arangodb::TaskPlan* TasksPlan::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >&
TasksPlan::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >*
TasksPlan::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// Plan

// required .arangodb.TasksPlan agents = 1;
inline bool Plan::has_agents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Plan::set_has_agents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Plan::clear_has_agents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Plan::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::TasksPlan::Clear();
  clear_has_agents();
}
inline const ::arangodb::TasksPlan& Plan::agents() const {
  return agents_ != NULL ? *agents_ : *default_instance_->agents_;
}
inline ::arangodb::TasksPlan* Plan::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) agents_ = new ::arangodb::TasksPlan;
  return agents_;
}
inline ::arangodb::TasksPlan* Plan::release_agents() {
  clear_has_agents();
  ::arangodb::TasksPlan* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Plan::set_allocated_agents(::arangodb::TasksPlan* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
}

// required .arangodb.TasksPlan coordinators = 2;
inline bool Plan::has_coordinators() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Plan::set_has_coordinators() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Plan::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Plan::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::TasksPlan::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::TasksPlan& Plan::coordinators() const {
  return coordinators_ != NULL ? *coordinators_ : *default_instance_->coordinators_;
}
inline ::arangodb::TasksPlan* Plan::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) coordinators_ = new ::arangodb::TasksPlan;
  return coordinators_;
}
inline ::arangodb::TasksPlan* Plan::release_coordinators() {
  clear_has_coordinators();
  ::arangodb::TasksPlan* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Plan::set_allocated_coordinators(::arangodb::TasksPlan* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
}

// required .arangodb.TasksPlan dbservers = 3;
inline bool Plan::has_dbservers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Plan::set_has_dbservers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Plan::clear_has_dbservers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Plan::clear_dbservers() {
  if (dbservers_ != NULL) dbservers_->::arangodb::TasksPlan::Clear();
  clear_has_dbservers();
}
inline const ::arangodb::TasksPlan& Plan::dbservers() const {
  return dbservers_ != NULL ? *dbservers_ : *default_instance_->dbservers_;
}
inline ::arangodb::TasksPlan* Plan::mutable_dbservers() {
  set_has_dbservers();
  if (dbservers_ == NULL) dbservers_ = new ::arangodb::TasksPlan;
  return dbservers_;
}
inline ::arangodb::TasksPlan* Plan::release_dbservers() {
  clear_has_dbservers();
  ::arangodb::TasksPlan* temp = dbservers_;
  dbservers_ = NULL;
  return temp;
}
inline void Plan::set_allocated_dbservers(::arangodb::TasksPlan* dbservers) {
  delete dbservers_;
  dbservers_ = dbservers;
  if (dbservers) {
    set_has_dbservers();
  } else {
    clear_has_dbservers();
  }
}

// required .arangodb.TasksPlan secondaries = 4;
inline bool Plan::has_secondaries() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Plan::set_has_secondaries() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Plan::clear_has_secondaries() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Plan::clear_secondaries() {
  if (secondaries_ != NULL) secondaries_->::arangodb::TasksPlan::Clear();
  clear_has_secondaries();
}
inline const ::arangodb::TasksPlan& Plan::secondaries() const {
  return secondaries_ != NULL ? *secondaries_ : *default_instance_->secondaries_;
}
inline ::arangodb::TasksPlan* Plan::mutable_secondaries() {
  set_has_secondaries();
  if (secondaries_ == NULL) secondaries_ = new ::arangodb::TasksPlan;
  return secondaries_;
}
inline ::arangodb::TasksPlan* Plan::release_secondaries() {
  clear_has_secondaries();
  ::arangodb::TasksPlan* temp = secondaries_;
  secondaries_ = NULL;
  return temp;
}
inline void Plan::set_allocated_secondaries(::arangodb::TasksPlan* secondaries) {
  delete secondaries_;
  secondaries_ = secondaries;
  if (secondaries) {
    set_has_secondaries();
  } else {
    clear_has_secondaries();
  }
}

// -------------------------------------------------------------------

// TaskCurrent

// optional .mesos.SlaveID slave_id = 1;
inline bool TaskCurrent::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskCurrent::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskCurrent::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskCurrent::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& TaskCurrent::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* TaskCurrent::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* TaskCurrent::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void TaskCurrent::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// optional .mesos.OfferID offer_id = 2;
inline bool TaskCurrent::has_offer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskCurrent::set_has_offer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskCurrent::clear_has_offer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskCurrent::clear_offer_id() {
  if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
  clear_has_offer_id();
}
inline const ::mesos::OfferID& TaskCurrent::offer_id() const {
  return offer_id_ != NULL ? *offer_id_ : *default_instance_->offer_id_;
}
inline ::mesos::OfferID* TaskCurrent::mutable_offer_id() {
  set_has_offer_id();
  if (offer_id_ == NULL) offer_id_ = new ::mesos::OfferID;
  return offer_id_;
}
inline ::mesos::OfferID* TaskCurrent::release_offer_id() {
  clear_has_offer_id();
  ::mesos::OfferID* temp = offer_id_;
  offer_id_ = NULL;
  return temp;
}
inline void TaskCurrent::set_allocated_offer_id(::mesos::OfferID* offer_id) {
  delete offer_id_;
  offer_id_ = offer_id;
  if (offer_id) {
    set_has_offer_id();
  } else {
    clear_has_offer_id();
  }
}

// repeated .mesos.Resource resources = 3;
inline int TaskCurrent::resources_size() const {
  return resources_.size();
}
inline void TaskCurrent::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& TaskCurrent::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* TaskCurrent::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* TaskCurrent::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TaskCurrent::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TaskCurrent::mutable_resources() {
  return &resources_;
}

// repeated uint32 ports = 4;
inline int TaskCurrent::ports_size() const {
  return ports_.size();
}
inline void TaskCurrent::clear_ports() {
  ports_.Clear();
}
inline ::google::protobuf::uint32 TaskCurrent::ports(int index) const {
  return ports_.Get(index);
}
inline void TaskCurrent::set_ports(int index, ::google::protobuf::uint32 value) {
  ports_.Set(index, value);
}
inline void TaskCurrent::add_ports(::google::protobuf::uint32 value) {
  ports_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TaskCurrent::ports() const {
  return ports_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TaskCurrent::mutable_ports() {
  return &ports_;
}

// optional string hostname = 5;
inline bool TaskCurrent::has_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskCurrent::set_has_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskCurrent::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskCurrent::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& TaskCurrent::hostname() const {
  return *hostname_;
}
inline void TaskCurrent::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void TaskCurrent::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void TaskCurrent::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskCurrent::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* TaskCurrent::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskCurrent::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string container_path = 6;
inline bool TaskCurrent::has_container_path() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskCurrent::set_has_container_path() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskCurrent::clear_has_container_path() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskCurrent::clear_container_path() {
  if (container_path_ != &::google::protobuf::internal::kEmptyString) {
    container_path_->clear();
  }
  clear_has_container_path();
}
inline const ::std::string& TaskCurrent::container_path() const {
  return *container_path_;
}
inline void TaskCurrent::set_container_path(const ::std::string& value) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(value);
}
inline void TaskCurrent::set_container_path(const char* value) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(value);
}
inline void TaskCurrent::set_container_path(const char* value, size_t size) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskCurrent::mutable_container_path() {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  return container_path_;
}
inline ::std::string* TaskCurrent::release_container_path() {
  clear_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = container_path_;
    container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskCurrent::set_allocated_container_path(::std::string* container_path) {
  if (container_path_ != &::google::protobuf::internal::kEmptyString) {
    delete container_path_;
  }
  if (container_path) {
    set_has_container_path();
    container_path_ = container_path;
  } else {
    clear_has_container_path();
    container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mesos.TaskInfo task_info = 7;
inline bool TaskCurrent::has_task_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskCurrent::set_has_task_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskCurrent::clear_has_task_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskCurrent::clear_task_info() {
  if (task_info_ != NULL) task_info_->::mesos::TaskInfo::Clear();
  clear_has_task_info();
}
inline const ::mesos::TaskInfo& TaskCurrent::task_info() const {
  return task_info_ != NULL ? *task_info_ : *default_instance_->task_info_;
}
inline ::mesos::TaskInfo* TaskCurrent::mutable_task_info() {
  set_has_task_info();
  if (task_info_ == NULL) task_info_ = new ::mesos::TaskInfo;
  return task_info_;
}
inline ::mesos::TaskInfo* TaskCurrent::release_task_info() {
  clear_has_task_info();
  ::mesos::TaskInfo* temp = task_info_;
  task_info_ = NULL;
  return temp;
}
inline void TaskCurrent::set_allocated_task_info(::mesos::TaskInfo* task_info) {
  delete task_info_;
  task_info_ = task_info;
  if (task_info) {
    set_has_task_info();
  } else {
    clear_has_task_info();
  }
}

// optional .mesos.TaskStatus task_status = 8;
inline bool TaskCurrent::has_task_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TaskCurrent::set_has_task_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TaskCurrent::clear_has_task_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TaskCurrent::clear_task_status() {
  if (task_status_ != NULL) task_status_->::mesos::TaskStatus::Clear();
  clear_has_task_status();
}
inline const ::mesos::TaskStatus& TaskCurrent::task_status() const {
  return task_status_ != NULL ? *task_status_ : *default_instance_->task_status_;
}
inline ::mesos::TaskStatus* TaskCurrent::mutable_task_status() {
  set_has_task_status();
  if (task_status_ == NULL) task_status_ = new ::mesos::TaskStatus;
  return task_status_;
}
inline ::mesos::TaskStatus* TaskCurrent::release_task_status() {
  clear_has_task_status();
  ::mesos::TaskStatus* temp = task_status_;
  task_status_ = NULL;
  return temp;
}
inline void TaskCurrent::set_allocated_task_status(::mesos::TaskStatus* task_status) {
  delete task_status_;
  task_status_ = task_status;
  if (task_status) {
    set_has_task_status();
  } else {
    clear_has_task_status();
  }
}

// -------------------------------------------------------------------

// TasksCurrent

// repeated .arangodb.TaskCurrent entries = 1;
inline int TasksCurrent::entries_size() const {
  return entries_.size();
}
inline void TasksCurrent::clear_entries() {
  entries_.Clear();
}
inline const ::arangodb::TaskCurrent& TasksCurrent::entries(int index) const {
  return entries_.Get(index);
}
inline ::arangodb::TaskCurrent* TasksCurrent::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::arangodb::TaskCurrent* TasksCurrent::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::TaskCurrent >&
TasksCurrent::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::TaskCurrent >*
TasksCurrent::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// Current

// required .arangodb.TasksCurrent agents = 1;
inline bool Current::has_agents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Current::set_has_agents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Current::clear_has_agents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Current::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::TasksCurrent::Clear();
  clear_has_agents();
}
inline const ::arangodb::TasksCurrent& Current::agents() const {
  return agents_ != NULL ? *agents_ : *default_instance_->agents_;
}
inline ::arangodb::TasksCurrent* Current::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) agents_ = new ::arangodb::TasksCurrent;
  return agents_;
}
inline ::arangodb::TasksCurrent* Current::release_agents() {
  clear_has_agents();
  ::arangodb::TasksCurrent* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Current::set_allocated_agents(::arangodb::TasksCurrent* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
}

// required .arangodb.TasksCurrent coordinators = 2;
inline bool Current::has_coordinators() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Current::set_has_coordinators() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Current::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Current::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::TasksCurrent::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::TasksCurrent& Current::coordinators() const {
  return coordinators_ != NULL ? *coordinators_ : *default_instance_->coordinators_;
}
inline ::arangodb::TasksCurrent* Current::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) coordinators_ = new ::arangodb::TasksCurrent;
  return coordinators_;
}
inline ::arangodb::TasksCurrent* Current::release_coordinators() {
  clear_has_coordinators();
  ::arangodb::TasksCurrent* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Current::set_allocated_coordinators(::arangodb::TasksCurrent* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
}

// required .arangodb.TasksCurrent dbservers = 3;
inline bool Current::has_dbservers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Current::set_has_dbservers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Current::clear_has_dbservers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Current::clear_dbservers() {
  if (dbservers_ != NULL) dbservers_->::arangodb::TasksCurrent::Clear();
  clear_has_dbservers();
}
inline const ::arangodb::TasksCurrent& Current::dbservers() const {
  return dbservers_ != NULL ? *dbservers_ : *default_instance_->dbservers_;
}
inline ::arangodb::TasksCurrent* Current::mutable_dbservers() {
  set_has_dbservers();
  if (dbservers_ == NULL) dbservers_ = new ::arangodb::TasksCurrent;
  return dbservers_;
}
inline ::arangodb::TasksCurrent* Current::release_dbservers() {
  clear_has_dbservers();
  ::arangodb::TasksCurrent* temp = dbservers_;
  dbservers_ = NULL;
  return temp;
}
inline void Current::set_allocated_dbservers(::arangodb::TasksCurrent* dbservers) {
  delete dbservers_;
  dbservers_ = dbservers;
  if (dbservers) {
    set_has_dbservers();
  } else {
    clear_has_dbservers();
  }
}

// required .arangodb.TasksCurrent secondaries = 4;
inline bool Current::has_secondaries() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Current::set_has_secondaries() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Current::clear_has_secondaries() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Current::clear_secondaries() {
  if (secondaries_ != NULL) secondaries_->::arangodb::TasksCurrent::Clear();
  clear_has_secondaries();
}
inline const ::arangodb::TasksCurrent& Current::secondaries() const {
  return secondaries_ != NULL ? *secondaries_ : *default_instance_->secondaries_;
}
inline ::arangodb::TasksCurrent* Current::mutable_secondaries() {
  set_has_secondaries();
  if (secondaries_ == NULL) secondaries_ = new ::arangodb::TasksCurrent;
  return secondaries_;
}
inline ::arangodb::TasksCurrent* Current::release_secondaries() {
  clear_has_secondaries();
  ::arangodb::TasksCurrent* temp = secondaries_;
  secondaries_ = NULL;
  return temp;
}
inline void Current::set_allocated_secondaries(::arangodb::TasksCurrent* secondaries) {
  delete secondaries_;
  secondaries_ = secondaries;
  if (secondaries) {
    set_has_secondaries();
  } else {
    clear_has_secondaries();
  }
}

// required bool cluster_complete = 5;
inline bool Current::has_cluster_complete() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Current::set_has_cluster_complete() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Current::clear_has_cluster_complete() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Current::clear_cluster_complete() {
  cluster_complete_ = false;
  clear_has_cluster_complete();
}
inline bool Current::cluster_complete() const {
  return cluster_complete_;
}
inline void Current::set_cluster_complete(bool value) {
  set_has_cluster_complete();
  cluster_complete_ = value;
}

// required bool cluster_bootstrappedDBservers = 6;
inline bool Current::has_cluster_bootstrappeddbservers() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Current::set_has_cluster_bootstrappeddbservers() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Current::clear_has_cluster_bootstrappeddbservers() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Current::clear_cluster_bootstrappeddbservers() {
  cluster_bootstrappeddbservers_ = false;
  clear_has_cluster_bootstrappeddbservers();
}
inline bool Current::cluster_bootstrappeddbservers() const {
  return cluster_bootstrappeddbservers_;
}
inline void Current::set_cluster_bootstrappeddbservers(bool value) {
  set_has_cluster_bootstrappeddbservers();
  cluster_bootstrappeddbservers_ = value;
}

// required bool cluster_upgradedDB = 7;
inline bool Current::has_cluster_upgradeddb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Current::set_has_cluster_upgradeddb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Current::clear_has_cluster_upgradeddb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Current::clear_cluster_upgradeddb() {
  cluster_upgradeddb_ = false;
  clear_has_cluster_upgradeddb();
}
inline bool Current::cluster_upgradeddb() const {
  return cluster_upgradeddb_;
}
inline void Current::set_cluster_upgradeddb(bool value) {
  set_has_cluster_upgradeddb();
  cluster_upgradeddb_ = value;
}

// required bool cluster_bootstrappedCoordinators = 8;
inline bool Current::has_cluster_bootstrappedcoordinators() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Current::set_has_cluster_bootstrappedcoordinators() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Current::clear_has_cluster_bootstrappedcoordinators() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Current::clear_cluster_bootstrappedcoordinators() {
  cluster_bootstrappedcoordinators_ = false;
  clear_has_cluster_bootstrappedcoordinators();
}
inline bool Current::cluster_bootstrappedcoordinators() const {
  return cluster_bootstrappedcoordinators_;
}
inline void Current::set_cluster_bootstrappedcoordinators(bool value) {
  set_has_cluster_bootstrappedcoordinators();
  cluster_bootstrappedcoordinators_ = value;
}

// required bool cluster_initialized = 9;
inline bool Current::has_cluster_initialized() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Current::set_has_cluster_initialized() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Current::clear_has_cluster_initialized() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Current::clear_cluster_initialized() {
  cluster_initialized_ = false;
  clear_has_cluster_initialized();
}
inline bool Current::cluster_initialized() const {
  return cluster_initialized_;
}
inline void Current::set_cluster_initialized(bool value) {
  set_has_cluster_initialized();
  cluster_initialized_ = value;
}

// -------------------------------------------------------------------

// State

// optional .mesos.FrameworkID framework_id = 1;
inline bool State::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void State::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& State::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* State::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* State::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void State::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .arangodb.Targets targets = 2;
inline bool State::has_targets() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::set_has_targets() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State::clear_has_targets() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void State::clear_targets() {
  if (targets_ != NULL) targets_->::arangodb::Targets::Clear();
  clear_has_targets();
}
inline const ::arangodb::Targets& State::targets() const {
  return targets_ != NULL ? *targets_ : *default_instance_->targets_;
}
inline ::arangodb::Targets* State::mutable_targets() {
  set_has_targets();
  if (targets_ == NULL) targets_ = new ::arangodb::Targets;
  return targets_;
}
inline ::arangodb::Targets* State::release_targets() {
  clear_has_targets();
  ::arangodb::Targets* temp = targets_;
  targets_ = NULL;
  return temp;
}
inline void State::set_allocated_targets(::arangodb::Targets* targets) {
  delete targets_;
  targets_ = targets;
  if (targets) {
    set_has_targets();
  } else {
    clear_has_targets();
  }
}

// required .arangodb.Plan plan = 3;
inline bool State::has_plan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State::set_has_plan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void State::clear_has_plan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void State::clear_plan() {
  if (plan_ != NULL) plan_->::arangodb::Plan::Clear();
  clear_has_plan();
}
inline const ::arangodb::Plan& State::plan() const {
  return plan_ != NULL ? *plan_ : *default_instance_->plan_;
}
inline ::arangodb::Plan* State::mutable_plan() {
  set_has_plan();
  if (plan_ == NULL) plan_ = new ::arangodb::Plan;
  return plan_;
}
inline ::arangodb::Plan* State::release_plan() {
  clear_has_plan();
  ::arangodb::Plan* temp = plan_;
  plan_ = NULL;
  return temp;
}
inline void State::set_allocated_plan(::arangodb::Plan* plan) {
  delete plan_;
  plan_ = plan;
  if (plan) {
    set_has_plan();
  } else {
    clear_has_plan();
  }
}

// required .arangodb.Current current = 4;
inline bool State::has_current() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void State::set_has_current() {
  _has_bits_[0] |= 0x00000008u;
}
inline void State::clear_has_current() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void State::clear_current() {
  if (current_ != NULL) current_->::arangodb::Current::Clear();
  clear_has_current();
}
inline const ::arangodb::Current& State::current() const {
  return current_ != NULL ? *current_ : *default_instance_->current_;
}
inline ::arangodb::Current* State::mutable_current() {
  set_has_current();
  if (current_ == NULL) current_ = new ::arangodb::Current;
  return current_;
}
inline ::arangodb::Current* State::release_current() {
  clear_has_current();
  ::arangodb::Current* temp = current_;
  current_ = NULL;
  return temp;
}
inline void State::set_allocated_current(::arangodb::Current* current) {
  delete current_;
  current_ = current;
  if (current) {
    set_has_current();
  } else {
    clear_has_current();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace arangodb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arangodb::TaskPlanState>() {
  return ::arangodb::TaskPlanState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_arangodb_2eproto__INCLUDED
