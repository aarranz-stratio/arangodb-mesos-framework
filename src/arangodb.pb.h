// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: arangodb.proto

#ifndef PROTOBUF_arangodb_2eproto__INCLUDED
#define PROTOBUF_arangodb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mesos/mesos.pb.h"
// @@protoc_insertion_point(includes)

namespace arangodb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_arangodb_2eproto();
void protobuf_AssignDesc_arangodb_2eproto();
void protobuf_ShutdownFile_arangodb_2eproto();

class Target;
class Targets;
class TaskPlan;
class TasksPlan;
class Plan;
class ResourceCurrent;
class ResourcesCurrent;
class InstanceCurrent;
class InstancesCurrent;
class Current;
class State;

enum TaskPlanState {
  TASK_STATE_NEW = 1,
  TASK_STATE_TRYING_TO_RESERVE = 2,
  TASK_STATE_TRYING_TO_PERSIST = 3,
  TASK_STATE_TRYING_TO_START = 4,
  TASK_STATE_TRYING_TO_RESTART = 5,
  TASK_STATE_RUNNING = 6,
  TASK_STATE_KILLED = 7,
  TASK_STATE_FAILED_OVER = 8
};
bool TaskPlanState_IsValid(int value);
const TaskPlanState TaskPlanState_MIN = TASK_STATE_NEW;
const TaskPlanState TaskPlanState_MAX = TASK_STATE_FAILED_OVER;
const int TaskPlanState_ARRAYSIZE = TaskPlanState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskPlanState_descriptor();
inline const ::std::string& TaskPlanState_Name(TaskPlanState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskPlanState_descriptor(), value);
}
inline bool TaskPlanState_Parse(
    const ::std::string& name, TaskPlanState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskPlanState>(
    TaskPlanState_descriptor(), name, value);
}
enum InstanceCurrentState {
  INSTANCE_STATE_UNUSED = 1,
  INSTANCE_STATE_STARTING = 2,
  INSTANCE_STATE_RUNNING = 3,
  INSTANCE_STATE_STOPPED = 4
};
bool InstanceCurrentState_IsValid(int value);
const InstanceCurrentState InstanceCurrentState_MIN = INSTANCE_STATE_UNUSED;
const InstanceCurrentState InstanceCurrentState_MAX = INSTANCE_STATE_STOPPED;
const int InstanceCurrentState_ARRAYSIZE = InstanceCurrentState_MAX + 1;

const ::google::protobuf::EnumDescriptor* InstanceCurrentState_descriptor();
inline const ::std::string& InstanceCurrentState_Name(InstanceCurrentState value) {
  return ::google::protobuf::internal::NameOfEnum(
    InstanceCurrentState_descriptor(), value);
}
inline bool InstanceCurrentState_Parse(
    const ::std::string& name, InstanceCurrentState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InstanceCurrentState>(
    InstanceCurrentState_descriptor(), name, value);
}
// ===================================================================

class Target : public ::google::protobuf::Message {
 public:
  Target();
  virtual ~Target();

  Target(const Target& from);

  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Target& default_instance();

  void Swap(Target* other);

  // implements Message ----------------------------------------------

  Target* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Target& from);
  void MergeFrom(const Target& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 instances = 1;
  inline bool has_instances() const;
  inline void clear_instances();
  static const int kInstancesFieldNumber = 1;
  inline ::google::protobuf::uint32 instances() const;
  inline void set_instances(::google::protobuf::uint32 value);

  // repeated .mesos.Resource minimal_resources = 2;
  inline int minimal_resources_size() const;
  inline void clear_minimal_resources();
  static const int kMinimalResourcesFieldNumber = 2;
  inline const ::mesos::Resource& minimal_resources(int index) const;
  inline ::mesos::Resource* mutable_minimal_resources(int index);
  inline ::mesos::Resource* add_minimal_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      minimal_resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_minimal_resources();

  // repeated .mesos.Resource additional_resources = 3;
  inline int additional_resources_size() const;
  inline void clear_additional_resources();
  static const int kAdditionalResourcesFieldNumber = 3;
  inline const ::mesos::Resource& additional_resources(int index) const;
  inline ::mesos::Resource* mutable_additional_resources(int index);
  inline ::mesos::Resource* add_additional_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      additional_resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_additional_resources();

  // required uint32 number_ports = 4;
  inline bool has_number_ports() const;
  inline void clear_number_ports();
  static const int kNumberPortsFieldNumber = 4;
  inline ::google::protobuf::uint32 number_ports() const;
  inline void set_number_ports(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:arangodb.Target)
 private:
  inline void set_has_instances();
  inline void clear_has_instances();
  inline void set_has_number_ports();
  inline void clear_has_number_ports();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > minimal_resources_;
  ::google::protobuf::uint32 instances_;
  ::google::protobuf::uint32 number_ports_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > additional_resources_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static Target* default_instance_;
};
// -------------------------------------------------------------------

class Targets : public ::google::protobuf::Message {
 public:
  Targets();
  virtual ~Targets();

  Targets(const Targets& from);

  inline Targets& operator=(const Targets& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Targets& default_instance();

  void Swap(Targets* other);

  // implements Message ----------------------------------------------

  Targets* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Targets& from);
  void MergeFrom(const Targets& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline const ::std::string& mode() const;
  inline void set_mode(const ::std::string& value);
  inline void set_mode(const char* value);
  inline void set_mode(const char* value, size_t size);
  inline ::std::string* mutable_mode();
  inline ::std::string* release_mode();
  inline void set_allocated_mode(::std::string* mode);

  // required .arangodb.Target agents = 2;
  inline bool has_agents() const;
  inline void clear_agents();
  static const int kAgentsFieldNumber = 2;
  inline const ::arangodb::Target& agents() const;
  inline ::arangodb::Target* mutable_agents();
  inline ::arangodb::Target* release_agents();
  inline void set_allocated_agents(::arangodb::Target* agents);

  // required .arangodb.Target coordinators = 3;
  inline bool has_coordinators() const;
  inline void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 3;
  inline const ::arangodb::Target& coordinators() const;
  inline ::arangodb::Target* mutable_coordinators();
  inline ::arangodb::Target* release_coordinators();
  inline void set_allocated_coordinators(::arangodb::Target* coordinators);

  // required .arangodb.Target dbservers = 4;
  inline bool has_dbservers() const;
  inline void clear_dbservers();
  static const int kDbserversFieldNumber = 4;
  inline const ::arangodb::Target& dbservers() const;
  inline ::arangodb::Target* mutable_dbservers();
  inline ::arangodb::Target* release_dbservers();
  inline void set_allocated_dbservers(::arangodb::Target* dbservers);

  // required .arangodb.Target secondaries = 5;
  inline bool has_secondaries() const;
  inline void clear_secondaries();
  static const int kSecondariesFieldNumber = 5;
  inline const ::arangodb::Target& secondaries() const;
  inline ::arangodb::Target* mutable_secondaries();
  inline ::arangodb::Target* release_secondaries();
  inline void set_allocated_secondaries(::arangodb::Target* secondaries);

  // optional bool asynchronous_replication = 6;
  inline bool has_asynchronous_replication() const;
  inline void clear_asynchronous_replication();
  static const int kAsynchronousReplicationFieldNumber = 6;
  inline bool asynchronous_replication() const;
  inline void set_asynchronous_replication(bool value);

  // @@protoc_insertion_point(class_scope:arangodb.Targets)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_agents();
  inline void clear_has_agents();
  inline void set_has_coordinators();
  inline void clear_has_coordinators();
  inline void set_has_dbservers();
  inline void clear_has_dbservers();
  inline void set_has_secondaries();
  inline void clear_has_secondaries();
  inline void set_has_asynchronous_replication();
  inline void clear_has_asynchronous_replication();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mode_;
  ::arangodb::Target* agents_;
  ::arangodb::Target* coordinators_;
  ::arangodb::Target* dbservers_;
  ::arangodb::Target* secondaries_;
  bool asynchronous_replication_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static Targets* default_instance_;
};
// -------------------------------------------------------------------

class TaskPlan : public ::google::protobuf::Message {
 public:
  TaskPlan();
  virtual ~TaskPlan();

  TaskPlan(const TaskPlan& from);

  inline TaskPlan& operator=(const TaskPlan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskPlan& default_instance();

  void Swap(TaskPlan* other);

  // implements Message ----------------------------------------------

  TaskPlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskPlan& from);
  void MergeFrom(const TaskPlan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .arangodb.TaskPlanState state = 1 [default = TASK_STATE_NEW];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::arangodb::TaskPlanState state() const;
  inline void set_state(::arangodb::TaskPlanState value);

  // required bool is_primary = 2;
  inline bool has_is_primary() const;
  inline void clear_is_primary();
  static const int kIsPrimaryFieldNumber = 2;
  inline bool is_primary() const;
  inline void set_is_primary(bool value);

  // optional string persistence_id = 3;
  inline bool has_persistence_id() const;
  inline void clear_persistence_id();
  static const int kPersistenceIdFieldNumber = 3;
  inline const ::std::string& persistence_id() const;
  inline void set_persistence_id(const ::std::string& value);
  inline void set_persistence_id(const char* value);
  inline void set_persistence_id(const char* value, size_t size);
  inline ::std::string* mutable_persistence_id();
  inline ::std::string* release_persistence_id();
  inline void set_allocated_persistence_id(::std::string* persistence_id);

  // required double started = 4;
  inline bool has_started() const;
  inline void clear_started();
  static const int kStartedFieldNumber = 4;
  inline double started() const;
  inline void set_started(double value);

  // @@protoc_insertion_point(class_scope:arangodb.TaskPlan)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_is_primary();
  inline void clear_has_is_primary();
  inline void set_has_persistence_id();
  inline void clear_has_persistence_id();
  inline void set_has_started();
  inline void clear_has_started();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;
  bool is_primary_;
  ::std::string* persistence_id_;
  double started_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static TaskPlan* default_instance_;
};
// -------------------------------------------------------------------

class TasksPlan : public ::google::protobuf::Message {
 public:
  TasksPlan();
  virtual ~TasksPlan();

  TasksPlan(const TasksPlan& from);

  inline TasksPlan& operator=(const TasksPlan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TasksPlan& default_instance();

  void Swap(TasksPlan* other);

  // implements Message ----------------------------------------------

  TasksPlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TasksPlan& from);
  void MergeFrom(const TasksPlan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.TaskPlan entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::arangodb::TaskPlan& entries(int index) const;
  inline ::arangodb::TaskPlan* mutable_entries(int index);
  inline ::arangodb::TaskPlan* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:arangodb.TasksPlan)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static TasksPlan* default_instance_;
};
// -------------------------------------------------------------------

class Plan : public ::google::protobuf::Message {
 public:
  Plan();
  virtual ~Plan();

  Plan(const Plan& from);

  inline Plan& operator=(const Plan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Plan& default_instance();

  void Swap(Plan* other);

  // implements Message ----------------------------------------------

  Plan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Plan& from);
  void MergeFrom(const Plan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .arangodb.TasksPlan agents = 1;
  inline bool has_agents() const;
  inline void clear_agents();
  static const int kAgentsFieldNumber = 1;
  inline const ::arangodb::TasksPlan& agents() const;
  inline ::arangodb::TasksPlan* mutable_agents();
  inline ::arangodb::TasksPlan* release_agents();
  inline void set_allocated_agents(::arangodb::TasksPlan* agents);

  // required .arangodb.TasksPlan coordinators = 2;
  inline bool has_coordinators() const;
  inline void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 2;
  inline const ::arangodb::TasksPlan& coordinators() const;
  inline ::arangodb::TasksPlan* mutable_coordinators();
  inline ::arangodb::TasksPlan* release_coordinators();
  inline void set_allocated_coordinators(::arangodb::TasksPlan* coordinators);

  // required .arangodb.TasksPlan dbservers = 3;
  inline bool has_dbservers() const;
  inline void clear_dbservers();
  static const int kDbserversFieldNumber = 3;
  inline const ::arangodb::TasksPlan& dbservers() const;
  inline ::arangodb::TasksPlan* mutable_dbservers();
  inline ::arangodb::TasksPlan* release_dbservers();
  inline void set_allocated_dbservers(::arangodb::TasksPlan* dbservers);

  // required .arangodb.TasksPlan secondaries = 4;
  inline bool has_secondaries() const;
  inline void clear_secondaries();
  static const int kSecondariesFieldNumber = 4;
  inline const ::arangodb::TasksPlan& secondaries() const;
  inline ::arangodb::TasksPlan* mutable_secondaries();
  inline ::arangodb::TasksPlan* release_secondaries();
  inline void set_allocated_secondaries(::arangodb::TasksPlan* secondaries);

  // @@protoc_insertion_point(class_scope:arangodb.Plan)
 private:
  inline void set_has_agents();
  inline void clear_has_agents();
  inline void set_has_coordinators();
  inline void clear_has_coordinators();
  inline void set_has_dbservers();
  inline void clear_has_dbservers();
  inline void set_has_secondaries();
  inline void clear_has_secondaries();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::arangodb::TasksPlan* agents_;
  ::arangodb::TasksPlan* coordinators_;
  ::arangodb::TasksPlan* dbservers_;
  ::arangodb::TasksPlan* secondaries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static Plan* default_instance_;
};
// -------------------------------------------------------------------

class ResourceCurrent : public ::google::protobuf::Message {
 public:
  ResourceCurrent();
  virtual ~ResourceCurrent();

  ResourceCurrent(const ResourceCurrent& from);

  inline ResourceCurrent& operator=(const ResourceCurrent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceCurrent& default_instance();

  void Swap(ResourceCurrent* other);

  // implements Message ----------------------------------------------

  ResourceCurrent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceCurrent& from);
  void MergeFrom(const ResourceCurrent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.SlaveID slave_id = 1;
  inline bool has_slave_id() const;
  inline void clear_slave_id();
  static const int kSlaveIdFieldNumber = 1;
  inline const ::mesos::SlaveID& slave_id() const;
  inline ::mesos::SlaveID* mutable_slave_id();
  inline ::mesos::SlaveID* release_slave_id();
  inline void set_allocated_slave_id(::mesos::SlaveID* slave_id);

  // optional .mesos.OfferID offer_id = 2;
  inline bool has_offer_id() const;
  inline void clear_offer_id();
  static const int kOfferIdFieldNumber = 2;
  inline const ::mesos::OfferID& offer_id() const;
  inline ::mesos::OfferID* mutable_offer_id();
  inline ::mesos::OfferID* release_offer_id();
  inline void set_allocated_offer_id(::mesos::OfferID* offer_id);

  // repeated .mesos.Resource resources = 3;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 3;
  inline const ::mesos::Resource& resources(int index) const;
  inline ::mesos::Resource* mutable_resources(int index);
  inline ::mesos::Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
      mutable_resources();

  // repeated uint32 ports = 4;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 4;
  inline ::google::protobuf::uint32 ports(int index) const;
  inline void set_ports(int index, ::google::protobuf::uint32 value);
  inline void add_ports(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ports() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ports();

  // optional string hostname = 5;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 5;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string container_path = 6;
  inline bool has_container_path() const;
  inline void clear_container_path();
  static const int kContainerPathFieldNumber = 6;
  inline const ::std::string& container_path() const;
  inline void set_container_path(const ::std::string& value);
  inline void set_container_path(const char* value);
  inline void set_container_path(const char* value, size_t size);
  inline ::std::string* mutable_container_path();
  inline ::std::string* release_container_path();
  inline void set_allocated_container_path(::std::string* container_path);

  // @@protoc_insertion_point(class_scope:arangodb.ResourceCurrent)
 private:
  inline void set_has_slave_id();
  inline void clear_has_slave_id();
  inline void set_has_offer_id();
  inline void clear_has_offer_id();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_container_path();
  inline void clear_has_container_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::SlaveID* slave_id_;
  ::mesos::OfferID* offer_id_;
  ::google::protobuf::RepeatedPtrField< ::mesos::Resource > resources_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ports_;
  ::std::string* hostname_;
  ::std::string* container_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static ResourceCurrent* default_instance_;
};
// -------------------------------------------------------------------

class ResourcesCurrent : public ::google::protobuf::Message {
 public:
  ResourcesCurrent();
  virtual ~ResourcesCurrent();

  ResourcesCurrent(const ResourcesCurrent& from);

  inline ResourcesCurrent& operator=(const ResourcesCurrent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourcesCurrent& default_instance();

  void Swap(ResourcesCurrent* other);

  // implements Message ----------------------------------------------

  ResourcesCurrent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourcesCurrent& from);
  void MergeFrom(const ResourcesCurrent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.ResourceCurrent entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::arangodb::ResourceCurrent& entries(int index) const;
  inline ::arangodb::ResourceCurrent* mutable_entries(int index);
  inline ::arangodb::ResourceCurrent* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::arangodb::ResourceCurrent >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::arangodb::ResourceCurrent >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:arangodb.ResourcesCurrent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::arangodb::ResourceCurrent > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static ResourcesCurrent* default_instance_;
};
// -------------------------------------------------------------------

class InstanceCurrent : public ::google::protobuf::Message {
 public:
  InstanceCurrent();
  virtual ~InstanceCurrent();

  InstanceCurrent(const InstanceCurrent& from);

  inline InstanceCurrent& operator=(const InstanceCurrent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceCurrent& default_instance();

  void Swap(InstanceCurrent* other);

  // implements Message ----------------------------------------------

  InstanceCurrent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceCurrent& from);
  void MergeFrom(const InstanceCurrent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .arangodb.InstanceCurrentState state = 1 [default = INSTANCE_STATE_UNUSED];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::arangodb::InstanceCurrentState state() const;
  inline void set_state(::arangodb::InstanceCurrentState value);

  // optional .mesos.TaskInfo task_info = 2;
  inline bool has_task_info() const;
  inline void clear_task_info();
  static const int kTaskInfoFieldNumber = 2;
  inline const ::mesos::TaskInfo& task_info() const;
  inline ::mesos::TaskInfo* mutable_task_info();
  inline ::mesos::TaskInfo* release_task_info();
  inline void set_allocated_task_info(::mesos::TaskInfo* task_info);

  // optional .mesos.TaskStatus task_status = 3;
  inline bool has_task_status() const;
  inline void clear_task_status();
  static const int kTaskStatusFieldNumber = 3;
  inline const ::mesos::TaskStatus& task_status() const;
  inline ::mesos::TaskStatus* mutable_task_status();
  inline ::mesos::TaskStatus* release_task_status();
  inline void set_allocated_task_status(::mesos::TaskStatus* task_status);

  // repeated uint32 ports = 4;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 4;
  inline ::google::protobuf::uint32 ports(int index) const;
  inline void set_ports(int index, ::google::protobuf::uint32 value);
  inline void add_ports(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ports() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ports();

  // optional string hostname = 5;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 5;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // @@protoc_insertion_point(class_scope:arangodb.InstanceCurrent)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_task_info();
  inline void clear_has_task_info();
  inline void set_has_task_status();
  inline void clear_has_task_status();
  inline void set_has_hostname();
  inline void clear_has_hostname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::TaskInfo* task_info_;
  ::mesos::TaskStatus* task_status_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ports_;
  ::std::string* hostname_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static InstanceCurrent* default_instance_;
};
// -------------------------------------------------------------------

class InstancesCurrent : public ::google::protobuf::Message {
 public:
  InstancesCurrent();
  virtual ~InstancesCurrent();

  InstancesCurrent(const InstancesCurrent& from);

  inline InstancesCurrent& operator=(const InstancesCurrent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstancesCurrent& default_instance();

  void Swap(InstancesCurrent* other);

  // implements Message ----------------------------------------------

  InstancesCurrent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstancesCurrent& from);
  void MergeFrom(const InstancesCurrent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arangodb.InstanceCurrent entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::arangodb::InstanceCurrent& entries(int index) const;
  inline ::arangodb::InstanceCurrent* mutable_entries(int index);
  inline ::arangodb::InstanceCurrent* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::arangodb::InstanceCurrent >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::arangodb::InstanceCurrent >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:arangodb.InstancesCurrent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::arangodb::InstanceCurrent > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static InstancesCurrent* default_instance_;
};
// -------------------------------------------------------------------

class Current : public ::google::protobuf::Message {
 public:
  Current();
  virtual ~Current();

  Current(const Current& from);

  inline Current& operator=(const Current& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Current& default_instance();

  void Swap(Current* other);

  // implements Message ----------------------------------------------

  Current* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Current& from);
  void MergeFrom(const Current& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .arangodb.ResourcesCurrent agency_resources = 1;
  inline bool has_agency_resources() const;
  inline void clear_agency_resources();
  static const int kAgencyResourcesFieldNumber = 1;
  inline const ::arangodb::ResourcesCurrent& agency_resources() const;
  inline ::arangodb::ResourcesCurrent* mutable_agency_resources();
  inline ::arangodb::ResourcesCurrent* release_agency_resources();
  inline void set_allocated_agency_resources(::arangodb::ResourcesCurrent* agency_resources);

  // required .arangodb.ResourcesCurrent coordinator_resources = 2;
  inline bool has_coordinator_resources() const;
  inline void clear_coordinator_resources();
  static const int kCoordinatorResourcesFieldNumber = 2;
  inline const ::arangodb::ResourcesCurrent& coordinator_resources() const;
  inline ::arangodb::ResourcesCurrent* mutable_coordinator_resources();
  inline ::arangodb::ResourcesCurrent* release_coordinator_resources();
  inline void set_allocated_coordinator_resources(::arangodb::ResourcesCurrent* coordinator_resources);

  // required .arangodb.ResourcesCurrent primary_dbserver_resources = 3;
  inline bool has_primary_dbserver_resources() const;
  inline void clear_primary_dbserver_resources();
  static const int kPrimaryDbserverResourcesFieldNumber = 3;
  inline const ::arangodb::ResourcesCurrent& primary_dbserver_resources() const;
  inline ::arangodb::ResourcesCurrent* mutable_primary_dbserver_resources();
  inline ::arangodb::ResourcesCurrent* release_primary_dbserver_resources();
  inline void set_allocated_primary_dbserver_resources(::arangodb::ResourcesCurrent* primary_dbserver_resources);

  // required .arangodb.ResourcesCurrent secondary_dbserver_resources = 4;
  inline bool has_secondary_dbserver_resources() const;
  inline void clear_secondary_dbserver_resources();
  static const int kSecondaryDbserverResourcesFieldNumber = 4;
  inline const ::arangodb::ResourcesCurrent& secondary_dbserver_resources() const;
  inline ::arangodb::ResourcesCurrent* mutable_secondary_dbserver_resources();
  inline ::arangodb::ResourcesCurrent* release_secondary_dbserver_resources();
  inline void set_allocated_secondary_dbserver_resources(::arangodb::ResourcesCurrent* secondary_dbserver_resources);

  // required .arangodb.InstancesCurrent agents = 5;
  inline bool has_agents() const;
  inline void clear_agents();
  static const int kAgentsFieldNumber = 5;
  inline const ::arangodb::InstancesCurrent& agents() const;
  inline ::arangodb::InstancesCurrent* mutable_agents();
  inline ::arangodb::InstancesCurrent* release_agents();
  inline void set_allocated_agents(::arangodb::InstancesCurrent* agents);

  // required .arangodb.InstancesCurrent coordinators = 6;
  inline bool has_coordinators() const;
  inline void clear_coordinators();
  static const int kCoordinatorsFieldNumber = 6;
  inline const ::arangodb::InstancesCurrent& coordinators() const;
  inline ::arangodb::InstancesCurrent* mutable_coordinators();
  inline ::arangodb::InstancesCurrent* release_coordinators();
  inline void set_allocated_coordinators(::arangodb::InstancesCurrent* coordinators);

  // required .arangodb.InstancesCurrent primary_dbservers = 7;
  inline bool has_primary_dbservers() const;
  inline void clear_primary_dbservers();
  static const int kPrimaryDbserversFieldNumber = 7;
  inline const ::arangodb::InstancesCurrent& primary_dbservers() const;
  inline ::arangodb::InstancesCurrent* mutable_primary_dbservers();
  inline ::arangodb::InstancesCurrent* release_primary_dbservers();
  inline void set_allocated_primary_dbservers(::arangodb::InstancesCurrent* primary_dbservers);

  // required .arangodb.InstancesCurrent secondary_dbservers = 8;
  inline bool has_secondary_dbservers() const;
  inline void clear_secondary_dbservers();
  static const int kSecondaryDbserversFieldNumber = 8;
  inline const ::arangodb::InstancesCurrent& secondary_dbservers() const;
  inline ::arangodb::InstancesCurrent* mutable_secondary_dbservers();
  inline ::arangodb::InstancesCurrent* release_secondary_dbservers();
  inline void set_allocated_secondary_dbservers(::arangodb::InstancesCurrent* secondary_dbservers);

  // required bool cluster_complete = 9;
  inline bool has_cluster_complete() const;
  inline void clear_cluster_complete();
  static const int kClusterCompleteFieldNumber = 9;
  inline bool cluster_complete() const;
  inline void set_cluster_complete(bool value);

  // required bool cluster_bootstrappedDBservers = 10;
  inline bool has_cluster_bootstrappeddbservers() const;
  inline void clear_cluster_bootstrappeddbservers();
  static const int kClusterBootstrappedDBserversFieldNumber = 10;
  inline bool cluster_bootstrappeddbservers() const;
  inline void set_cluster_bootstrappeddbservers(bool value);

  // required bool cluster_upgradedDB = 11;
  inline bool has_cluster_upgradeddb() const;
  inline void clear_cluster_upgradeddb();
  static const int kClusterUpgradedDBFieldNumber = 11;
  inline bool cluster_upgradeddb() const;
  inline void set_cluster_upgradeddb(bool value);

  // required bool cluster_bootstrappedCoordinators = 12;
  inline bool has_cluster_bootstrappedcoordinators() const;
  inline void clear_cluster_bootstrappedcoordinators();
  static const int kClusterBootstrappedCoordinatorsFieldNumber = 12;
  inline bool cluster_bootstrappedcoordinators() const;
  inline void set_cluster_bootstrappedcoordinators(bool value);

  // required bool cluster_initialized = 13;
  inline bool has_cluster_initialized() const;
  inline void clear_cluster_initialized();
  static const int kClusterInitializedFieldNumber = 13;
  inline bool cluster_initialized() const;
  inline void set_cluster_initialized(bool value);

  // @@protoc_insertion_point(class_scope:arangodb.Current)
 private:
  inline void set_has_agency_resources();
  inline void clear_has_agency_resources();
  inline void set_has_coordinator_resources();
  inline void clear_has_coordinator_resources();
  inline void set_has_primary_dbserver_resources();
  inline void clear_has_primary_dbserver_resources();
  inline void set_has_secondary_dbserver_resources();
  inline void clear_has_secondary_dbserver_resources();
  inline void set_has_agents();
  inline void clear_has_agents();
  inline void set_has_coordinators();
  inline void clear_has_coordinators();
  inline void set_has_primary_dbservers();
  inline void clear_has_primary_dbservers();
  inline void set_has_secondary_dbservers();
  inline void clear_has_secondary_dbservers();
  inline void set_has_cluster_complete();
  inline void clear_has_cluster_complete();
  inline void set_has_cluster_bootstrappeddbservers();
  inline void clear_has_cluster_bootstrappeddbservers();
  inline void set_has_cluster_upgradeddb();
  inline void clear_has_cluster_upgradeddb();
  inline void set_has_cluster_bootstrappedcoordinators();
  inline void clear_has_cluster_bootstrappedcoordinators();
  inline void set_has_cluster_initialized();
  inline void clear_has_cluster_initialized();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::arangodb::ResourcesCurrent* agency_resources_;
  ::arangodb::ResourcesCurrent* coordinator_resources_;
  ::arangodb::ResourcesCurrent* primary_dbserver_resources_;
  ::arangodb::ResourcesCurrent* secondary_dbserver_resources_;
  ::arangodb::InstancesCurrent* agents_;
  ::arangodb::InstancesCurrent* coordinators_;
  ::arangodb::InstancesCurrent* primary_dbservers_;
  ::arangodb::InstancesCurrent* secondary_dbservers_;
  bool cluster_complete_;
  bool cluster_bootstrappeddbservers_;
  bool cluster_upgradeddb_;
  bool cluster_bootstrappedcoordinators_;
  bool cluster_initialized_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static Current* default_instance_;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  void Swap(State* other);

  // implements Message ----------------------------------------------

  State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mesos.FrameworkID framework_id = 1;
  inline bool has_framework_id() const;
  inline void clear_framework_id();
  static const int kFrameworkIdFieldNumber = 1;
  inline const ::mesos::FrameworkID& framework_id() const;
  inline ::mesos::FrameworkID* mutable_framework_id();
  inline ::mesos::FrameworkID* release_framework_id();
  inline void set_allocated_framework_id(::mesos::FrameworkID* framework_id);

  // required .arangodb.Targets targets = 2;
  inline bool has_targets() const;
  inline void clear_targets();
  static const int kTargetsFieldNumber = 2;
  inline const ::arangodb::Targets& targets() const;
  inline ::arangodb::Targets* mutable_targets();
  inline ::arangodb::Targets* release_targets();
  inline void set_allocated_targets(::arangodb::Targets* targets);

  // required .arangodb.Plan plan = 3;
  inline bool has_plan() const;
  inline void clear_plan();
  static const int kPlanFieldNumber = 3;
  inline const ::arangodb::Plan& plan() const;
  inline ::arangodb::Plan* mutable_plan();
  inline ::arangodb::Plan* release_plan();
  inline void set_allocated_plan(::arangodb::Plan* plan);

  // required .arangodb.Current current = 4;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 4;
  inline const ::arangodb::Current& current() const;
  inline ::arangodb::Current* mutable_current();
  inline ::arangodb::Current* release_current();
  inline void set_allocated_current(::arangodb::Current* current);

  // @@protoc_insertion_point(class_scope:arangodb.State)
 private:
  inline void set_has_framework_id();
  inline void clear_has_framework_id();
  inline void set_has_targets();
  inline void clear_has_targets();
  inline void set_has_plan();
  inline void clear_has_plan();
  inline void set_has_current();
  inline void clear_has_current();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mesos::FrameworkID* framework_id_;
  ::arangodb::Targets* targets_;
  ::arangodb::Plan* plan_;
  ::arangodb::Current* current_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_arangodb_2eproto();
  friend void protobuf_AssignDesc_arangodb_2eproto();
  friend void protobuf_ShutdownFile_arangodb_2eproto();

  void InitAsDefaultInstance();
  static State* default_instance_;
};
// ===================================================================


// ===================================================================

// Target

// required uint32 instances = 1;
inline bool Target::has_instances() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Target::set_has_instances() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Target::clear_has_instances() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Target::clear_instances() {
  instances_ = 0u;
  clear_has_instances();
}
inline ::google::protobuf::uint32 Target::instances() const {
  return instances_;
}
inline void Target::set_instances(::google::protobuf::uint32 value) {
  set_has_instances();
  instances_ = value;
}

// repeated .mesos.Resource minimal_resources = 2;
inline int Target::minimal_resources_size() const {
  return minimal_resources_.size();
}
inline void Target::clear_minimal_resources() {
  minimal_resources_.Clear();
}
inline const ::mesos::Resource& Target::minimal_resources(int index) const {
  return minimal_resources_.Get(index);
}
inline ::mesos::Resource* Target::mutable_minimal_resources(int index) {
  return minimal_resources_.Mutable(index);
}
inline ::mesos::Resource* Target::add_minimal_resources() {
  return minimal_resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Target::minimal_resources() const {
  return minimal_resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Target::mutable_minimal_resources() {
  return &minimal_resources_;
}

// repeated .mesos.Resource additional_resources = 3;
inline int Target::additional_resources_size() const {
  return additional_resources_.size();
}
inline void Target::clear_additional_resources() {
  additional_resources_.Clear();
}
inline const ::mesos::Resource& Target::additional_resources(int index) const {
  return additional_resources_.Get(index);
}
inline ::mesos::Resource* Target::mutable_additional_resources(int index) {
  return additional_resources_.Mutable(index);
}
inline ::mesos::Resource* Target::add_additional_resources() {
  return additional_resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Target::additional_resources() const {
  return additional_resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Target::mutable_additional_resources() {
  return &additional_resources_;
}

// required uint32 number_ports = 4;
inline bool Target::has_number_ports() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Target::set_has_number_ports() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Target::clear_has_number_ports() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Target::clear_number_ports() {
  number_ports_ = 0u;
  clear_has_number_ports();
}
inline ::google::protobuf::uint32 Target::number_ports() const {
  return number_ports_;
}
inline void Target::set_number_ports(::google::protobuf::uint32 value) {
  set_has_number_ports();
  number_ports_ = value;
}

// -------------------------------------------------------------------

// Targets

// required string mode = 1;
inline bool Targets::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Targets::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Targets::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Targets::clear_mode() {
  if (mode_ != &::google::protobuf::internal::kEmptyString) {
    mode_->clear();
  }
  clear_has_mode();
}
inline const ::std::string& Targets::mode() const {
  return *mode_;
}
inline void Targets::set_mode(const ::std::string& value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
}
inline void Targets::set_mode(const char* value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
}
inline void Targets::set_mode(const char* value, size_t size) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  mode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Targets::mutable_mode() {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    mode_ = new ::std::string;
  }
  return mode_;
}
inline ::std::string* Targets::release_mode() {
  clear_has_mode();
  if (mode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mode_;
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Targets::set_allocated_mode(::std::string* mode) {
  if (mode_ != &::google::protobuf::internal::kEmptyString) {
    delete mode_;
  }
  if (mode) {
    set_has_mode();
    mode_ = mode;
  } else {
    clear_has_mode();
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .arangodb.Target agents = 2;
inline bool Targets::has_agents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Targets::set_has_agents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Targets::clear_has_agents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Targets::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::Target::Clear();
  clear_has_agents();
}
inline const ::arangodb::Target& Targets::agents() const {
  return agents_ != NULL ? *agents_ : *default_instance_->agents_;
}
inline ::arangodb::Target* Targets::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) agents_ = new ::arangodb::Target;
  return agents_;
}
inline ::arangodb::Target* Targets::release_agents() {
  clear_has_agents();
  ::arangodb::Target* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Targets::set_allocated_agents(::arangodb::Target* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
}

// required .arangodb.Target coordinators = 3;
inline bool Targets::has_coordinators() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Targets::set_has_coordinators() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Targets::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Targets::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::Target::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::Target& Targets::coordinators() const {
  return coordinators_ != NULL ? *coordinators_ : *default_instance_->coordinators_;
}
inline ::arangodb::Target* Targets::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) coordinators_ = new ::arangodb::Target;
  return coordinators_;
}
inline ::arangodb::Target* Targets::release_coordinators() {
  clear_has_coordinators();
  ::arangodb::Target* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Targets::set_allocated_coordinators(::arangodb::Target* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
}

// required .arangodb.Target dbservers = 4;
inline bool Targets::has_dbservers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Targets::set_has_dbservers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Targets::clear_has_dbservers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Targets::clear_dbservers() {
  if (dbservers_ != NULL) dbservers_->::arangodb::Target::Clear();
  clear_has_dbservers();
}
inline const ::arangodb::Target& Targets::dbservers() const {
  return dbservers_ != NULL ? *dbservers_ : *default_instance_->dbservers_;
}
inline ::arangodb::Target* Targets::mutable_dbservers() {
  set_has_dbservers();
  if (dbservers_ == NULL) dbservers_ = new ::arangodb::Target;
  return dbservers_;
}
inline ::arangodb::Target* Targets::release_dbservers() {
  clear_has_dbservers();
  ::arangodb::Target* temp = dbservers_;
  dbservers_ = NULL;
  return temp;
}
inline void Targets::set_allocated_dbservers(::arangodb::Target* dbservers) {
  delete dbservers_;
  dbservers_ = dbservers;
  if (dbservers) {
    set_has_dbservers();
  } else {
    clear_has_dbservers();
  }
}

// required .arangodb.Target secondaries = 5;
inline bool Targets::has_secondaries() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Targets::set_has_secondaries() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Targets::clear_has_secondaries() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Targets::clear_secondaries() {
  if (secondaries_ != NULL) secondaries_->::arangodb::Target::Clear();
  clear_has_secondaries();
}
inline const ::arangodb::Target& Targets::secondaries() const {
  return secondaries_ != NULL ? *secondaries_ : *default_instance_->secondaries_;
}
inline ::arangodb::Target* Targets::mutable_secondaries() {
  set_has_secondaries();
  if (secondaries_ == NULL) secondaries_ = new ::arangodb::Target;
  return secondaries_;
}
inline ::arangodb::Target* Targets::release_secondaries() {
  clear_has_secondaries();
  ::arangodb::Target* temp = secondaries_;
  secondaries_ = NULL;
  return temp;
}
inline void Targets::set_allocated_secondaries(::arangodb::Target* secondaries) {
  delete secondaries_;
  secondaries_ = secondaries;
  if (secondaries) {
    set_has_secondaries();
  } else {
    clear_has_secondaries();
  }
}

// optional bool asynchronous_replication = 6;
inline bool Targets::has_asynchronous_replication() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Targets::set_has_asynchronous_replication() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Targets::clear_has_asynchronous_replication() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Targets::clear_asynchronous_replication() {
  asynchronous_replication_ = false;
  clear_has_asynchronous_replication();
}
inline bool Targets::asynchronous_replication() const {
  return asynchronous_replication_;
}
inline void Targets::set_asynchronous_replication(bool value) {
  set_has_asynchronous_replication();
  asynchronous_replication_ = value;
}

// -------------------------------------------------------------------

// TaskPlan

// required .arangodb.TaskPlanState state = 1 [default = TASK_STATE_NEW];
inline bool TaskPlan::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskPlan::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskPlan::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskPlan::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::arangodb::TaskPlanState TaskPlan::state() const {
  return static_cast< ::arangodb::TaskPlanState >(state_);
}
inline void TaskPlan::set_state(::arangodb::TaskPlanState value) {
  assert(::arangodb::TaskPlanState_IsValid(value));
  set_has_state();
  state_ = value;
}

// required bool is_primary = 2;
inline bool TaskPlan::has_is_primary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskPlan::set_has_is_primary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskPlan::clear_has_is_primary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskPlan::clear_is_primary() {
  is_primary_ = false;
  clear_has_is_primary();
}
inline bool TaskPlan::is_primary() const {
  return is_primary_;
}
inline void TaskPlan::set_is_primary(bool value) {
  set_has_is_primary();
  is_primary_ = value;
}

// optional string persistence_id = 3;
inline bool TaskPlan::has_persistence_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskPlan::set_has_persistence_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskPlan::clear_has_persistence_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskPlan::clear_persistence_id() {
  if (persistence_id_ != &::google::protobuf::internal::kEmptyString) {
    persistence_id_->clear();
  }
  clear_has_persistence_id();
}
inline const ::std::string& TaskPlan::persistence_id() const {
  return *persistence_id_;
}
inline void TaskPlan::set_persistence_id(const ::std::string& value) {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  persistence_id_->assign(value);
}
inline void TaskPlan::set_persistence_id(const char* value) {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  persistence_id_->assign(value);
}
inline void TaskPlan::set_persistence_id(const char* value, size_t size) {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  persistence_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TaskPlan::mutable_persistence_id() {
  set_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    persistence_id_ = new ::std::string;
  }
  return persistence_id_;
}
inline ::std::string* TaskPlan::release_persistence_id() {
  clear_has_persistence_id();
  if (persistence_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = persistence_id_;
    persistence_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TaskPlan::set_allocated_persistence_id(::std::string* persistence_id) {
  if (persistence_id_ != &::google::protobuf::internal::kEmptyString) {
    delete persistence_id_;
  }
  if (persistence_id) {
    set_has_persistence_id();
    persistence_id_ = persistence_id;
  } else {
    clear_has_persistence_id();
    persistence_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double started = 4;
inline bool TaskPlan::has_started() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskPlan::set_has_started() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskPlan::clear_has_started() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskPlan::clear_started() {
  started_ = 0;
  clear_has_started();
}
inline double TaskPlan::started() const {
  return started_;
}
inline void TaskPlan::set_started(double value) {
  set_has_started();
  started_ = value;
}

// -------------------------------------------------------------------

// TasksPlan

// repeated .arangodb.TaskPlan entries = 1;
inline int TasksPlan::entries_size() const {
  return entries_.size();
}
inline void TasksPlan::clear_entries() {
  entries_.Clear();
}
inline const ::arangodb::TaskPlan& TasksPlan::entries(int index) const {
  return entries_.Get(index);
}
inline ::arangodb::TaskPlan* TasksPlan::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::arangodb::TaskPlan* TasksPlan::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >&
TasksPlan::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::TaskPlan >*
TasksPlan::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// Plan

// required .arangodb.TasksPlan agents = 1;
inline bool Plan::has_agents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Plan::set_has_agents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Plan::clear_has_agents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Plan::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::TasksPlan::Clear();
  clear_has_agents();
}
inline const ::arangodb::TasksPlan& Plan::agents() const {
  return agents_ != NULL ? *agents_ : *default_instance_->agents_;
}
inline ::arangodb::TasksPlan* Plan::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) agents_ = new ::arangodb::TasksPlan;
  return agents_;
}
inline ::arangodb::TasksPlan* Plan::release_agents() {
  clear_has_agents();
  ::arangodb::TasksPlan* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Plan::set_allocated_agents(::arangodb::TasksPlan* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
}

// required .arangodb.TasksPlan coordinators = 2;
inline bool Plan::has_coordinators() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Plan::set_has_coordinators() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Plan::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Plan::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::TasksPlan::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::TasksPlan& Plan::coordinators() const {
  return coordinators_ != NULL ? *coordinators_ : *default_instance_->coordinators_;
}
inline ::arangodb::TasksPlan* Plan::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) coordinators_ = new ::arangodb::TasksPlan;
  return coordinators_;
}
inline ::arangodb::TasksPlan* Plan::release_coordinators() {
  clear_has_coordinators();
  ::arangodb::TasksPlan* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Plan::set_allocated_coordinators(::arangodb::TasksPlan* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
}

// required .arangodb.TasksPlan dbservers = 3;
inline bool Plan::has_dbservers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Plan::set_has_dbservers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Plan::clear_has_dbservers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Plan::clear_dbservers() {
  if (dbservers_ != NULL) dbservers_->::arangodb::TasksPlan::Clear();
  clear_has_dbservers();
}
inline const ::arangodb::TasksPlan& Plan::dbservers() const {
  return dbservers_ != NULL ? *dbservers_ : *default_instance_->dbservers_;
}
inline ::arangodb::TasksPlan* Plan::mutable_dbservers() {
  set_has_dbservers();
  if (dbservers_ == NULL) dbservers_ = new ::arangodb::TasksPlan;
  return dbservers_;
}
inline ::arangodb::TasksPlan* Plan::release_dbservers() {
  clear_has_dbservers();
  ::arangodb::TasksPlan* temp = dbservers_;
  dbservers_ = NULL;
  return temp;
}
inline void Plan::set_allocated_dbservers(::arangodb::TasksPlan* dbservers) {
  delete dbservers_;
  dbservers_ = dbservers;
  if (dbservers) {
    set_has_dbservers();
  } else {
    clear_has_dbservers();
  }
}

// required .arangodb.TasksPlan secondaries = 4;
inline bool Plan::has_secondaries() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Plan::set_has_secondaries() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Plan::clear_has_secondaries() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Plan::clear_secondaries() {
  if (secondaries_ != NULL) secondaries_->::arangodb::TasksPlan::Clear();
  clear_has_secondaries();
}
inline const ::arangodb::TasksPlan& Plan::secondaries() const {
  return secondaries_ != NULL ? *secondaries_ : *default_instance_->secondaries_;
}
inline ::arangodb::TasksPlan* Plan::mutable_secondaries() {
  set_has_secondaries();
  if (secondaries_ == NULL) secondaries_ = new ::arangodb::TasksPlan;
  return secondaries_;
}
inline ::arangodb::TasksPlan* Plan::release_secondaries() {
  clear_has_secondaries();
  ::arangodb::TasksPlan* temp = secondaries_;
  secondaries_ = NULL;
  return temp;
}
inline void Plan::set_allocated_secondaries(::arangodb::TasksPlan* secondaries) {
  delete secondaries_;
  secondaries_ = secondaries;
  if (secondaries) {
    set_has_secondaries();
  } else {
    clear_has_secondaries();
  }
}

// -------------------------------------------------------------------

// ResourceCurrent

// optional .mesos.SlaveID slave_id = 1;
inline bool ResourceCurrent::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceCurrent::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceCurrent::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceCurrent::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
inline const ::mesos::SlaveID& ResourceCurrent::slave_id() const {
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
inline ::mesos::SlaveID* ResourceCurrent::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) slave_id_ = new ::mesos::SlaveID;
  return slave_id_;
}
inline ::mesos::SlaveID* ResourceCurrent::release_slave_id() {
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
inline void ResourceCurrent::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
}

// optional .mesos.OfferID offer_id = 2;
inline bool ResourceCurrent::has_offer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceCurrent::set_has_offer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceCurrent::clear_has_offer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceCurrent::clear_offer_id() {
  if (offer_id_ != NULL) offer_id_->::mesos::OfferID::Clear();
  clear_has_offer_id();
}
inline const ::mesos::OfferID& ResourceCurrent::offer_id() const {
  return offer_id_ != NULL ? *offer_id_ : *default_instance_->offer_id_;
}
inline ::mesos::OfferID* ResourceCurrent::mutable_offer_id() {
  set_has_offer_id();
  if (offer_id_ == NULL) offer_id_ = new ::mesos::OfferID;
  return offer_id_;
}
inline ::mesos::OfferID* ResourceCurrent::release_offer_id() {
  clear_has_offer_id();
  ::mesos::OfferID* temp = offer_id_;
  offer_id_ = NULL;
  return temp;
}
inline void ResourceCurrent::set_allocated_offer_id(::mesos::OfferID* offer_id) {
  delete offer_id_;
  offer_id_ = offer_id;
  if (offer_id) {
    set_has_offer_id();
  } else {
    clear_has_offer_id();
  }
}

// repeated .mesos.Resource resources = 3;
inline int ResourceCurrent::resources_size() const {
  return resources_.size();
}
inline void ResourceCurrent::clear_resources() {
  resources_.Clear();
}
inline const ::mesos::Resource& ResourceCurrent::resources(int index) const {
  return resources_.Get(index);
}
inline ::mesos::Resource* ResourceCurrent::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::mesos::Resource* ResourceCurrent::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourceCurrent::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourceCurrent::mutable_resources() {
  return &resources_;
}

// repeated uint32 ports = 4;
inline int ResourceCurrent::ports_size() const {
  return ports_.size();
}
inline void ResourceCurrent::clear_ports() {
  ports_.Clear();
}
inline ::google::protobuf::uint32 ResourceCurrent::ports(int index) const {
  return ports_.Get(index);
}
inline void ResourceCurrent::set_ports(int index, ::google::protobuf::uint32 value) {
  ports_.Set(index, value);
}
inline void ResourceCurrent::add_ports(::google::protobuf::uint32 value) {
  ports_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ResourceCurrent::ports() const {
  return ports_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ResourceCurrent::mutable_ports() {
  return &ports_;
}

// optional string hostname = 5;
inline bool ResourceCurrent::has_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceCurrent::set_has_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceCurrent::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceCurrent::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& ResourceCurrent::hostname() const {
  return *hostname_;
}
inline void ResourceCurrent::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ResourceCurrent::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ResourceCurrent::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceCurrent::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* ResourceCurrent::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceCurrent::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string container_path = 6;
inline bool ResourceCurrent::has_container_path() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResourceCurrent::set_has_container_path() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResourceCurrent::clear_has_container_path() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResourceCurrent::clear_container_path() {
  if (container_path_ != &::google::protobuf::internal::kEmptyString) {
    container_path_->clear();
  }
  clear_has_container_path();
}
inline const ::std::string& ResourceCurrent::container_path() const {
  return *container_path_;
}
inline void ResourceCurrent::set_container_path(const ::std::string& value) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(value);
}
inline void ResourceCurrent::set_container_path(const char* value) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(value);
}
inline void ResourceCurrent::set_container_path(const char* value, size_t size) {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  container_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceCurrent::mutable_container_path() {
  set_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    container_path_ = new ::std::string;
  }
  return container_path_;
}
inline ::std::string* ResourceCurrent::release_container_path() {
  clear_has_container_path();
  if (container_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = container_path_;
    container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceCurrent::set_allocated_container_path(::std::string* container_path) {
  if (container_path_ != &::google::protobuf::internal::kEmptyString) {
    delete container_path_;
  }
  if (container_path) {
    set_has_container_path();
    container_path_ = container_path;
  } else {
    clear_has_container_path();
    container_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResourcesCurrent

// repeated .arangodb.ResourceCurrent entries = 1;
inline int ResourcesCurrent::entries_size() const {
  return entries_.size();
}
inline void ResourcesCurrent::clear_entries() {
  entries_.Clear();
}
inline const ::arangodb::ResourceCurrent& ResourcesCurrent::entries(int index) const {
  return entries_.Get(index);
}
inline ::arangodb::ResourceCurrent* ResourcesCurrent::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::arangodb::ResourceCurrent* ResourcesCurrent::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::ResourceCurrent >&
ResourcesCurrent::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::ResourceCurrent >*
ResourcesCurrent::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// InstanceCurrent

// required .arangodb.InstanceCurrentState state = 1 [default = INSTANCE_STATE_UNUSED];
inline bool InstanceCurrent::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceCurrent::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceCurrent::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceCurrent::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::arangodb::InstanceCurrentState InstanceCurrent::state() const {
  return static_cast< ::arangodb::InstanceCurrentState >(state_);
}
inline void InstanceCurrent::set_state(::arangodb::InstanceCurrentState value) {
  assert(::arangodb::InstanceCurrentState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .mesos.TaskInfo task_info = 2;
inline bool InstanceCurrent::has_task_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceCurrent::set_has_task_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceCurrent::clear_has_task_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceCurrent::clear_task_info() {
  if (task_info_ != NULL) task_info_->::mesos::TaskInfo::Clear();
  clear_has_task_info();
}
inline const ::mesos::TaskInfo& InstanceCurrent::task_info() const {
  return task_info_ != NULL ? *task_info_ : *default_instance_->task_info_;
}
inline ::mesos::TaskInfo* InstanceCurrent::mutable_task_info() {
  set_has_task_info();
  if (task_info_ == NULL) task_info_ = new ::mesos::TaskInfo;
  return task_info_;
}
inline ::mesos::TaskInfo* InstanceCurrent::release_task_info() {
  clear_has_task_info();
  ::mesos::TaskInfo* temp = task_info_;
  task_info_ = NULL;
  return temp;
}
inline void InstanceCurrent::set_allocated_task_info(::mesos::TaskInfo* task_info) {
  delete task_info_;
  task_info_ = task_info;
  if (task_info) {
    set_has_task_info();
  } else {
    clear_has_task_info();
  }
}

// optional .mesos.TaskStatus task_status = 3;
inline bool InstanceCurrent::has_task_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceCurrent::set_has_task_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceCurrent::clear_has_task_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceCurrent::clear_task_status() {
  if (task_status_ != NULL) task_status_->::mesos::TaskStatus::Clear();
  clear_has_task_status();
}
inline const ::mesos::TaskStatus& InstanceCurrent::task_status() const {
  return task_status_ != NULL ? *task_status_ : *default_instance_->task_status_;
}
inline ::mesos::TaskStatus* InstanceCurrent::mutable_task_status() {
  set_has_task_status();
  if (task_status_ == NULL) task_status_ = new ::mesos::TaskStatus;
  return task_status_;
}
inline ::mesos::TaskStatus* InstanceCurrent::release_task_status() {
  clear_has_task_status();
  ::mesos::TaskStatus* temp = task_status_;
  task_status_ = NULL;
  return temp;
}
inline void InstanceCurrent::set_allocated_task_status(::mesos::TaskStatus* task_status) {
  delete task_status_;
  task_status_ = task_status;
  if (task_status) {
    set_has_task_status();
  } else {
    clear_has_task_status();
  }
}

// repeated uint32 ports = 4;
inline int InstanceCurrent::ports_size() const {
  return ports_.size();
}
inline void InstanceCurrent::clear_ports() {
  ports_.Clear();
}
inline ::google::protobuf::uint32 InstanceCurrent::ports(int index) const {
  return ports_.Get(index);
}
inline void InstanceCurrent::set_ports(int index, ::google::protobuf::uint32 value) {
  ports_.Set(index, value);
}
inline void InstanceCurrent::add_ports(::google::protobuf::uint32 value) {
  ports_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
InstanceCurrent::ports() const {
  return ports_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
InstanceCurrent::mutable_ports() {
  return &ports_;
}

// optional string hostname = 5;
inline bool InstanceCurrent::has_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstanceCurrent::set_has_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstanceCurrent::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstanceCurrent::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& InstanceCurrent::hostname() const {
  return *hostname_;
}
inline void InstanceCurrent::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void InstanceCurrent::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void InstanceCurrent::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstanceCurrent::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* InstanceCurrent::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstanceCurrent::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InstancesCurrent

// repeated .arangodb.InstanceCurrent entries = 1;
inline int InstancesCurrent::entries_size() const {
  return entries_.size();
}
inline void InstancesCurrent::clear_entries() {
  entries_.Clear();
}
inline const ::arangodb::InstanceCurrent& InstancesCurrent::entries(int index) const {
  return entries_.Get(index);
}
inline ::arangodb::InstanceCurrent* InstancesCurrent::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::arangodb::InstanceCurrent* InstancesCurrent::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::arangodb::InstanceCurrent >&
InstancesCurrent::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::arangodb::InstanceCurrent >*
InstancesCurrent::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// Current

// required .arangodb.ResourcesCurrent agency_resources = 1;
inline bool Current::has_agency_resources() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Current::set_has_agency_resources() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Current::clear_has_agency_resources() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Current::clear_agency_resources() {
  if (agency_resources_ != NULL) agency_resources_->::arangodb::ResourcesCurrent::Clear();
  clear_has_agency_resources();
}
inline const ::arangodb::ResourcesCurrent& Current::agency_resources() const {
  return agency_resources_ != NULL ? *agency_resources_ : *default_instance_->agency_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::mutable_agency_resources() {
  set_has_agency_resources();
  if (agency_resources_ == NULL) agency_resources_ = new ::arangodb::ResourcesCurrent;
  return agency_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::release_agency_resources() {
  clear_has_agency_resources();
  ::arangodb::ResourcesCurrent* temp = agency_resources_;
  agency_resources_ = NULL;
  return temp;
}
inline void Current::set_allocated_agency_resources(::arangodb::ResourcesCurrent* agency_resources) {
  delete agency_resources_;
  agency_resources_ = agency_resources;
  if (agency_resources) {
    set_has_agency_resources();
  } else {
    clear_has_agency_resources();
  }
}

// required .arangodb.ResourcesCurrent coordinator_resources = 2;
inline bool Current::has_coordinator_resources() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Current::set_has_coordinator_resources() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Current::clear_has_coordinator_resources() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Current::clear_coordinator_resources() {
  if (coordinator_resources_ != NULL) coordinator_resources_->::arangodb::ResourcesCurrent::Clear();
  clear_has_coordinator_resources();
}
inline const ::arangodb::ResourcesCurrent& Current::coordinator_resources() const {
  return coordinator_resources_ != NULL ? *coordinator_resources_ : *default_instance_->coordinator_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::mutable_coordinator_resources() {
  set_has_coordinator_resources();
  if (coordinator_resources_ == NULL) coordinator_resources_ = new ::arangodb::ResourcesCurrent;
  return coordinator_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::release_coordinator_resources() {
  clear_has_coordinator_resources();
  ::arangodb::ResourcesCurrent* temp = coordinator_resources_;
  coordinator_resources_ = NULL;
  return temp;
}
inline void Current::set_allocated_coordinator_resources(::arangodb::ResourcesCurrent* coordinator_resources) {
  delete coordinator_resources_;
  coordinator_resources_ = coordinator_resources;
  if (coordinator_resources) {
    set_has_coordinator_resources();
  } else {
    clear_has_coordinator_resources();
  }
}

// required .arangodb.ResourcesCurrent primary_dbserver_resources = 3;
inline bool Current::has_primary_dbserver_resources() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Current::set_has_primary_dbserver_resources() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Current::clear_has_primary_dbserver_resources() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Current::clear_primary_dbserver_resources() {
  if (primary_dbserver_resources_ != NULL) primary_dbserver_resources_->::arangodb::ResourcesCurrent::Clear();
  clear_has_primary_dbserver_resources();
}
inline const ::arangodb::ResourcesCurrent& Current::primary_dbserver_resources() const {
  return primary_dbserver_resources_ != NULL ? *primary_dbserver_resources_ : *default_instance_->primary_dbserver_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::mutable_primary_dbserver_resources() {
  set_has_primary_dbserver_resources();
  if (primary_dbserver_resources_ == NULL) primary_dbserver_resources_ = new ::arangodb::ResourcesCurrent;
  return primary_dbserver_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::release_primary_dbserver_resources() {
  clear_has_primary_dbserver_resources();
  ::arangodb::ResourcesCurrent* temp = primary_dbserver_resources_;
  primary_dbserver_resources_ = NULL;
  return temp;
}
inline void Current::set_allocated_primary_dbserver_resources(::arangodb::ResourcesCurrent* primary_dbserver_resources) {
  delete primary_dbserver_resources_;
  primary_dbserver_resources_ = primary_dbserver_resources;
  if (primary_dbserver_resources) {
    set_has_primary_dbserver_resources();
  } else {
    clear_has_primary_dbserver_resources();
  }
}

// required .arangodb.ResourcesCurrent secondary_dbserver_resources = 4;
inline bool Current::has_secondary_dbserver_resources() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Current::set_has_secondary_dbserver_resources() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Current::clear_has_secondary_dbserver_resources() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Current::clear_secondary_dbserver_resources() {
  if (secondary_dbserver_resources_ != NULL) secondary_dbserver_resources_->::arangodb::ResourcesCurrent::Clear();
  clear_has_secondary_dbserver_resources();
}
inline const ::arangodb::ResourcesCurrent& Current::secondary_dbserver_resources() const {
  return secondary_dbserver_resources_ != NULL ? *secondary_dbserver_resources_ : *default_instance_->secondary_dbserver_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::mutable_secondary_dbserver_resources() {
  set_has_secondary_dbserver_resources();
  if (secondary_dbserver_resources_ == NULL) secondary_dbserver_resources_ = new ::arangodb::ResourcesCurrent;
  return secondary_dbserver_resources_;
}
inline ::arangodb::ResourcesCurrent* Current::release_secondary_dbserver_resources() {
  clear_has_secondary_dbserver_resources();
  ::arangodb::ResourcesCurrent* temp = secondary_dbserver_resources_;
  secondary_dbserver_resources_ = NULL;
  return temp;
}
inline void Current::set_allocated_secondary_dbserver_resources(::arangodb::ResourcesCurrent* secondary_dbserver_resources) {
  delete secondary_dbserver_resources_;
  secondary_dbserver_resources_ = secondary_dbserver_resources;
  if (secondary_dbserver_resources) {
    set_has_secondary_dbserver_resources();
  } else {
    clear_has_secondary_dbserver_resources();
  }
}

// required .arangodb.InstancesCurrent agents = 5;
inline bool Current::has_agents() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Current::set_has_agents() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Current::clear_has_agents() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Current::clear_agents() {
  if (agents_ != NULL) agents_->::arangodb::InstancesCurrent::Clear();
  clear_has_agents();
}
inline const ::arangodb::InstancesCurrent& Current::agents() const {
  return agents_ != NULL ? *agents_ : *default_instance_->agents_;
}
inline ::arangodb::InstancesCurrent* Current::mutable_agents() {
  set_has_agents();
  if (agents_ == NULL) agents_ = new ::arangodb::InstancesCurrent;
  return agents_;
}
inline ::arangodb::InstancesCurrent* Current::release_agents() {
  clear_has_agents();
  ::arangodb::InstancesCurrent* temp = agents_;
  agents_ = NULL;
  return temp;
}
inline void Current::set_allocated_agents(::arangodb::InstancesCurrent* agents) {
  delete agents_;
  agents_ = agents;
  if (agents) {
    set_has_agents();
  } else {
    clear_has_agents();
  }
}

// required .arangodb.InstancesCurrent coordinators = 6;
inline bool Current::has_coordinators() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Current::set_has_coordinators() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Current::clear_has_coordinators() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Current::clear_coordinators() {
  if (coordinators_ != NULL) coordinators_->::arangodb::InstancesCurrent::Clear();
  clear_has_coordinators();
}
inline const ::arangodb::InstancesCurrent& Current::coordinators() const {
  return coordinators_ != NULL ? *coordinators_ : *default_instance_->coordinators_;
}
inline ::arangodb::InstancesCurrent* Current::mutable_coordinators() {
  set_has_coordinators();
  if (coordinators_ == NULL) coordinators_ = new ::arangodb::InstancesCurrent;
  return coordinators_;
}
inline ::arangodb::InstancesCurrent* Current::release_coordinators() {
  clear_has_coordinators();
  ::arangodb::InstancesCurrent* temp = coordinators_;
  coordinators_ = NULL;
  return temp;
}
inline void Current::set_allocated_coordinators(::arangodb::InstancesCurrent* coordinators) {
  delete coordinators_;
  coordinators_ = coordinators;
  if (coordinators) {
    set_has_coordinators();
  } else {
    clear_has_coordinators();
  }
}

// required .arangodb.InstancesCurrent primary_dbservers = 7;
inline bool Current::has_primary_dbservers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Current::set_has_primary_dbservers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Current::clear_has_primary_dbservers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Current::clear_primary_dbservers() {
  if (primary_dbservers_ != NULL) primary_dbservers_->::arangodb::InstancesCurrent::Clear();
  clear_has_primary_dbservers();
}
inline const ::arangodb::InstancesCurrent& Current::primary_dbservers() const {
  return primary_dbservers_ != NULL ? *primary_dbservers_ : *default_instance_->primary_dbservers_;
}
inline ::arangodb::InstancesCurrent* Current::mutable_primary_dbservers() {
  set_has_primary_dbservers();
  if (primary_dbservers_ == NULL) primary_dbservers_ = new ::arangodb::InstancesCurrent;
  return primary_dbservers_;
}
inline ::arangodb::InstancesCurrent* Current::release_primary_dbservers() {
  clear_has_primary_dbservers();
  ::arangodb::InstancesCurrent* temp = primary_dbservers_;
  primary_dbservers_ = NULL;
  return temp;
}
inline void Current::set_allocated_primary_dbservers(::arangodb::InstancesCurrent* primary_dbservers) {
  delete primary_dbservers_;
  primary_dbservers_ = primary_dbservers;
  if (primary_dbservers) {
    set_has_primary_dbservers();
  } else {
    clear_has_primary_dbservers();
  }
}

// required .arangodb.InstancesCurrent secondary_dbservers = 8;
inline bool Current::has_secondary_dbservers() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Current::set_has_secondary_dbservers() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Current::clear_has_secondary_dbservers() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Current::clear_secondary_dbservers() {
  if (secondary_dbservers_ != NULL) secondary_dbservers_->::arangodb::InstancesCurrent::Clear();
  clear_has_secondary_dbservers();
}
inline const ::arangodb::InstancesCurrent& Current::secondary_dbservers() const {
  return secondary_dbservers_ != NULL ? *secondary_dbservers_ : *default_instance_->secondary_dbservers_;
}
inline ::arangodb::InstancesCurrent* Current::mutable_secondary_dbservers() {
  set_has_secondary_dbservers();
  if (secondary_dbservers_ == NULL) secondary_dbservers_ = new ::arangodb::InstancesCurrent;
  return secondary_dbservers_;
}
inline ::arangodb::InstancesCurrent* Current::release_secondary_dbservers() {
  clear_has_secondary_dbservers();
  ::arangodb::InstancesCurrent* temp = secondary_dbservers_;
  secondary_dbservers_ = NULL;
  return temp;
}
inline void Current::set_allocated_secondary_dbservers(::arangodb::InstancesCurrent* secondary_dbservers) {
  delete secondary_dbservers_;
  secondary_dbservers_ = secondary_dbservers;
  if (secondary_dbservers) {
    set_has_secondary_dbservers();
  } else {
    clear_has_secondary_dbservers();
  }
}

// required bool cluster_complete = 9;
inline bool Current::has_cluster_complete() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Current::set_has_cluster_complete() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Current::clear_has_cluster_complete() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Current::clear_cluster_complete() {
  cluster_complete_ = false;
  clear_has_cluster_complete();
}
inline bool Current::cluster_complete() const {
  return cluster_complete_;
}
inline void Current::set_cluster_complete(bool value) {
  set_has_cluster_complete();
  cluster_complete_ = value;
}

// required bool cluster_bootstrappedDBservers = 10;
inline bool Current::has_cluster_bootstrappeddbservers() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Current::set_has_cluster_bootstrappeddbservers() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Current::clear_has_cluster_bootstrappeddbservers() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Current::clear_cluster_bootstrappeddbservers() {
  cluster_bootstrappeddbservers_ = false;
  clear_has_cluster_bootstrappeddbservers();
}
inline bool Current::cluster_bootstrappeddbservers() const {
  return cluster_bootstrappeddbservers_;
}
inline void Current::set_cluster_bootstrappeddbservers(bool value) {
  set_has_cluster_bootstrappeddbservers();
  cluster_bootstrappeddbservers_ = value;
}

// required bool cluster_upgradedDB = 11;
inline bool Current::has_cluster_upgradeddb() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Current::set_has_cluster_upgradeddb() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Current::clear_has_cluster_upgradeddb() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Current::clear_cluster_upgradeddb() {
  cluster_upgradeddb_ = false;
  clear_has_cluster_upgradeddb();
}
inline bool Current::cluster_upgradeddb() const {
  return cluster_upgradeddb_;
}
inline void Current::set_cluster_upgradeddb(bool value) {
  set_has_cluster_upgradeddb();
  cluster_upgradeddb_ = value;
}

// required bool cluster_bootstrappedCoordinators = 12;
inline bool Current::has_cluster_bootstrappedcoordinators() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Current::set_has_cluster_bootstrappedcoordinators() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Current::clear_has_cluster_bootstrappedcoordinators() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Current::clear_cluster_bootstrappedcoordinators() {
  cluster_bootstrappedcoordinators_ = false;
  clear_has_cluster_bootstrappedcoordinators();
}
inline bool Current::cluster_bootstrappedcoordinators() const {
  return cluster_bootstrappedcoordinators_;
}
inline void Current::set_cluster_bootstrappedcoordinators(bool value) {
  set_has_cluster_bootstrappedcoordinators();
  cluster_bootstrappedcoordinators_ = value;
}

// required bool cluster_initialized = 13;
inline bool Current::has_cluster_initialized() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Current::set_has_cluster_initialized() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Current::clear_has_cluster_initialized() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Current::clear_cluster_initialized() {
  cluster_initialized_ = false;
  clear_has_cluster_initialized();
}
inline bool Current::cluster_initialized() const {
  return cluster_initialized_;
}
inline void Current::set_cluster_initialized(bool value) {
  set_has_cluster_initialized();
  cluster_initialized_ = value;
}

// -------------------------------------------------------------------

// State

// optional .mesos.FrameworkID framework_id = 1;
inline bool State::has_framework_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::set_has_framework_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void State::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
inline const ::mesos::FrameworkID& State::framework_id() const {
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
inline ::mesos::FrameworkID* State::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) framework_id_ = new ::mesos::FrameworkID;
  return framework_id_;
}
inline ::mesos::FrameworkID* State::release_framework_id() {
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
inline void State::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
}

// required .arangodb.Targets targets = 2;
inline bool State::has_targets() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::set_has_targets() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State::clear_has_targets() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void State::clear_targets() {
  if (targets_ != NULL) targets_->::arangodb::Targets::Clear();
  clear_has_targets();
}
inline const ::arangodb::Targets& State::targets() const {
  return targets_ != NULL ? *targets_ : *default_instance_->targets_;
}
inline ::arangodb::Targets* State::mutable_targets() {
  set_has_targets();
  if (targets_ == NULL) targets_ = new ::arangodb::Targets;
  return targets_;
}
inline ::arangodb::Targets* State::release_targets() {
  clear_has_targets();
  ::arangodb::Targets* temp = targets_;
  targets_ = NULL;
  return temp;
}
inline void State::set_allocated_targets(::arangodb::Targets* targets) {
  delete targets_;
  targets_ = targets;
  if (targets) {
    set_has_targets();
  } else {
    clear_has_targets();
  }
}

// required .arangodb.Plan plan = 3;
inline bool State::has_plan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State::set_has_plan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void State::clear_has_plan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void State::clear_plan() {
  if (plan_ != NULL) plan_->::arangodb::Plan::Clear();
  clear_has_plan();
}
inline const ::arangodb::Plan& State::plan() const {
  return plan_ != NULL ? *plan_ : *default_instance_->plan_;
}
inline ::arangodb::Plan* State::mutable_plan() {
  set_has_plan();
  if (plan_ == NULL) plan_ = new ::arangodb::Plan;
  return plan_;
}
inline ::arangodb::Plan* State::release_plan() {
  clear_has_plan();
  ::arangodb::Plan* temp = plan_;
  plan_ = NULL;
  return temp;
}
inline void State::set_allocated_plan(::arangodb::Plan* plan) {
  delete plan_;
  plan_ = plan;
  if (plan) {
    set_has_plan();
  } else {
    clear_has_plan();
  }
}

// required .arangodb.Current current = 4;
inline bool State::has_current() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void State::set_has_current() {
  _has_bits_[0] |= 0x00000008u;
}
inline void State::clear_has_current() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void State::clear_current() {
  if (current_ != NULL) current_->::arangodb::Current::Clear();
  clear_has_current();
}
inline const ::arangodb::Current& State::current() const {
  return current_ != NULL ? *current_ : *default_instance_->current_;
}
inline ::arangodb::Current* State::mutable_current() {
  set_has_current();
  if (current_ == NULL) current_ = new ::arangodb::Current;
  return current_;
}
inline ::arangodb::Current* State::release_current() {
  clear_has_current();
  ::arangodb::Current* temp = current_;
  current_ = NULL;
  return temp;
}
inline void State::set_allocated_current(::arangodb::Current* current) {
  delete current_;
  current_ = current;
  if (current) {
    set_has_current();
  } else {
    clear_has_current();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace arangodb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arangodb::TaskPlanState>() {
  return ::arangodb::TaskPlanState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arangodb::InstanceCurrentState>() {
  return ::arangodb::InstanceCurrentState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_arangodb_2eproto__INCLUDED
